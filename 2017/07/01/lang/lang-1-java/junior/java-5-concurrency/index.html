<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="java并发篇">
<meta property="og:type" content="article">
<meta property="og:title" content="concurrency">
<meta property="og:url" content="http://example.com/2017/07/01/lang/lang-1-java/junior/java-5-concurrency/index.html">
<meta property="og:site_name" content="朱继鹏的博客">
<meta property="og:description" content="java并发篇">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-06-30T17:05:00.000Z">
<meta property="article:modified_time" content="2024-04-08T12:07:22.543Z">
<meta property="article:author" content="朱继鹏">
<meta property="article:tag" content="+ java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2017/07/01/lang/lang-1-java/junior/java-5-concurrency/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>concurrency | 朱继鹏的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">朱继鹏的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">天道酬勤，全栈不停</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/07/01/lang/lang-1-java/junior/java-5-concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar/zhujipeng.jpg">
      <meta itemprop="name" content="朱继鹏">
      <meta itemprop="description" content="在全栈的路上狂奔不止">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朱继鹏的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          concurrency
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-07-01 01:05:00" itemprop="dateCreated datePublished" datetime="2017-07-01T01:05:00+08:00">2017-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-08 20:07:22" itemprop="dateModified" datetime="2024-04-08T20:07:22+08:00">2024-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/lang-java-junior/" itemprop="url" rel="index"><span itemprop="name">+ lang + java + junior</span></a>
                </span>
            </span>

          
            <div class="post-description">java并发篇</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38721537/article/details/124581201">Thread详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/alex_xfboy/article/details/90722654">线程上下文切换详解</a></li>
</ul>
</blockquote>
<ul>
<li>线程（Thread）是执行任务的基本单位</li>
<li>进程（Process）是分配资源的基本单位</li>
</ul>
<h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangyechi/article/details/88079983">Thread之线程的创建方式详解</a></li>
</ul>
</blockquote>
<ul>
<li>继承Thread，并实现run方法，然后调用start启动</li>
<li>实现Runnable，并作为target传递给线程进行启动</li>
<li>实现Callable，并用FutureTask包装后作为target传递给线程进行启动</li>
<li>使用线程池的execute方法执行Runnable</li>
<li>使用线程池的submit方法提交Runnable或者Callable</li>
<li>使用CompletableFuture类</li>
</ul>
<h3 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_37139197/article/details/81989749">Thread之线程的优先级详解</a></li>
</ul>
</blockquote>
<h3 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40087231/article/details/90031253">Thread之守护线程入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41063141/article/details/91939540">Thread之守护线程详解</a></li>
</ul>
</blockquote>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/muzhixi/article/details/105197446">Thread之线程状态入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Elephant_King/article/details/122559577">Thread之线程状态详解</a></li>
</ul>
</blockquote>
<p>NEW、READY、RUNNING、WAITING、TIMED_WAITING、BLOCKED、TERMINATED</p>
<ul>
<li>NEW（新建）：创建线程后进入此状态</li>
<li>READY（就绪）：创建后调用Thread.start或者运行时调用Thread.yield进入此状态</li>
<li>RUNNING（运行）：获取资源（cpu和lock）成功后进入此状态</li>
<li>WAITING（等待）：调用Thread.join、Object.wait、LockSupport.park的非超时方法后进入此状态</li>
<li>TIMED_WAITING（超时等待）：调用Thread.sleep、Thread.join、Object.wait、LockSupport.park的超时方法后进入此状态</li>
<li>BLOCKED（阻塞）：获取lock失败后进入此状态</li>
<li>TERMINATED（死亡）：结束线程后进入此状态</li>
</ul>
<h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lbh199466/article/details/104691252">Thread之线程资源详解</a></li>
</ul>
</blockquote>
<ul>
<li>cpu：中央处理器资源</li>
<li>lock：锁资源</li>
</ul>
<h3 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41540362/article/details/102809420">Thread之线程控制入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011047968/article/details/106954649">Thread之线程控制详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/fengyuyeguirenenen/article/details/122589605">Thread之线程控制之Thread.sleep(0)的意义</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_29384657/article/details/52228578">Thread之线程控制之join详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010983881/article/details/80257703">Thread之线程控制之join原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/shangguoli/article/details/108453551">Thread之线程控制之join唤醒</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/succing/article/details/123023851">Thread之线程控制之join和锁</a></li>
</ul>
</blockquote>
<ul>
<li>Thread.yield：让出cpu资源并进入<code>就绪状态</code>，<code>不释放锁资源</code></li>
<li>Thread.sleep：让出cpu资源并进入<code>等待状态</code>，<code>不释放锁资源</code></li>
<li>Thread.join：让出cpu资源并进入<code>等待状态</code>，<code>会释放锁资源</code></li>
</ul>
<blockquote>
<p>ps：join的作用是阻塞当前线程c（调用t.join的那个线程）并等待线程t结束后继续运行<br>ps：join内部是基于wait（当前线程c调用线程t的wait方法后在t上wait）实现的，JVM会在线程t结束后自动notify在t上wait的线程</p>
</blockquote>
<h3 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41512783/article/details/108943193">Thread之线程中断入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/hl_java/article/details/79162097">Thread之线程中断详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40378837/article/details/116503069">Thread之InterruptedException详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yytree123/article/details/108896876">Thread之interrupt和interrupted的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39682377/article/details/81449451">Thread之interrupted和isInterrupted的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34167819/article/details/85629990">Thread之阻塞IO如何中断</a></li>
</ul>
</blockquote>
<blockquote>
<p>ps： <code>interrupt</code> 可以中断 <code>sleep</code> 、 <code>join</code> 、 <code>wait</code> 等那些判断了 <code>isInterrupted</code> 的操作</p>
</blockquote>
<h3 id="Terminate"><a href="#Terminate" class="headerlink" title="Terminate"></a>Terminate</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26482855/article/details/118676625">Thread之线程终止入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/x541211190/article/details/109428620">Thread之线程终止详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44715697/article/details/114494899">Thread之不推荐使用volatile修饰的标记终止线程</a></li>
</ul>
</blockquote>
<p>如果线程在循环体中阻塞了（比如阻塞队列），是无法继续执行到volatile修饰的标记位置的，但是阻塞的线程是可以响应interrupt信号并抛出InterruptedException的</p>
<h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated"></a>Deprecated</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/gediseer/article/details/53835295">Thread之废弃的方法入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/hchaoh/article/details/103907661">Thread之废弃的方法详解</a></li>
</ul>
</blockquote>
<p>suspend&#x2F;resume、stop、destroy</p>
<ul>
<li>suspend：不会释放锁，会导致死锁问题</li>
<li>stop：会立即终止线程，导致操作被中断，会导致数据不一致和资源未释放等问题</li>
<li>destroy：从来都没有被实现过，且已经被废弃了（相当于suspend且没有后续的resume）</li>
</ul>
<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ThinkWon/article/details/102021274">线程和进程的区别详解</a></li>
</ul>
</blockquote>
<ul>
<li>线程是任务调度和指令执行的最小单元，进程是资源分配的最小单元</li>
<li>线程开销小，进程开销大，线程又被称作轻量级进程</li>
<li>进程可以包含多个线程，至少包含一个线程</li>
<li>同一个进程的线程共享资源，不同进程之间的资源相互独立</li>
<li>线程异常如果不处理会导致线程所属的进程挂掉，进程挂掉则不会影响其他进程</li>
</ul>
<h3 id="Runnable和Callable的区别"><a href="#Runnable和Callable的区别" class="headerlink" title="Runnable和Callable的区别"></a>Runnable和Callable的区别</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_39634657/article/details/81456810">Runnable和Callable的区别</a></li>
</ul>
</blockquote>
<ul>
<li>Runnable不能获取返回值</li>
<li>Callable和Future、FutureTask配合可以获取返回值</li>
</ul>
<h3 id="Thread的start和run的区别"><a href="#Thread的start和run的区别" class="headerlink" title="Thread的start和run的区别"></a>Thread的start和run的区别</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Mypromise_TFS/article/details/81096007">run和start的区别</a></li>
</ul>
</blockquote>
<ul>
<li>start是本地方法，会启动线程</li>
<li>run是普通方法，不会启动线程</li>
</ul>
<blockquote>
<p>start调用了start0，start0是本地方法</p>
</blockquote>
<h3 id="Thread的start能调用多次吗"><a href="#Thread的start能调用多次吗" class="headerlink" title="Thread的start能调用多次吗"></a>Thread的start能调用多次吗</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Vae023/article/details/106985222">Thread的start能调用多次吗</a></li>
</ul>
</blockquote>
<p>不能，再次调用时会检测到状态变化后抛出 <code>IllegalThreadStateException</code> 异常</p>
<h3 id="Thread的sleep和yield的区别"><a href="#Thread的sleep和yield的区别" class="headerlink" title="Thread的sleep和yield的区别"></a>Thread的sleep和yield的区别</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/rod0320/article/details/123167174">sleep和yield的区别</a></li>
</ul>
</blockquote>
<ul>
<li>方法：都是Thread的静态方法</li>
<li>锁：都不释放锁</li>
<li>状态：sleep进入到等待状态，yield进入到就绪状态</li>
</ul>
<h3 id="Thread的sleep和join的区别"><a href="#Thread的sleep和join的区别" class="headerlink" title="Thread的sleep和join的区别"></a>Thread的sleep和join的区别</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/rod0320/article/details/123167174">sleep和join的区别</a></li>
</ul>
</blockquote>
<ul>
<li>方法：sleep是Thread的静态方法，join是Thread的实例方法</li>
<li>锁：sleep不释放锁，join释放锁</li>
<li>状态：都是进入到等待状态</li>
</ul>
<h3 id="Thread的join和wait的区别"><a href="#Thread的join和wait的区别" class="headerlink" title="Thread的join和wait的区别"></a>Thread的join和wait的区别</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/rod0320/article/details/123167174">join和wait的区别</a></li>
</ul>
</blockquote>
<ul>
<li>方法：join是Thread的实例方法，wait是Object的实例方法</li>
<li>锁：都会释放锁</li>
<li>状态：都是进入到等待状态</li>
</ul>
<blockquote>
<p>ps：join是通过wait来实现的，所以和wait没区别</p>
</blockquote>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="Basic-1"><a href="#Basic-1" class="headerlink" title="Basic"></a>Basic</h2><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lisheng19870305/article/details/110100947">ThreadLocal入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010445301/article/details/111322569">ThreadLocal进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangnanwlw/article/details/108866086">ThreadLocal详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42285585/article/details/119035982">ThreadLocal精进</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/meism5/article/details/90413860">ThreadLocal原理入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38293564/article/details/80459827">ThreadLocal原理进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44377709/article/details/105962734">ThreadLocal原理详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39192827/article/details/85611873">ThreadLocal之强弱引用</a></li>
</ul>
</blockquote>
<h3 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN2497242041/article/details/120192343">ThreadLocal使用场景</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37609060/article/details/122410302">ThreadLocal保证DateFormat的线程安全</a></li>
</ul>
</blockquote>
<h3 id="Leak"><a href="#Leak" class="headerlink" title="Leak"></a>Leak</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u022812849/article/details/107513876">ThreadLocal内存泄漏入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/y5492853/article/details/123984840">ThreadLocal内存泄漏详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Weixiaohuai/article/details/120351275">内存泄漏详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sushuiyuzhou/article/details/108463530">内存溢出详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/golden_zhj/article/details/86574481">内存泄漏和内存溢出的区别入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44798288/article/details/119641944">内存泄漏和内存溢出的区别详解</a></li>
</ul>
</blockquote>
<h3 id="Inherit"><a href="#Inherit" class="headerlink" title="Inherit"></a>Inherit</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/a837199685/article/details/52712547">ThreadLocal之子线程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/liubenlong007/article/details/107050929">ThreadLocal之线程池</a></li>
</ul>
</blockquote>
<h2 id="Question-1"><a href="#Question-1" class="headerlink" title="Question"></a>Question</h2><h3 id="ThreadLocal为什么会内存泄漏"><a href="#ThreadLocal为什么会内存泄漏" class="headerlink" title="ThreadLocal为什么会内存泄漏"></a>ThreadLocal为什么会内存泄漏</h3><ol>
<li>ThreadLocal是基于ThreadLocalMap实现的</li>
<li>Thread引用了ThreadLocalMap</li>
<li>ThreadLocalMap引用了key和value</li>
<li>key弱引用了ThreadLocal</li>
<li>当ThreadLocal不再使用时，即没有强引用时</li>
<li>由于key是弱引用，所以ThreadLocal会被回收</li>
<li>此时无法通过ThreadLocal访问value，value应该被回收</li>
<li>由于Thread通过ThreadLocalMap间接强引用了value，所以要先回收Thread</li>
<li>但是如果Thread是线程池时，Thread不能被回收，所以value不能回收</li>
<li>此时value既不能访问又不能回收，就造成了内存泄漏</li>
</ol>
<blockquote>
<p>ps：ThreadLocal在get和set时会自动检测哪些key指向null的entry并清除，可以一定程度减轻内存泄漏的影响</p>
</blockquote>
<h3 id="ThreadLocalMap的key为什么是弱引用"><a href="#ThreadLocalMap的key为什么是弱引用" class="headerlink" title="ThreadLocalMap的key为什么是弱引用"></a>ThreadLocalMap的key为什么是弱引用</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/BruceLiu_code/article/details/118518148">ThreadLocalMap的key为什么是弱引用</a></li>
</ul>
</blockquote>
<ul>
<li>如果ThreadLocalMap的key为强引用，此时Thread就会通过ThreadLocalMap间接强引用了key</li>
<li>如果Thread不回收，比如是线程池时，即使ThreadLocal不再使用了</li>
<li>由于ThreadLocal还被Thread引用着，所以ThreadLocal会无法回收而导致内存泄漏</li>
</ul>
<h3 id="ThreadLocalMap的value为什么是强引用"><a href="#ThreadLocalMap的value为什么是强引用" class="headerlink" title="ThreadLocalMap的value为什么是强引用"></a>ThreadLocalMap的value为什么是强引用</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/foxException/article/details/123496254">ThreadLocalMap的value为什么是强引用</a></li>
</ul>
</blockquote>
<p>如果value是弱引用，垃圾回收后value指向了null，此时ThreadLocal还活着却获取不到value对象就不符合逻辑</p>
<h3 id="ThreadLocalMap为什么不用Thread做key"><a href="#ThreadLocalMap为什么不用Thread做key" class="headerlink" title="ThreadLocalMap为什么不用Thread做key"></a>ThreadLocalMap为什么不用Thread做key</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_72088858/article/details/126699225">ThreadLocalMap为什么不用Thread做key</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/trayvonnn/article/details/112524314">HashMap线程不安全导致的死循环和数据丢失</a></li>
</ul>
</blockquote>
<ul>
<li>如果用Thread做key（且ThreadLocalMap是ThreadLocal的实例），就会有多个线程访问map，就需要保证线程安全，复杂性会提高，并且并发性也会降低</li>
<li>如果用ThreadLocal做key（且ThreadLocalMap是Thread的实例），那么访问map的线程都是持有map的那一个线程，就不需要保证线程安全，复杂性会降低，并且并发性也会提高</li>
<li>如果是用二级map，那就会和ThreadLocalMap做key一样，就会有多个线程访问map，就需要保证线程安全，还需要两次寻址，复杂性会更高，并且并发性也会更低</li>
</ul>
<h3 id="ThreadLocal为什么要定义成静态变量"><a href="#ThreadLocal为什么要定义成静态变量" class="headerlink" title="ThreadLocal为什么要定义成静态变量"></a>ThreadLocal为什么要定义成静态变量</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/justlpf/article/details/106097539">ThreadLocal为什么要定义成静态变量</a></li>
</ul>
</blockquote>
<p>定义成实例变量，容易重复创建，造成内存浪费</p>
<h3 id="ThreadLocal和局部变量的区别"><a href="#ThreadLocal和局部变量的区别" class="headerlink" title="ThreadLocal和局部变量的区别"></a>ThreadLocal和局部变量的区别</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yk20091201/article/details/88844954">ThreadLocal和局部变量的区别</a></li>
</ul>
</blockquote>
<p>ThreadLocal是线程（隔离）变量，局部变量是方法（隔离）变量</p>
<blockquote>
<p>ps：局部变量不逃逸时本质上还是线程（隔离）变量，因为局部变量属于方法私有，方法属于线程私有</p>
</blockquote>
<h1 id="Safe"><a href="#Safe" class="headerlink" title="Safe"></a>Safe</h1><h2 id="Basic-2"><a href="#Basic-2" class="headerlink" title="Basic"></a>Basic</h2><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/q669239799/article/details/90614077">线程安全详解</a></li>
</ul>
</blockquote>
<ul>
<li>不可变：不可变对象一定是安全的</li>
<li>绝对安全：对象的单个操作和复合操作都是安全的</li>
<li>相对安全：对象的单个操作是安全的，复合操作需要额外的同步措施来保证安全</li>
<li>兼容安全：对象的所有操作都不安全，但可以通过额外的同步措施来保证安全</li>
<li>安全对立：即使采取了额外的同步措施也无法保证安全</li>
</ul>
<h2 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h2><h3 id="线程安全之基本原则"><a href="#线程安全之基本原则" class="headerlink" title="线程安全之基本原则"></a>线程安全之基本原则</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/songzi1228/article/details/102506136">线程安全之基本原则入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_58196614/article/details/126257857">线程安全之基本原则详解</a></li>
</ul>
</blockquote>
<ul>
<li>原子性：一系列操作不可被中断（synchronized、lock、atomic）</li>
<li>可见性：对数据的修改可以及时地被其他线程看到（synchronized、lock、volatile）</li>
<li>有序性：指令没有被重新排列（synchronized、lock、volatile）</li>
</ul>
<h3 id="线程安全之实现方案"><a href="#线程安全之实现方案" class="headerlink" title="线程安全之实现方案"></a>线程安全之实现方案</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lililuni/article/details/86534388">线程安全之实现方案入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014454538/article/details/98515807">线程安全之实现方案详解</a></li>
</ul>
</blockquote>
<ul>
<li>共享<ul>
<li>不可变<ul>
<li>不可变对象（Immutable）：通过对象不可变机制实现</li>
</ul>
</li>
<li>访问控制<ul>
<li>悲观锁（LOCK）：通过Mutex机制实现</li>
<li>乐观锁（CAS）：通过CAS机制实现</li>
</ul>
</li>
<li>读写分离<ul>
<li>写时复制（COW）：通过COW机制实现</li>
</ul>
</li>
</ul>
</li>
<li>私有<ul>
<li>局部变量（LocalVariable）：通过方法私有机制实现</li>
<li>线程变量（ThreadLocal）：通过线程私有机制实现</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：局部变量不逃逸时本质上还是线程（隔离）变量，因为局部变量属于方法私有，方法属于线程私有</p>
</blockquote>
<h3 id="线程安全之变量安全"><a href="#线程安全之变量安全" class="headerlink" title="线程安全之变量安全"></a>线程安全之变量安全</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/aaa1117a8w5s6d/article/details/8295527">线程安全之各种变量详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42924666/article/details/121293321">线程安全之静态变量详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/nihui123/article/details/102824471">线程安全之实例变量详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44143902/article/details/116067285">线程安全之局部变量详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/f641385712/article/details/104573489">线程安全之线程变量详解</a></li>
</ul>
</blockquote>
<ul>
<li>可共享变量：静态变量、实例变量</li>
<li>只私有变量：局部变量、线程变量</li>
</ul>
<blockquote>
<p>ps：局部变量不逃逸时本质上还是线程（隔离）变量，因为局部变量属于方法私有，方法属于线程私有</p>
</blockquote>
<h3 id="线程安全之对象安全"><a href="#线程安全之对象安全" class="headerlink" title="线程安全之对象安全"></a>线程安全之对象安全</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/tiandao321/article/details/81300489">线程安全之对象安全入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22701869/article/details/107271921">线程安全之对象安全进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/CsWarmSun/article/details/122050509">线程安全之对象安全详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/dream_weave/article/details/105506795">线程安全之对象发布和逸出入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012190514/article/details/105083881">线程安全之对象发布和逸出详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/t_liuyong/article/details/86557031">线程安全之对象线程封闭入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010963948/article/details/77672429">线程安全之对象线程封闭详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/JokerLJG/article/details/125732788">线程安全之对象逃逸入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_72106802/article/details/126879788">线程安全之对象逃逸详解</a></li>
</ul>
</blockquote>
<ul>
<li>逸出：发布了未完成初始化的对象（创建对象时的指令重排会导致这种问题）</li>
<li>封闭：ThreadLocal</li>
<li>逃逸：局部变量暴露到方法之外了</li>
</ul>
<h3 id="线程安全之内存安全"><a href="#线程安全之内存安全" class="headerlink" title="线程安全之内存安全"></a>线程安全之内存安全</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sjdjdjdjahd/article/details/108858376">线程安全之内存安全入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31960623/article/details/115353065">线程安全之内存安全详解</a></li>
</ul>
</blockquote>
<p>JMM：Java Memory Model（java内存模型）</p>
<h2 id="Question-2"><a href="#Question-2" class="headerlink" title="Question"></a>Question</h2><h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/q669239799/article/details/90614077">什么是线程安全</a></li>
</ul>
</blockquote>
<p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的</p>
<h3 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全"></a>如何保证线程安全</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sumengnan/article/details/125024148">如何保证线程安全</a></li>
</ul>
</blockquote>
<ul>
<li>共享<ul>
<li>不可变<ul>
<li>不可变对象（Immutable）：通过对象不可变机制实现</li>
</ul>
</li>
<li>访问控制<ul>
<li>悲观锁（LOCK）：通过Mutex机制实现</li>
<li>乐观锁（CAS）：通过CAS机制实现</li>
</ul>
</li>
<li>读写分离<ul>
<li>写时复制（COW）：通过COW机制实现</li>
</ul>
</li>
</ul>
</li>
<li>私有<ul>
<li>方法局部对象（LocalVariable）：通过方法私有机制实现</li>
<li>线程隔离对象（ThreadLocal）：通过线程私有机制实现</li>
</ul>
</li>
</ul>
<h3 id="volatile能确保线程安全性吗"><a href="#volatile能确保线程安全性吗" class="headerlink" title="volatile能确保线程安全性吗"></a>volatile能确保线程安全性吗</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014191624/article/details/118991744">volatile能确保线程安全性吗</a></li>
</ul>
</blockquote>
<ul>
<li>volatile只能保证可见性和有序性，不能保证原子性</li>
<li>volatile只能保证原子操作（比如读和写操作）的线程安全</li>
<li>volatile不能保证非原子操作（比如自增和自减操作）的线程安全</li>
</ul>
<blockquote>
<p>所以volatile只能用来修饰哪些已经保证了原子性的操作，比如 <code>flag读写</code> 和 <code>cas操作</code></p>
</blockquote>
<blockquote>
<p>如果要想保证非原子性的操作的安全，可以使用 <code>atomic类</code> （atomic类内部依赖了volatile）</p>
</blockquote>
<h3 id="volatile的底层实现原理"><a href="#volatile的底层实现原理" class="headerlink" title="volatile的底层实现原理"></a>volatile的底层实现原理</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sufu1065/article/details/136385489">volatile的底层实现原理</a></li>
</ul>
</blockquote>
<ul>
<li>保证可见性：内存屏障</li>
<li>保证有序性：内存屏障</li>
</ul>
<blockquote>
<p>ps：内存屏障存在的意义就是为了解决程序在运行过程中出现的内存访问乱序的问题<br>ps：内存屏障是靠cpu的lock前缀指令实现的</p>
</blockquote>
<h3 id="单例模式的双检查实现中volatile的作用"><a href="#单例模式的双检查实现中volatile的作用" class="headerlink" title="单例模式的双检查实现中volatile的作用"></a>单例模式的双检查实现中volatile的作用</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/java_1996/article/details/87472644">单例模式的双检查实现中volatile的作用</a></li>
</ul>
</blockquote>
<ul>
<li>保证可见性：volatile可以保证可见性，避免双重判断时没有读到最新的状态从而重复创建对象</li>
<li>保证有序性：volatile会禁止指令重排，避免还没初始化完成的对象被提前暴露引用并使用</li>
</ul>
<h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_50370837/article/details/124471888">Lock详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38004638/article/details/114736314">Lock分类</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sumengnan/article/details/125034081">分布式锁实现方案</a></li>
</ul>
</blockquote>
<p>分布式锁实现方案</p>
<ul>
<li>mysql（不常用，性能比较差）</li>
<li>redis（较常用，性能比较好）</li>
<li>zookeeper（不常用，性能比较差）</li>
</ul>
<h2 id="Basic-3"><a href="#Basic-3" class="headerlink" title="Basic"></a>Basic</h2><h3 id="锁的作用"><a href="#锁的作用" class="headerlink" title="锁的作用"></a>锁的作用</h3><p>通过互斥机制和队列机制将并发操作变为串行操作从而保证并发操作的线程安全</p>
<h4 id="并发操作的控制方式"><a href="#并发操作的控制方式" class="headerlink" title="并发操作的控制方式"></a>并发操作的控制方式</h4><blockquote>
<ol>
<li>悲观锁（LOCK）：适合 <code>低并发</code> 、 <code>常规读写</code> 、 <code>强一致性</code> 的场景</li>
<li>乐观锁（CAS ）：适合 <code>高并发</code> 、 <code>读多写少</code> 、 <code>弱一致性</code> 的场景</li>
<li>写时复制（COW）：适合 <code>高并发</code> 、 <code>读多写少</code> 、 <code>弱一致性</code> 的场景</li>
</ol>
</blockquote>
<blockquote>
<p>ps：CAS如果写多的话，竞争激烈时大量的失败导致cpu做了很多无用功从而占用和浪费cpu资源<br>ps：COW如果写多的话，频繁分配内存时来不及回收会造成内存占用过高<br>ps：CAS比COW的效率更高，但CAS支持设置操作却不支持插入和删除的操作</p>
</blockquote>
<h4 id="并发操作的读写控制"><a href="#并发操作的读写控制" class="headerlink" title="并发操作的读写控制"></a>并发操作的读写控制</h4><blockquote>
<ol>
<li>悲观锁（LOCK）：写写互斥，读写互斥，读读互斥</li>
<li>乐观锁（CAS ）：写写互斥，读写不互斥，读读不互斥</li>
<li>写时复制（COW）：写写互斥，读写不互斥，读读不互斥</li>
</ol>
</blockquote>
<blockquote>
<p>ps：读写不互斥时会存在弱一致性的问题</p>
</blockquote>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><h4 id="锁的类型分类"><a href="#锁的类型分类" class="headerlink" title="锁的类型分类"></a>锁的类型分类</h4><ul>
<li>是否锁住资源：悲观锁（锁住资源）、乐观锁（不锁住资源）</li>
<li>是否独占资源：排他锁（独占资源）、共享锁（共享资源）</li>
<li>是否阻塞线程：同步锁（阻塞）、自旋锁（不阻塞）</li>
</ul>
<blockquote>
<p>ps：读写锁一般是写独占和读共享的，即写写互斥，读写互斥，读读不互斥</p>
</blockquote>
<h4 id="锁的实现分类"><a href="#锁的实现分类" class="headerlink" title="锁的实现分类"></a>锁的实现分类</h4><ul>
<li>是否锁住资源：悲观锁（synchronized、ReentrantLock）、乐观锁（ReentrantReadWriteLock、StampedLock）</li>
<li>是否共享资源：排他锁（synchronized、ReentrantLock）、共享锁（Semaphore）、读写锁（ReentrantReadWriteLock、StampedLock）</li>
<li>是否阻塞线程：同步锁（synchronized、ReentrantLock、ReentrantReadWriteLock、StampedLock）、自旋锁（SpinLock）</li>
</ul>
<blockquote>
<p>ps：ReentrantReadWriteLock是 <code>读写互斥</code> 的，而StampedLock是 <code>读写不互斥</code> 的</p>
</blockquote>
<h4 id="锁的范围分类"><a href="#锁的范围分类" class="headerlink" title="锁的范围分类"></a>锁的范围分类</h4><ul>
<li>线程锁</li>
<li>进程锁</li>
<li>分布式锁</li>
</ul>
<blockquote>
<p>ps：java锁、redis锁、数据库锁</p>
</blockquote>
<h3 id="锁的原理"><a href="#锁的原理" class="headerlink" title="锁的原理"></a>锁的原理</h3><ul>
<li>悲观锁：Mutex + 阻塞 + 唤醒</li>
<li>乐观锁：CAS + 自旋 + 重试</li>
</ul>
<h3 id="锁的特性"><a href="#锁的特性" class="headerlink" title="锁的特性"></a>锁的特性</h3><ul>
<li>是否支持重入：同一个线程是否可以多次获取锁</li>
<li>是否支持中断：线程是否可以响应中断请求</li>
<li>是否支持公平：线程是否能够公平的处理请求</li>
</ul>
<blockquote>
<p>ps：公平（排队且先进先出）、非公平（先插队，如果失败后再排队）</p>
</blockquote>
<h3 id="锁的问题"><a href="#锁的问题" class="headerlink" title="锁的问题"></a>锁的问题</h3><h4 id="DeadLock（死锁）"><a href="#DeadLock（死锁）" class="headerlink" title="DeadLock（死锁）"></a>DeadLock（死锁）</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/chow__zh/article/details/123968286">死锁问题详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/jyy305/article/details/70077042">死锁的形成条件</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/guaiguaihenguai/article/details/80303835">死锁的解决办法</a></li>
</ul>
</blockquote>
<p>死锁的形成条件</p>
<ul>
<li>互斥使用：即当资源被一个线程占用时，别的线程不能使用</li>
<li>不可抢占：资源请求者不能强制从资源占有者手中抢夺资源，资源只能由占有者主动释放</li>
<li>资源保持：当资源请求者在请求其他资源的同时保持对现有资源的占有</li>
<li>循环等待：多个线程存在环路的锁依赖关系而永远等待下去（例如T1占有T2需要的资源，T2占有T3需要的资源，T3占有T1需要的资源，这种情况可能会形成一个等待环路）</li>
</ul>
<p>死锁的解决办法</p>
<ul>
<li>预防死锁<ul>
<li>破坏不可抢占条件：当请求不到其他资源超时时释放自己持有的资源</li>
<li>破坏资源保持条件：申请资源时一次性申请全部所需的资源</li>
<li>破坏循环等待条件：给资源分配编号并按照编号顺序进行申请</li>
</ul>
</li>
<li>避免死锁<ul>
<li>银行家算法</li>
</ul>
</li>
<li>检测和解除死锁</li>
</ul>
<h4 id="Starvation（饥饿）"><a href="#Starvation（饥饿）" class="headerlink" title="Starvation（饥饿）"></a>Starvation（饥饿）</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37734042/article/details/108417432">饥饿问题详解</a></li>
</ul>
</blockquote>
<p>饥饿的解决办法</p>
<ul>
<li>分配资源时使用公平的算法</li>
</ul>
<blockquote>
<p>ps：公平（排队且先进先出）、非公平（先插队，如果失败后再排队）</p>
</blockquote>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zgcy123456/article/details/124231957">synchronized锁详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/daobuxinzi/article/details/127214663">synchronized锁之中断详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_45406092/article/details/109437091">synchronized锁之重入详解</a></li>
</ul>
</blockquote>
<ul>
<li>修饰类和静态方法，锁是当前类的Class对象</li>
<li>修饰实例方法，锁是当前实例对象</li>
<li>修饰代码块，锁是括号里面的对象</li>
</ul>
<h4 id="synchronized锁原理"><a href="#synchronized锁原理" class="headerlink" title="synchronized锁原理"></a>synchronized锁原理</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/javazejian/article/details/72828483">synchronized锁原理</a></li>
</ul>
</blockquote>
<ul>
<li>锁方法：通过方法的<code>ACC_SYNCHRONIZED</code>标识实现</li>
<li>锁代码块：通过对象的<code>monitor</code>锁和系统的<code>monitorenter</code>和<code>monitorexit</code>指令实现</li>
</ul>
<h4 id="synchronized锁优化"><a href="#synchronized锁优化" class="headerlink" title="synchronized锁优化"></a>synchronized锁优化</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/java_dazhuzhu/article/details/119574987">synchronized锁优化</a></li>
</ul>
</blockquote>
<ul>
<li>锁膨胀</li>
<li>锁消除</li>
<li>锁粗化</li>
<li>自适应自旋锁</li>
</ul>
<h4 id="synchronized锁膨胀"><a href="#synchronized锁膨胀" class="headerlink" title="synchronized锁膨胀"></a>synchronized锁膨胀</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41477034/article/details/119775535">synchronized锁膨胀</a></li>
</ul>
</blockquote>
<ul>
<li>无锁：没有线程获取锁</li>
<li>偏向锁：只有一个线程获取锁时进入此状态（通过CAS对象的标记头获取锁）</li>
<li>轻量级锁：多个线程获取锁时进入此状态（通过CAS对象的标记头获取锁，获取锁失败的线程需进行自旋）</li>
<li>重量级锁：多个线程获取锁并且有线程自旋失败（10次且可配置）时进入此状态（通过操作系统的Mutex机制获取锁）</li>
</ul>
<h4 id="synchronized锁消除"><a href="#synchronized锁消除" class="headerlink" title="synchronized锁消除"></a>synchronized锁消除</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yuan_qh/article/details/100195185">synchronized锁消除</a></li>
</ul>
</blockquote>
<h4 id="synchronized锁粗化"><a href="#synchronized锁粗化" class="headerlink" title="synchronized锁粗化"></a>synchronized锁粗化</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27471405/article/details/115410412">synchronized锁粗化</a></li>
</ul>
</blockquote>
<h4 id="synchronized锁自旋"><a href="#synchronized锁自旋" class="headerlink" title="synchronized锁自旋"></a>synchronized锁自旋</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yzpbright/article/details/105483620">synchronized锁自旋</a></li>
</ul>
</blockquote>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42411214/article/details/105100303">ReentrantLock详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/every__day/article/details/108818343">ReentrantLock原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013013553/article/details/78700168">ReentrantLock和Condition详解</a></li>
</ul>
</blockquote>
<p>ReentrantLock是基于AQS框架实现的，ArrayBlockingQueue则是基于ReentrantLock和Condition实现的</p>
<h4 id="lock-lock-写在-try-代码块内部行吗？"><a href="#lock-lock-写在-try-代码块内部行吗？" class="headerlink" title="lock.lock() 写在 try 代码块内部行吗？"></a>lock.lock() 写在 try 代码块内部行吗？</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013568373/article/details/98480603">lock.lock() 写在 try 代码块内部行吗？</a></li>
</ul>
</blockquote>
<p>不能，如果写在try里面，当lock异常时，finally会执行unlock，unlock的时候检测到线程没有先持有锁会抛出 <code>IllegalMonitorStateException</code> 异常</p>
<h4 id="如何安全的unlock"><a href="#如何安全的unlock" class="headerlink" title="如何安全的unlock"></a>如何安全的unlock</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/w8y56f/article/details/115608666">如何安全的unlock</a></li>
</ul>
</blockquote>
<ul>
<li>用try-catch包住异常，并且不处理任何异常，不打印日志</li>
<li>可以用ReentrantLock对象的isHeldByCurrentThread方法进行判断</li>
</ul>
<blockquote>
<p>ps：并不是所有的Lock实现类都有isHeldByCurrentThread方法，所以可以统一使用try-catch包住异常</p>
</blockquote>
<h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wtopps/article/details/106202418">读写锁之ReentrantReadWriteLock和StampedLock入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Longstar_L/article/details/112241559">读写锁之ReentrantReadWriteLock和StampedLock详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43631716/article/details/121492528">ReentrantReadWriteLock详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42039228/article/details/123181145">ReentrantReadWriteLock原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42634696/article/details/105135368">StampedLock详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangnanwlw/article/details/109848035">StampedLock原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiangyue1221/article/details/123518116">读写锁之读写之间互斥吗</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38737992/article/details/92796403">读写锁之锁降级和锁升级入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/GDUT_Trim/article/details/120796255">读写锁之锁降级和锁升级详解</a></li>
</ul>
</blockquote>
<ul>
<li>ReentrantReadWriteLock（悲观读写锁）：写写互斥，<code>读写互斥</code>，读读不互斥</li>
<li>StampedLock（乐观读写锁）：写写互斥，<code>读写不互斥</code>，读读不互斥</li>
</ul>
<blockquote>
<p><code>悲观读写</code> ： <code>读写互斥</code> ， <code>乐观读写</code> ： <code>读写不互斥</code></p>
</blockquote>
<h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40276626/article/details/119900143">Atomic详解</a></li>
</ul>
</blockquote>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38737992/article/details/90812550">CAS入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lwang_IT/article/details/121638089">CAS详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_41632451/article/details/124754457">CAS自旋</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/fengyuyeguirenenen/article/details/122554553">CAS和自旋到底是一个概念吗</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wodetongnian/article/details/104044865">CAS自旋实现样例</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_38112165/article/details/108987422">CAS存在的问题以及解决方案</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Yrainy_D/article/details/109489406">CAS和volatile配合使用保证线程安全</a></li>
</ul>
</blockquote>
<p>CAS存在的问题</p>
<ul>
<li>ABA问题：可以加版本号或者时间戳解决</li>
<li>只能保证单个变量操作的原子性：可以合并多个变量为单个对象进行操作</li>
<li>竞争激烈时大量的失败导致cpu做了很多无用功从而占用和浪费cpu资源：可以限制重试次数</li>
</ul>
<blockquote>
<p>ps：cas需要配合volatile来实现线程安全，atomic类就是这样实现的</p>
</blockquote>
<h4 id="OptimisticLock（乐观锁）"><a href="#OptimisticLock（乐观锁）" class="headerlink" title="OptimisticLock（乐观锁）"></a>OptimisticLock（乐观锁）</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/LyySwx/article/details/125634783">乐观锁详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_32421529/article/details/104992791">乐观锁的优点和缺点</a></li>
</ul>
</blockquote>
<p>乐观锁的优点和缺点</p>
<ul>
<li>优点：避免冲突时等待造成的耗时</li>
<li>缺点：失败后需要重新处理并重试</li>
</ul>
<h4 id="SpinLock（自旋锁）"><a href="#SpinLock（自旋锁）" class="headerlink" title="SpinLock（自旋锁）"></a>SpinLock（自旋锁）</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46146718/article/details/120647711">自旋锁详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/vincent_wen0766/article/details/108558656">自旋锁的优点和缺点</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46311811/article/details/122354855">自旋锁和单核处理器</a></li>
</ul>
</blockquote>
<p>自旋锁的优点和缺点</p>
<ul>
<li>优点：避免上下文切换带来的耗时</li>
<li>缺点：自旋循环时间长的话会占用和浪费cpu资源</li>
</ul>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/long199366/article/details/112506704">AQS详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40728028/article/details/106444575">AQS之state详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/foxException/article/details/108817698">AQS之CLH队列和锁详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39313241/article/details/114954769">AQS之waitStatus详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhang199091/article/details/101145852">AQS之独占式同步状态的获取和释放</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhang199091/article/details/102673268">AQS之共享式同步状态的获取和释放</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhang199091/article/details/105875383">AQS之阻塞和唤醒</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_36586120/article/details/108934089">AQS之ReentrantLock详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_36586120/article/details/108958006">AQS之Semaphore详解</a></li>
</ul>
</blockquote>
<p>抽象同步器负责通用的逻辑（阻塞和唤醒、入队和出队），具体同步器负责自定义逻辑（加锁和解锁）</p>
<p>AQS的核心对象</p>
<ul>
<li>state：资源</li>
<li>CLH队列：双向链表实现的等待队列（链表结点中包含线程对象）</li>
</ul>
<blockquote>
<p>ps：CLH队列中的某个结点会自旋CAS检查前驱结点的locked状态，自旋失败后则进行阻塞并等待前驱结点唤醒</p>
</blockquote>
<p>AQS的重写方法</p>
<ul>
<li>isHeldExclusively()：该线程是否正在独占资源（只有用到Condition时才需要去实现它）</li>
<li>tryAcquire(int)：独占方式，成功则返回true，失败则返回false</li>
<li>tryRelease(int)：独占方式，成功则返回true，失败则返回false</li>
<li>tryAcquireShared(int)：共享方式，负数表示失败，0表示成功但没有剩余资源，正数表示成功且有剩余资源</li>
<li>tryReleaseShared(int)：共享方式，如果释放后允许唤醒后续等待对象则返回true，否则返回false</li>
</ul>
<h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangliangluang/article/details/123033352">LockSupport详解</a></li>
</ul>
</blockquote>
<p>LockSupport.park可以实现 <code>阻塞</code> 功能但不能实现 <code>互斥</code> 功能</p>
<h2 id="Question-3"><a href="#Question-3" class="headerlink" title="Question"></a>Question</h2><h3 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/z123456789XDW/article/details/100031621">synchronized和volatile的区别</a></li>
</ul>
</blockquote>
<ul>
<li>synchronized可以修饰类、字段、方法，volatile只能修饰字段</li>
<li>synchronized保证原子性、可见性、有序性，volatile只保证可见性、有序性</li>
<li>synchronized会阻塞线程，volatile不会阻塞线程</li>
</ul>
<h3 id="synchronized和Lock的区别"><a href="#synchronized和Lock的区别" class="headerlink" title="synchronized和Lock的区别"></a>synchronized和Lock的区别</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/drrzh/article/details/119519455">synchronized和Lock的区别</a></li>
</ul>
</blockquote>
<ul>
<li>位置：<ul>
<li>synchronized是java关键字，Lock是java类</li>
</ul>
</li>
<li>实现：<ul>
<li>synchronized基于操作系统mutex机制实现，Lock基于java的AQS机制实现</li>
</ul>
</li>
<li>操作：<ul>
<li>synchronized会自动释放锁，Lock需要手动释放</li>
</ul>
</li>
<li>超时：<ul>
<li>synchronized不能设置等待超时时间，Lock可以设置等待超时时间</li>
</ul>
</li>
<li>状态：<ul>
<li>synchronized无法判断是否获取了锁，Lock可以判断是否获取了锁</li>
</ul>
</li>
<li>特性：<ul>
<li>synchronized支持重入，Lock也支持重入</li>
<li>synchronized不支持中断，Lock可支持中断（也支持不可中断）</li>
<li>synchronized不支持公平锁，Lock可支持公平锁（也支持非公平）</li>
</ul>
</li>
</ul>
<h3 id="synchronized和ReentrantLock为什么默认是非公平的"><a href="#synchronized和ReentrantLock为什么默认是非公平的" class="headerlink" title="synchronized和ReentrantLock为什么默认是非公平的"></a>synchronized和ReentrantLock为什么默认是非公平的</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_73311735/article/details/131304965">synchronized和ReentrantLock为什么默认是非公平的</a></li>
</ul>
</blockquote>
<p>因为非公平锁在释放后可以省去唤醒某个线程的开销直接让另一个线程获得锁，从而提高整体的效率</p>
<blockquote>
<p>ps：但是非公平锁可能会导致饥饿问题</p>
</blockquote>
<h3 id="ReentrantLock是如何实现公平和非公平性的"><a href="#ReentrantLock是如何实现公平和非公平性的" class="headerlink" title="ReentrantLock是如何实现公平和非公平性的"></a>ReentrantLock是如何实现公平和非公平性的</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/agonie201218/article/details/129029558">ReentrantLock是如何实现公平和非公平性的</a></li>
</ul>
</blockquote>
<ul>
<li>公平：线程在竞争锁资源的时候先判断AQS同步队列里面有没有在等待的线程，如果有的话就加入到队列的尾部等待，没有的话就直接获取锁</li>
<li>非公平：线程在竞争锁资源的时候先尝试获取锁，失败后再加入到队列的尾部等待</li>
</ul>
<h3 id="synchronized是如何保证线程安全的"><a href="#synchronized是如何保证线程安全的" class="headerlink" title="synchronized是如何保证线程安全的"></a>synchronized是如何保证线程安全的</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/chenzengnian123/article/details/122686371">synchronized是如何保证线程安全的</a></li>
</ul>
</blockquote>
<p>synchronized通过锁的互斥机制保证了原子性，使得同一时间只有一个线程能够操作资源来保证了线程安全，同时通过内存屏障来保证了线程安全中的可见性和有序性</p>
<p>synchronized的底层原理</p>
<ul>
<li>锁方法：通过方法的<code>ACC_SYNCHRONIZED</code>标识实现</li>
<li>锁代码块：通过对象的<code>monitor</code>锁和系统的<code>monitorenter</code>和<code>monitorexit</code>指令实现</li>
</ul>
<h3 id="wait和notify为什么要位于synchronized代码块中"><a href="#wait和notify为什么要位于synchronized代码块中" class="headerlink" title="wait和notify为什么要位于synchronized代码块中"></a>wait和notify为什么要位于synchronized代码块中</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44885775/article/details/124523878">wait和notify为什么要位于synchronized代码块中</a></li>
</ul>
</blockquote>
<ul>
<li>wait和notify是用来实现线程间通信的，是基于共享变量实现的</li>
<li>为了保证共享变量的线程安全，需要用synchronized来对共享变量加锁</li>
</ul>
<h1 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h1><h2 id="Basic-4"><a href="#Basic-4" class="headerlink" title="Basic"></a>Basic</h2><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ChenRui_yz/article/details/126926950">java异步编程入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_73493267/article/details/126611222">java异步编程进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/afreon/article/details/128825831">java异步编程详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/a321123b/article/details/123389278">java并发编程入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/a321123b/article/details/123482491">java并发编程进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/a321123b/article/details/123482812">java并发编程详解</a></li>
</ul>
</blockquote>
<ul>
<li>Future：普通任务的接口，核心实现类为FutureTask</li>
<li>RunnableFuture：对Runnable进行包装的Future</li>
<li>FutureTask：Future的实现类</li>
<li>ScheduledFuture：调度任务的接口，核心实现类为ScheduledFutureTask</li>
<li>RunnableScheduledFuture：对Runnable进行包装的ScheduledFuture</li>
<li>ScheduledFutureTask：ScheduledFuture的实现类</li>
<li>Delayed：延迟任务的接口，继承了Comparable</li>
<li>ExecutorService：普通任务执行器，核心实现类为ThreadPoolExecutor</li>
<li>ScheduledExecutorService：调度任务执行器，核心实现类为ScheduledThreadPoolExecutor</li>
<li>CompletionStage：异步任务调度和计算的接口</li>
<li>CompletableFuture：异步任务调度和计算的实现类</li>
</ul>
<h3 id="任务的运行方式"><a href="#任务的运行方式" class="headerlink" title="任务的运行方式"></a>任务的运行方式</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013288190/article/details/114257211">任务的运行方式</a></li>
</ul>
</blockquote>
<ul>
<li>串行：<code>一个</code>工作者<code>按序</code>执行多个任务（serial）</li>
<li>并发：<code>一个</code>工作者<code>分时</code>执行多个任务（concurrent）</li>
<li>并行：<code>多个</code>工作者<code>同时</code>执行多个任务（parallel）</li>
</ul>
<blockquote>
<p>ps：工作者（worker）通常是指线程（本质是指cpu）<br>ps：并发度指的就是 <code>分时</code> 执行任务的任务个数<br>ps：并行度指的就是 <code>同时</code> 执行任务的任务个数</p>
</blockquote>
<p>串行的实现方式</p>
<ul>
<li>加锁</li>
<li>队列</li>
</ul>
<blockquote>
<p>ps：加锁的本质还是使用队列进行排队</p>
</blockquote>
<p>并发的实现方式</p>
<ul>
<li>多线程</li>
<li>多进程</li>
<li>协程</li>
</ul>
<h4 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/kevin_mails/article/details/80251234">并发和并行的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Cai_deLong/article/details/108302842">并发和并行图解</a></li>
</ul>
</blockquote>
<ul>
<li>并发（Concurrency）：<code>一个</code>工作者<code>分时</code>执行多个任务</li>
<li>并行（Parallelism）：<code>多个</code>工作者<code>同时</code>执行多个任务</li>
</ul>
<h4 id="集群和分布式的区别"><a href="#集群和分布式的区别" class="headerlink" title="集群和分布式的区别"></a>集群和分布式的区别</h4><ul>
<li>集群（Cluster）：<code>多个</code>工作者<code>轮流</code>处理主任务</li>
<li>分布式（Distributed）：<code>多个</code>工作者<code>分工</code>处理子任务</li>
</ul>
<h4 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h4><ul>
<li>同步（Synchronization）：<code>主动</code>获取结果，不一定<code>阻塞</code>的（轮询获取结果就不是阻塞的）</li>
<li>异步（Asynchronization）：<code>被动</code>获取结果，一般是<code>非阻塞</code>的</li>
</ul>
<h3 id="任务的调度方式"><a href="#任务的调度方式" class="headerlink" title="任务的调度方式"></a>任务的调度方式</h3><h4 id="普通调度（normal）"><a href="#普通调度（normal）" class="headerlink" title="普通调度（normal）"></a>普通调度（normal）</h4><p>可以使用ScheduledThreadPoolExecutor的 <code>schedule</code> 方法实现</p>
<h4 id="延时调度（delay）"><a href="#延时调度（delay）" class="headerlink" title="延时调度（delay）"></a>延时调度（delay）</h4><p>可以使用ScheduledThreadPoolExecutor的 <code>schedule</code> 方法中的 <code>delay</code> 参数实现</p>
<h4 id="定时调度（timing）"><a href="#定时调度（timing）" class="headerlink" title="定时调度（timing）"></a>定时调度（timing）</h4><p>可以使用ScheduledThreadPoolExecutor的如下方法实现</p>
<ul>
<li><code>scheduleAtFixedRate</code>：固定<code>频率</code>的触发任务的执行</li>
<li><code>scheduleWithFixedDelay</code>：固定<code>延迟</code>后触发任务的执行</li>
</ul>
<h2 id="Usage-1"><a href="#Usage-1" class="headerlink" title="Usage"></a>Usage</h2><h3 id="SyncTask"><a href="#SyncTask" class="headerlink" title="SyncTask"></a>SyncTask</h3><p>java中没有SyncTask类，对应的类为FutureTask</p>
<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014209205/article/details/80598209">Future详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43145361/article/details/97049103">RunnableFuture详解</a></li>
</ul>
</blockquote>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lp284558195/article/details/115670103">FutureTask使用入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40685275/article/details/99838677">FutureTask使用详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27264789/article/details/100129323">FutureTask原理详解</a></li>
</ul>
</blockquote>
<h5 id="Basic-5"><a href="#Basic-5" class="headerlink" title="Basic"></a>Basic</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/kking_edc/article/details/108297917">FutureTask调用之使用Thread运行</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38750084/article/details/84801211">FutureTask调用之使用线程池运行</a></li>
</ul>
</blockquote>
<h5 id="State-1"><a href="#State-1" class="headerlink" title="State"></a>State</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39654841/article/details/90631795">FutureTask的状态详解</a></li>
</ul>
</blockquote>
<ul>
<li>NEW（已创建）：创建FutureTask之后</li>
<li>COMPLETING（完成中）：设置结果开始时，是一个中间过渡态</li>
<li>NORMAL（已正常完成）：设置结果（正常完成）结束后</li>
<li>EXCEPTIONAL（已异常完成）：设置结果（异常完成）结束后</li>
<li>CANCELLED（已取消）：取消任务后</li>
<li>INTERRUPTING（中断中）：中断开始时，是一个中间过渡态</li>
<li>INTERRUPTED（已断中）：中断结束后</li>
</ul>
<h5 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zn0999/article/details/109034085">FutureTask.get异常捕获详解</a></li>
</ul>
</blockquote>
<p>FutureTask.get异常如下</p>
<ul>
<li>CancellationException：任务提交后<code>取消</code>抛出的异常</li>
<li>InterruptedException：任务执行时<code>中断</code>抛出的异常</li>
<li>ExecutionException：任务执行时<code>出错</code>抛出的异常</li>
<li>TimeoutException：任务执行时<code>超时</code>抛出的异常</li>
</ul>
<blockquote>
<p>ps：cancel时如果任务还在执行中，就会抛出CancellationException（RuntimeException），否则就可能抛出InterruptedException</p>
</blockquote>
<h5 id="Cancel"><a href="#Cancel" class="headerlink" title="Cancel"></a>Cancel</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014644574/article/details/114327939">FutureTask.cancel取消任务详解</a></li>
</ul>
</blockquote>
<blockquote>
<p>ps：cancel时如果任务已经执行，会调用 <code>Thread.interrupt</code> 对 <code>当前</code> 线程进行中断</p>
</blockquote>
<h5 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/cuiwjava/article/details/108186030">FutureTask.get超时原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/cenjianteng/article/details/91873019">FutureTask之实现超时任务</a></li>
</ul>
</blockquote>
<blockquote>
<p>ps：get的阻塞效果是通过LockSupport.park或者LockSupport.parkNanos实现的</p>
</blockquote>
<h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/afreon/article/details/128825831">java异步编程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_62789540/article/details/123223427">python异步编程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/howgod/article/details/93978297">javascript异步编程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/a645293829/article/details/125324761">java异步编程多线程和MQ哪个好</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sky_jiangcheng/article/details/82025154">java异步编程线程池和MQ哪个好</a></li>
</ul>
</blockquote>
<p>java中没有AsyncTask类，对应的类为CompletableFuture</p>
<h4 id="CompletionStage"><a href="#CompletionStage" class="headerlink" title="CompletionStage"></a>CompletionStage</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42695485/article/details/110407485">CompletionStage详解</a></li>
</ul>
</blockquote>
<h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><h5 id="Basic-6"><a href="#Basic-6" class="headerlink" title="Basic"></a>Basic</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/duke_ding2/article/details/107562881">CompletableFuture使用入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43631716/article/details/121766969">CompletableFuture使用详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44337445/article/details/121710515">CompletableFuture方法总结</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39332800/article/details/108185931">CompletableFuture原理详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/q258523454/article/details/117967874">CompletableFuture非async方法和async方法的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/leon_wzm/article/details/80560081">CompletableFuture非async方法的执行线程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43722048/article/details/121942164">CompletableFuture.allOf获取所有结果</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014526725/article/details/96474500">java9 CompletableFuture改进</a></li>
</ul>
</blockquote>
<ul>
<li>包含async方法和非async方法</li>
<li>包含async的有两种方法，一种使用默认的forkjoin线程池，一种是使用自定义线程池</li>
<li>包含apply的都使用Function回调，有输入，有返回值</li>
<li>包含accept的都使用Consumer回调，有输入，没有返回</li>
<li>包含supply的都使用Supplier回调，没有输入，有返回</li>
<li>包含run的都使用Runnable回调，没有输入，没有返回</li>
</ul>
<h6 id="创建任务（createTask）"><a href="#创建任务（createTask）" class="headerlink" title="创建任务（createTask）"></a>创建任务（createTask）</h6><p>####### supplyAsync</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span><br></pre></td></tr></table></figure>

<p>####### runAsync</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span></span><br></pre></td></tr></table></figure>

<p>####### completedFuture</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">completedFuture</span><span class="params">(U value)</span></span><br></pre></td></tr></table></figure>

<h6 id="处理结果（handleResult）"><a href="#处理结果（handleResult）" class="headerlink" title="处理结果（handleResult）"></a>处理结果（handleResult）</h6><blockquote>
<p>result &#x3D; value or error</p>
</blockquote>
<p>####### thenApply（thenApplyValue）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span></span><br></pre></td></tr></table></figure>

<p>####### thenAccept（thenAcceptValue）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAccept</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span></span><br></pre></td></tr></table></figure>

<p>####### thenRun（thenRun）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRun</span><span class="params">(Runnable action)</span></span><br></pre></td></tr></table></figure>

<p>####### exceptionally（thenApplyError）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">exceptionally</span><span class="params">(Function&lt;Throwable,? extends T&gt; fn)</span></span><br></pre></td></tr></table></figure>

<p>####### handle（thenApplyResult）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handle</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> T,Throwable,? extends U&gt; fn)</span></span><br></pre></td></tr></table></figure>

<p>####### whenComplete（thenAcceptResult）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> Throwable&gt; action)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>thenRun不关心值，也不关心异常（??? 会吃掉异常，支持从异常中恢复并继续后面的操作）</li>
<li>thenApply和thenAccept只关心值，不关心异常（??? 会吃掉异常，支持从异常中恢复并继续后面的操作）</li>
<li>exceptionally不关心值，只关心异常（会吃掉异常，支持从异常中恢复并继续后面的操作）</li>
<li>handle既关心值，也关心异常（会吃掉异常，支持从异常中恢复并继续后面的操作）</li>
<li>whenComplete既关心值，也关心异常（不会吃掉异常，不支持从异常中恢复并中断后面的操作）</li>
</ul>
</blockquote>
<h6 id="设置结果（setResult）"><a href="#设置结果（setResult）" class="headerlink" title="设置结果（setResult）"></a>设置结果（setResult）</h6><p>####### 设置结果（setValue）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">complete</span><span class="params">(T value)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtrudeValue</span><span class="params">(T value)</span></span><br></pre></td></tr></table></figure>

<p>####### 设置结果（setError）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">completeExceptionally</span><span class="params">(Throwable ex)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtrudeException</span><span class="params">(Throwable ex)</span></span><br></pre></td></tr></table></figure>

<h6 id="获取结果（getResult）"><a href="#获取结果（getResult）" class="headerlink" title="获取结果（getResult）"></a>获取结果（getResult）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">join</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getNow</span><span class="params">(T valueIfAbsent)</span></span><br></pre></td></tr></table></figure>

<h6 id="检查状态（checkState）"><a href="#检查状态（checkState）" class="headerlink" title="检查状态（checkState）"></a>检查状态（checkState）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompletedExceptionally</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h6 id="编排任务（Choreography）"><a href="#编排任务（Choreography）" class="headerlink" title="编排任务（Choreography）"></a>编排任务（Choreography）</h6><p>####### 链式调用（chain）</p>
<p>######## thenCompose（thenChain）</p>
<p>将当前异步任务的结果交给另一个异步任务处理，并返回另一个异步任务，即串联执行两个任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenCompose</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends CompletionStage&lt;U&gt;&gt; fn)</span></span><br></pre></td></tr></table></figure>

<p>####### 组合调用（group）</p>
<p>组合处理两个或多个任务</p>
<p>######## 组合调用（and）</p>
<p>解决任务之间的 <code>与</code> 编排（choreography）关系，等待两个任务同时完成，并处理两个任务的结果</p>
<p>######### thenCombine（thenApplyBoth）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title function_">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn)</span></span><br></pre></td></tr></table></figure>

<p>######### thenAcceptBoth（thenAcceptBoth）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptBoth</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U&gt; action)</span></span><br></pre></td></tr></table></figure>

<p>######### runAfterBoth（thenRunBoth）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span></span><br></pre></td></tr></table></figure>

<p>######## 组合调用（or）</p>
<p>解决任务之间的 <code>或</code> 编排（choreography）关系，等待任意一个任务完成，并处理快的任务的结果</p>
<p>######### applyToEither（thenApplyEither）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">applyToEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T,U&gt; fn)</span></span><br></pre></td></tr></table></figure>

<p>######### acceptEither（thenAcceptEither）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">acceptEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span></span><br></pre></td></tr></table></figure>

<p>######### runAfterEither（thenRunEither）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAfterEither</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span></span><br></pre></td></tr></table></figure>

<p>######## 组合调用（all）</p>
<p>解决任务之间的 <code>与</code> 编排（choreography）关系，等待所有任务同时完成，并忽略所有任务的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span><br></pre></td></tr></table></figure>

<p>######## 组合调用（any）</p>
<p>解决任务之间的 <code>或</code> 编排（choreography）关系，等待任意一个任务完成，并返回快的任务的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title function_">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span><br></pre></td></tr></table></figure>

<h5 id="State-2"><a href="#State-2" class="headerlink" title="State"></a>State</h5><h5 id="Exception-1"><a href="#Exception-1" class="headerlink" title="Exception"></a>Exception</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://mincong.io/2020/05/30/exception-handling-in-completable-future/">CompletableFuture异常处理详解</a></li>
</ul>
</blockquote>
<h5 id="Cancel-1"><a href="#Cancel-1" class="headerlink" title="Cancel"></a>Cancel</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/listeningsea/article/details/123168224">CompletableFuture.cancel取消任务详解</a></li>
</ul>
</blockquote>
<h5 id="Timeout-1"><a href="#Timeout-1" class="headerlink" title="Timeout"></a>Timeout</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013905744/article/details/109134516">CompletableFuture之实现超时任务</a></li>
</ul>
</blockquote>
<h4 id="More"><a href="#More" class="headerlink" title="More"></a>More</h4><h5 id="AsyncTask（python）"><a href="#AsyncTask（python）" class="headerlink" title="AsyncTask（python）"></a>AsyncTask（python）</h5><h6 id="async和await（python）"><a href="#async和await（python）" class="headerlink" title="async和await（python）"></a>async和await（python）</h6><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43380180/article/details/111573642">python async和await详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/permike/article/details/110821246">python async和await原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_51078229/article/details/112343124">python await必须在async函数中使用</a></li>
</ul>
</blockquote>
<h6 id="coroutine（python）"><a href="#coroutine（python）" class="headerlink" title="coroutine（python）"></a>coroutine（python）</h6><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yifengchaoran/article/details/113854853">python 迭代器和生成器详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_36338224/article/details/109231279">python 生成器和协程详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Smile_Mr/article/details/86624376">python 协程详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27825451/article/details/85226239">python 协程之yield详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27825451/article/details/85234610">python 协程之yield实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27825451/article/details/85244237">python 协程之yield from详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/JENREY/article/details/121231495">python yield详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/jpch89/article/details/87776528">python yield from详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43192617/article/details/117791470">python yield和yield from的区别</a></li>
</ul>
</blockquote>
<h6 id="asyncio（python）"><a href="#asyncio（python）" class="headerlink" title="asyncio（python）"></a>asyncio（python）</h6><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xixihahalelehehe/article/details/106398084">python asyncio详解</a></li>
</ul>
</blockquote>
<h6 id="aiohttp（python）"><a href="#aiohttp（python）" class="headerlink" title="aiohttp（python）"></a>aiohttp（python）</h6><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhb_feng/article/details/118081327">python aiohttp详解</a></li>
</ul>
</blockquote>
<h6 id="Tornado（python）"><a href="#Tornado（python）" class="headerlink" title="Tornado（python）"></a>Tornado（python）</h6><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44634704/article/details/115917628">python tornado异步使用详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013421629/article/details/101293065">python tornado异步原理入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/runner668/article/details/82930988">python tornado异步原理详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/jazywoo123/article/details/17566357">python tornado异步和协程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lyc2016012170/article/details/127219152">python tornado异步库</a></li>
</ul>
</blockquote>
<h6 id="Celery（python）"><a href="#Celery（python）" class="headerlink" title="Celery（python）"></a>Celery（python）</h6><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/aaahtml/article/details/115131246">Celery详解</a></li>
<li><a target="_blank" rel="noopener" href="https://celeryproject.readthedocs.io/zh_CN/latest/userguide/canvas.html">Celery工作流详解</a></li>
<li><a target="_blank" rel="noopener" href="https://celery-docs-cn.readthedocs.io/zh/latest/getting-started/first-steps-with-celery.html">Celery结果存储和通信代理详解</a></li>
</ul>
</blockquote>
<p>celery backend：结果存储<br>celery broker：通信代理</p>
<h5 id="AsyncTask（javascript）"><a href="#AsyncTask（javascript）" class="headerlink" title="AsyncTask（javascript）"></a>AsyncTask（javascript）</h5><h6 id="async和await（javascript）"><a href="#async和await（javascript）" class="headerlink" title="async和await（javascript）"></a>async和await（javascript）</h6><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/MrWangJB/article/details/107881183">javascript async和await详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/codebay118/article/details/72596951">javascript async和await解决地狱回调</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lgno2/article/details/109446348">javascript await必须在async函数中使用</a></li>
</ul>
</blockquote>
<h6 id="Promise（javascript）"><a href="#Promise（javascript）" class="headerlink" title="Promise（javascript）"></a>Promise（javascript）</h6><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yes1983/article/details/83629647">javascript Promise入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_53993283/article/details/119945800">javascript Promise详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21980517/article/details/103908747">javascript Promise链式调用</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42681555/article/details/121974050">javascript Promise中then使用详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44776206/article/details/109402410">javascript Promise中catch使用详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38211541/article/details/106261991">javascript Promise中finally使用详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32644987/article/details/117842230">javascript Promise手写实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sunshinessx/article/details/88666179">javascript Promise和Rxjs对比</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39341415/article/details/121716810">javascript Promise和axios</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lingliu0824/article/details/108547842">javascript axios请求的数据格式</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/github_39319000/article/details/89472033">javascript箭头函数的返回值</a></li>
</ul>
</blockquote>
<h3 id="ScheduledTask"><a href="#ScheduledTask" class="headerlink" title="ScheduledTask"></a>ScheduledTask</h3><ul>
<li>延时任务</li>
<li>定时任务</li>
</ul>
<h4 id="ScheduledFuture"><a href="#ScheduledFuture" class="headerlink" title="ScheduledFuture"></a>ScheduledFuture</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013851082/article/details/70175394">ScheduledFuture详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/a355586533/article/details/78455788">RunnableScheduledFuture详解</a></li>
</ul>
</blockquote>
<h4 id="ScheduledFutureTask"><a href="#ScheduledFutureTask" class="headerlink" title="ScheduledFutureTask"></a>ScheduledFutureTask</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_50518271/article/details/119087739">ScheduledFutureTask详解</a></li>
</ul>
</blockquote>
<h2 id="Question-4"><a href="#Question-4" class="headerlink" title="Question"></a>Question</h2><h3 id="FutureTask为什么支持传递给线程"><a href="#FutureTask为什么支持传递给线程" class="headerlink" title="FutureTask为什么支持传递给线程"></a>FutureTask为什么支持传递给线程</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33591903/article/details/108422098">FutureTask为什么支持传递给线程</a></li>
</ul>
</blockquote>
<p>因为FutureTask实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable接口，所以FutureTask支持传递给线程</p>
<h1 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h1><h2 id="Basic-7"><a href="#Basic-7" class="headerlink" title="Basic"></a>Basic</h2><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/tongdanping/article/details/79604637">Executor框架入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40093255/article/details/116990431">Executor框架详解</a></li>
</ul>
</blockquote>
<h3 id="线程池的创建方式"><a href="#线程池的创建方式" class="headerlink" title="线程池的创建方式"></a>线程池的创建方式</h3><ul>
<li>使用Executors快速创建</li>
<li>使用ExecutorService手动创建</li>
</ul>
<h3 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/riemann_/article/details/104704197">线程池的核心参数</a></li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>corePoolSize：核心线程数</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程保活时间大小</li>
<li>unit：线程保活时间单位</li>
<li>workQueue：工作队列</li>
<li>threadFactory：线程工厂</li>
<li>handler：任务饱和策略处理器</li>
</ul>
<h3 id="线程池的提交策略"><a href="#线程池的提交策略" class="headerlink" title="线程池的提交策略"></a>线程池的提交策略</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/chzphoenix/article/details/78968075">线程池的提交策略</a></li>
</ul>
</blockquote>
<ul>
<li><code>poolSize &lt; corePoolSize</code>时增加线程</li>
<li><code>poolSize = corePoolSize</code>时放入队列</li>
<li>队列满了之后再增加线程</li>
<li>线程达到<code>maximumPoolSize</code>后执行RejectedExecutionHandler</li>
<li>根据RejectedExecutionHandler指定的拒绝策略来处理新的任务</li>
</ul>
<h3 id="线程池的线程数量"><a href="#线程池的线程数量" class="headerlink" title="线程池的线程数量"></a>线程池的线程数量</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xp178171640/article/details/104566677">线程池的线程数量</a></li>
</ul>
</blockquote>
<ul>
<li>如果是CPU密集型应用，则线程池大小设置为CPU核心数+1</li>
<li>如果是IO密集型应用，则线程池大小设置为2*CPU核心数+1</li>
</ul>
<h3 id="线程池的工作队列"><a href="#线程池的工作队列" class="headerlink" title="线程池的工作队列"></a>线程池的工作队列</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40306697/article/details/119718820">线程池的工作队列</a></li>
</ul>
</blockquote>
<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>SynchronousQueue</li>
<li>LinkedTransferQueue</li>
<li>PriorityBlockingQueue</li>
<li>DelayedWorkQueue</li>
<li>LinkedBlockingDeque</li>
</ul>
<h3 id="线程池的饱和策略"><a href="#线程池的饱和策略" class="headerlink" title="线程池的饱和策略"></a>线程池的饱和策略</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/jgteng/article/details/54411423">线程池的饱和策略</a></li>
</ul>
</blockquote>
<ul>
<li>AbortPolicy：丢弃任务并且抛出RejectedExecutionException异常（默认策略）</li>
<li>DiscardPolicy：丢弃任务但不抛出异常</li>
<li>DiscardOldestPolicy：丢弃最老的（队列头部）任务</li>
<li>CallerRunsPolicy：在提交的线程中直接执行任务</li>
</ul>
<h3 id="线程池的提交方式"><a href="#线程池的提交方式" class="headerlink" title="线程池的提交方式"></a>线程池的提交方式</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/whiteBearClimb/article/details/113249833">线程池的提交方式</a></li>
</ul>
</blockquote>
<ul>
<li>使用submit方法提交（普通任务有返回值时使用）</li>
<li>使用execute方法提交（普通任务无返回值时使用）</li>
<li>使用schedule方法提交（延时任务和定时任务时使用）</li>
</ul>
<h4 id="submit和execute的区别"><a href="#submit和execute的区别" class="headerlink" title="submit和execute的区别"></a>submit和execute的区别</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qing040513/article/details/111667627">submit和execute的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43901882/article/details/106017061">submit和execute的异常处理区别</a></li>
</ul>
</blockquote>
<ul>
<li>execute只支持Runnable，submit可以支持Runnable和Callable</li>
<li>execute没有返回值，submit有返回值</li>
<li>execute有异常会直接打印，submit在Future.get的时候才会打印异常</li>
</ul>
<h3 id="线程池的异常捕获"><a href="#线程池的异常捕获" class="headerlink" title="线程池的异常捕获"></a>线程池的异常捕获</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/feiying0canglang/article/details/121093876">线程异常之全局捕获</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/silyvin/article/details/80025165">线程池异常之异常捕获入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_20009015/article/details/100569976">线程池异常之异常捕获进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45076180/article/details/114552567">线程池异常之异常捕获详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/LiZhen314/article/details/119609565">线程池异常之线程异常了线程池会怎么处理</a></li>
</ul>
</blockquote>
<ul>
<li>execute方式提交时<ul>
<li>在方法内部捕获异常并处理</li>
<li>在ThreadFactory里使用Thread.setUncaughtExceptionHandler拦截处理</li>
<li>在ThreadPoolExecutor.afterExecute里面处理</li>
</ul>
</li>
<li>submit方式提交时<ul>
<li>在方法内部捕获异常并处理</li>
<li>调用Future.get的时候捕获异常并处理</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：线程池里面的某个线程异常了，线程池会移除这个线程并创建一个新的线程</p>
</blockquote>
<h3 id="线程池的关闭方式"><a href="#线程池的关闭方式" class="headerlink" title="线程池的关闭方式"></a>线程池的关闭方式</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47872288/article/details/124225574">线程池的关闭方式入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zlp1992/article/details/104197515">线程池的关闭方式进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36691683/article/details/84856516">线程池的关闭方式详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/LiZhen314/article/details/119948776">线程池需要关闭吗</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Hellowenpan/article/details/119960517">JVM安全退出之关闭的时候到底会不会等待线程池线程任务执行完毕</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wmq880204/article/details/115408498">JVM安全退出之如何优雅的关闭线程池</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Dongguabai/article/details/106309527">JVM安全退出之如何优雅的关闭java服务</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44902907/article/details/105055041">JVM安全退出之如何优雅的释放连接</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36689178/article/details/104705606">JVM安全退出之如何优雅的释放资源</a></li>
</ul>
</blockquote>
<ul>
<li>shutdown：线程池的状态变为SHUTDOWN，不再接受新任务了，不会终止当前正在运行的任务，还会继续处理队列里剩余的任务</li>
<li>shutdownNow：线程池的状态变为STOP，不再接受新任务了，会终止当前正在运行的任务，而且不会处理队列里剩余的任务并返回还未处理完成的任务列表</li>
</ul>
<h4 id="shutdown和shutdownNow的区别"><a href="#shutdown和shutdownNow的区别" class="headerlink" title="shutdown和shutdownNow的区别"></a>shutdown和shutdownNow的区别</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaojin21cen/article/details/81778651">shutdown和shutdownNow的区别</a></li>
</ul>
</blockquote>
<ul>
<li>shutdown和shutdownNow之后都不会接收新任务了</li>
<li>shutdown不会终止当前正在运行的任务，shutdownNow会终止当前正在运行的任务</li>
<li>shutdown还会继续处理队列里剩余的任务，shutdownNow不会处理队列里剩余的任务</li>
</ul>
<h2 id="Usage-2"><a href="#Usage-2" class="headerlink" title="Usage"></a>Usage</h2><h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u022812849/article/details/109097171">Executors入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Think_and_work/article/details/123667645">Executors详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31439011/article/details/100824461">Executors方法选择</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40096897/article/details/121660747">Executors方法区别</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/asd136912/article/details/87908629">Executors问题说明</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/winterking3/article/details/115917125">Executors之WorkStealingPool</a></li>
</ul>
</blockquote>
<h4 id="快速创建线程池的方法"><a href="#快速创建线程池的方法" class="headerlink" title="快速创建线程池的方法"></a>快速创建线程池的方法</h4><p>快速创建线程池的本质是ThreadPoolExecutor和ScheduledThreadPoolExecutor的快速构造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<h5 id="Executors-newSingleThreadExecutor"><a href="#Executors-newSingleThreadExecutor" class="headerlink" title="Executors.newSingleThreadExecutor"></a>Executors.newSingleThreadExecutor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程数固定（一个），队列容量无限大，适合需要串行执行的任务</p>
<h5 id="Executors-newFixedThreadPool"><a href="#Executors-newFixedThreadPool" class="headerlink" title="Executors.newFixedThreadPool"></a>Executors.newFixedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程数固定（多个），队列容量无限大，线程数量固定且不回收线程，任务需要排队，适合耗时长的少量任务</p>
<h5 id="Executors-newCachedThreadPool"><a href="#Executors-newCachedThreadPool" class="headerlink" title="Executors.newCachedThreadPool"></a>Executors.newCachedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程数无限大，队列容量固定（0个），线程数量充足且有保活时间，任务不用排队，适合耗时短的大量任务</p>
<h5 id="Executors-newScheduledThreadPool"><a href="#Executors-newScheduledThreadPool" class="headerlink" title="Executors.newScheduledThreadPool"></a>Executors.newScheduledThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程数无限大，队列容量无限大，支持延时和定时任务</p>
<h5 id="Executors-newSingleThreadScheduledExecutor"><a href="#Executors-newSingleThreadScheduledExecutor" class="headerlink" title="Executors.newSingleThreadScheduledExecutor"></a>Executors.newSingleThreadScheduledExecutor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newSingleThreadScheduledExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DelegatedScheduledExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程数无限大，队列容量无限大，支持延时和定时任务</p>
<h5 id="Executors-newWorkStealingPool"><a href="#Executors-newWorkStealingPool" class="headerlink" title="Executors.newWorkStealingPool"></a>Executors.newWorkStealingPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span></span><br><span class="line">            (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">             <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ForkJoinPool(int parallelism,</span><br><span class="line">                        ForkJoinWorkerThreadFactory factory,</span><br><span class="line">                        UncaughtExceptionHandler handler,</span><br><span class="line">                        boolean asyncMode) &#123;</span><br><span class="line">        this(checkParallelism(parallelism),</span><br><span class="line">             checkFactory(factory),</span><br><span class="line">             handler,</span><br><span class="line">             asyncMode ? FIFO_QUEUE : LIFO_QUEUE,</span><br><span class="line">             &quot;ForkJoinPool-&quot; + nextPoolId() + &quot;-worker-&quot;);</span><br><span class="line">        checkPermission();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ForkJoinPool</span><span class="params">(<span class="type">int</span> parallelism,</span></span><br><span class="line"><span class="params">                         ForkJoinWorkerThreadFactory factory,</span></span><br><span class="line"><span class="params">                         UncaughtExceptionHandler handler,</span></span><br><span class="line"><span class="params">                         <span class="type">int</span> mode,</span></span><br><span class="line"><span class="params">                         String workerNamePrefix)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">        <span class="built_in">this</span>.ueh = handler;</span><br><span class="line">        <span class="built_in">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">        <span class="type">long</span> <span class="variable">np</span> <span class="operator">=</span> (<span class="type">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">        <span class="built_in">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速创建线程池的问题"><a href="#快速创建线程池的问题" class="headerlink" title="快速创建线程池的问题"></a>快速创建线程池的问题</h4><ul>
<li>Executors.newSingleThreadExecutor：队列容量无限大，容易导致内存耗尽引发OOM</li>
<li>Executors.newFixedThreadPool：队列容量无限大，容易导致内存耗尽引发OOM</li>
<li>Executors.newCachedThreadPool：线程数量无限大，容易导致内存耗尽引发OOM</li>
<li>Executors.newScheduledThreadPool：线程数量无限大，容易导致内存耗尽引发OOM</li>
<li>Executors.newSingleThreadScheduledExecutor：线程数量无限大，容易导致内存耗尽引发OOM</li>
<li>Executors.newWorkStealingPool：队列容量无限大，容易导致内存耗尽引发OOM</li>
</ul>
<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/suifeng3051/article/details/49443835">ExecutorService详解</a></li>
</ul>
</blockquote>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xu_yong_lin/article/details/117521773">ThreadPoolExecutor详解</a></li>
</ul>
</blockquote>
<h5 id="State-3"><a href="#State-3" class="headerlink" title="State"></a>State</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/AlbenXie/article/details/84702331">ThreadPoolExecutor的状态详解</a></li>
</ul>
</blockquote>
<p>RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED</p>
<ul>
<li>RUNNING（运行）：创建线程池后的初始状态</li>
<li>SHUTDOWN（关闭）：执行shutdown()后，不接收新任务，但会继续处理当前任务和队列里剩余的任务</li>
<li>STOP（停止）：执行shutdownNow()后，不接收新任务，且会中断当前任务和丢弃并返回队列里剩余的任务</li>
<li>TIDYING（清扫）：线程池中的任务队列为空后</li>
<li>TERMINATED（终结）：执行terminated()后</li>
</ul>
<h3 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22076345/article/details/115404421">ScheduledExecutorService详解</a></li>
</ul>
</blockquote>
<h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/huangzhilin2015/article/details/116246043">ScheduledThreadPoolExecutor详解</a></li>
</ul>
</blockquote>
<h3 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuyu973971883/article/details/108055564">CompletionService详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wang123459/article/details/79700300">多线程并发执行任务并获取任务结果列表</a></li>
</ul>
</blockquote>
<ul>
<li>将提交任务返回的Future添加到列表中，并等任务全部提交后，再循环列表获取Future的结果</li>
<li>CompletionService</li>
</ul>
<h4 id="ExecutorCompletionService"><a href="#ExecutorCompletionService" class="headerlink" title="ExecutorCompletionService"></a>ExecutorCompletionService</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012060033/article/details/129720991">ExecutorCompletionService详解</a></li>
</ul>
</blockquote>
<h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42039228/article/details/123206215">ForkJoinPool入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41432730/article/details/121308729">ForkJoinPool进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37542889/article/details/92640903">ForkJoinPool详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bof_jangle/article/details/108297499">ForkJoinPool异常处理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37173810/article/details/109635794">ForkJoinPool和ThreadPoolExecutor对比</a></li>
</ul>
</blockquote>
<h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_47770103/article/details/117562941">Timer入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44667083/article/details/114385096">Timer详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lijianqingfeng/article/details/112465288">Timer与ExecutorService对比入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37113604/article/details/89429986">Timer与ExecutorService对比详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013332124/article/details/79603943">java定时器实现原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wjc133/article/details/118308706">操作系统定时器实现方案</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/hpu11/article/details/79588563">linux定时器实现方案</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Renyi-Fan/p/12624226.html">linux定时之sleep实现原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21539375/article/details/124049553">定时器实现方案入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42956653/article/details/126237909">定时器实现方案进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_52622200/article/details/123381196">定时器实现方案详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zalan01408980/article/details/124837321">延时任务和定时任务的区别入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42806574/article/details/102733285">延时任务和定时任务的区别进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45511733/article/details/107575264">延时任务和定时任务的区别详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/crazy_xieyi/article/details/128584144">延时任务和定时任务之优先级队列入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Aqua_yyds/article/details/133629517">延时任务和定时任务之优先级队列详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/justlpf/article/details/130205485">延时任务和定时任务之时间轮入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/crazymakercircle/article/details/128205683">延时任务和定时任务之时间轮详解</a></li>
</ul>
</blockquote>
<h2 id="Question-5"><a href="#Question-5" class="headerlink" title="Question"></a>Question</h2><h3 id="线程池是如何保证核心线程不被销毁的"><a href="#线程池是如何保证核心线程不被销毁的" class="headerlink" title="线程池是如何保证核心线程不被销毁的"></a>线程池是如何保证核心线程不被销毁的</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/smile_from_2015/article/details/105259789">线程池是如何保证核心线程不被销毁的</a></li>
</ul>
</blockquote>
<p>线程池里面的线程内部是无限循环，任务执行完后不会结束，而是继续去队列里面获取任务，如果没获取到任务，就会被队列阻塞直到有新的任务可以获取</p>
<h3 id="如何知道线程池里的的任务已经完成了"><a href="#如何知道线程池里的的任务已经完成了" class="headerlink" title="如何知道线程池里的的任务已经完成了"></a>如何知道线程池里的的任务已经完成了</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_63431773/article/details/134011311">如何知道线程池里的的任务已经完成了</a></li>
</ul>
</blockquote>
<ul>
<li>线程池内部<ul>
<li>Runnable的run方法执行完毕时，这个任务就完成了</li>
<li>Callable的call方法执行完毕时，这个任务就完成了</li>
</ul>
</li>
<li>线程池外部<ul>
<li>通过线程池的isTerminated方法可以用来判断所有的任务是否已经完成了</li>
<li>通过线程池返回的Future对象的isDone方法可以用来判断某个任务是否已经完成了</li>
<li>可以通过CountDownLatch计数器来等待相关的任务完成</li>
</ul>
</li>
</ul>
<h1 id="Cooperation"><a href="#Cooperation" class="headerlink" title="Cooperation"></a>Cooperation</h1><h2 id="Communication"><a href="#Communication" class="headerlink" title="Communication"></a>Communication</h2><p>线程间通信（Communication）是线程间协作（Cooperation）的基础</p>
<h3 id="线程通信机制详解"><a href="#线程通信机制详解" class="headerlink" title="线程通信机制详解"></a>线程通信机制详解</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xianyu_x/article/details/127419036">线程通信机制详解</a></li>
</ul>
</blockquote>
<ul>
<li>Object：wait和notify、notifyAll</li>
<li>Condition：await和signal、signalAll</li>
<li>LockSupport：park和unpark</li>
</ul>
<blockquote>
<p>ps：Thread.join是在Thread对象上手动wait和自动notify的线程通信快捷方式</p>
</blockquote>
<h4 id="Object的wait和notify"><a href="#Object的wait和notify" class="headerlink" title="Object的wait和notify"></a>Object的wait和notify</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lizhengze1117/article/details/106342359">Object的wait和notify详解</a></li>
</ul>
</blockquote>
<h4 id="Condition的await和signal"><a href="#Condition的await和signal" class="headerlink" title="Condition的await和signal"></a>Condition的await和signal</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38293564/article/details/80554516">Condition的await和signal详解</a></li>
</ul>
</blockquote>
<h4 id="LockSupport的park和unpark"><a href="#LockSupport的park和unpark" class="headerlink" title="LockSupport的park和unpark"></a>LockSupport的park和unpark</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_63566550/article/details/125712631">LockSupport的park和unpark详解</a></li>
</ul>
</blockquote>
<h3 id="线程通信机制比较"><a href="#线程通信机制比较" class="headerlink" title="线程通信机制比较"></a>线程通信机制比较</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44245828/article/details/109410117">线程通信机制比较</a></li>
</ul>
</blockquote>
<p>Object只有一个等待队列，Condition可以有多个等待队列</p>
<h2 id="Collaboration"><a href="#Collaboration" class="headerlink" title="Collaboration"></a>Collaboration</h2><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41727218/article/details/88376773">互斥和同步详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44808472/article/details/126315732">Semaphore、CountDownLatch、CyclicBarrier详解</a></li>
</ul>
</blockquote>
<ul>
<li>Mutex：解决互斥的问题</li>
<li>Lock：解决同步的问题</li>
<li>Semaphore：解决限流的问题（限流器）</li>
<li>CountDownLatch：解决计数的问题（计数器）</li>
<li>CyclicBarrier：解决同步点的问题（屏障器）</li>
</ul>
<h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_29952235/article/details/114308860">Mutex详解</a></li>
</ul>
</blockquote>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/warybee/article/details/111316932">Semaphore详解</a></li>
</ul>
</blockquote>
<h4 id="Semaphore和Mutex的区别"><a href="#Semaphore和Mutex的区别" class="headerlink" title="Semaphore和Mutex的区别"></a>Semaphore和Mutex的区别</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/cyan20115/article/details/106549012">Semaphore和Mutex的区别</a></li>
</ul>
</blockquote>
<p>Semaphore：同时可以有多个使用者访问资源（acquire和release）<br>Mutex：同时只能有一个使用者访问资源（lock和unlock）</p>
<h4 id="Semaphore和Lock的区别"><a href="#Semaphore和Lock的区别" class="headerlink" title="Semaphore和Lock的区别"></a>Semaphore和Lock的区别</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/gengyiping18/article/details/60142300">Semaphore和Lock的区别</a></li>
</ul>
</blockquote>
<p>Semaphore：释放许可前不要求先获取许可，并且任何人都能释放许可<br>Lock：解锁前必须先持有这个锁，且只能自己释放锁</p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><h4 id="CountDownLatch和Semaphore的区别"><a href="#CountDownLatch和Semaphore的区别" class="headerlink" title="CountDownLatch和Semaphore的区别"></a>CountDownLatch和Semaphore的区别</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_70734549/article/details/125982906">CountDownLatch和Semaphore的区别</a></li>
</ul>
</blockquote>
<ul>
<li>CountDownLatch：计数器，只能递减数量（count），归零后通知等待的线程继续运行</li>
<li>Semaphore：信号量，可以释放许可（permit），归还许可给其他线程使用</li>
</ul>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><h4 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/dgh112233/article/details/104649531">CyclicBarrier和CountDownLatch的区别</a></li>
</ul>
</blockquote>
<ul>
<li>CyclicBarrier：屏障栏，可以重复使用，归零后通知等待的<code>所有</code>线程继续运行</li>
<li>CountDownLatch：计数器，只能使用一次，归零后通知等待的<code>监听</code>线程继续运行</li>
</ul>
<h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_58554082/article/details/118254227">Exchanger详解</a></li>
</ul>
</blockquote>
<h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42569136/article/details/122888783">java如何实现阻塞等待功能</a></li>
</ul>
</blockquote>
<ul>
<li>while + check + sleep</li>
<li>wait + notify</li>
<li>BlockingQueue</li>
</ul>
<h1 id="Utils"><a href="#Utils" class="headerlink" title="Utils"></a>Utils</h1><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27828675/article/details/114068266">并发工具入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ruan_luqingnian/article/details/118529835">并发工具进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/swadian2008/article/details/127028509">并发工具详解</a></li>
</ul>
</blockquote>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h2 id="Apache-Commons"><a href="#Apache-Commons" class="headerlink" title="Apache Commons"></a>Apache Commons</h2><h2 id="Google-Guava"><a href="#Google-Guava" class="headerlink" title="Google Guava"></a>Google Guava</h2>
    </div>

    
    
    
        <div class="reward-container">
  <div>只想买包辣条</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/pay/wechatpay.jpeg" alt="朱继鹏 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># + java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/07/01/lang/lang-1-java/junior/java-4-exception/" rel="prev" title="exception">
      <i class="fa fa-chevron-left"></i> exception
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/07/01/lang/lang-1-java/junior/java-6-io/" rel="next" title="io">
      io <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Thread"><span class="nav-number">1.</span> <span class="nav-text">Thread</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic"><span class="nav-number">1.1.</span> <span class="nav-text">Basic</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Create"><span class="nav-number">1.1.1.</span> <span class="nav-text">Create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Priority"><span class="nav-number">1.1.2.</span> <span class="nav-text">Priority</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Daemon"><span class="nav-number">1.1.3.</span> <span class="nav-text">Daemon</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#State"><span class="nav-number">1.1.4.</span> <span class="nav-text">State</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Resource"><span class="nav-number">1.1.5.</span> <span class="nav-text">Resource</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Control"><span class="nav-number">1.1.6.</span> <span class="nav-text">Control</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interrupt"><span class="nav-number">1.1.7.</span> <span class="nav-text">Interrupt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Terminate"><span class="nav-number">1.1.8.</span> <span class="nav-text">Terminate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Deprecated"><span class="nav-number">1.1.9.</span> <span class="nav-text">Deprecated</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Question"><span class="nav-number">1.2.</span> <span class="nav-text">Question</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.1.</span> <span class="nav-text">线程和进程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Runnable%E5%92%8CCallable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.2.</span> <span class="nav-text">Runnable和Callable的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E7%9A%84start%E5%92%8Crun%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.3.</span> <span class="nav-text">Thread的start和run的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E7%9A%84start%E8%83%BD%E8%B0%83%E7%94%A8%E5%A4%9A%E6%AC%A1%E5%90%97"><span class="nav-number">1.2.4.</span> <span class="nav-text">Thread的start能调用多次吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E7%9A%84sleep%E5%92%8Cyield%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.5.</span> <span class="nav-text">Thread的sleep和yield的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E7%9A%84sleep%E5%92%8Cjoin%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.6.</span> <span class="nav-text">Thread的sleep和join的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E7%9A%84join%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.7.</span> <span class="nav-text">Thread的join和wait的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">2.</span> <span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-1"><span class="nav-number">2.1.</span> <span class="nav-text">Basic</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Scene"><span class="nav-number">2.1.1.</span> <span class="nav-text">Scene</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leak"><span class="nav-number">2.1.2.</span> <span class="nav-text">Leak</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Inherit"><span class="nav-number">2.1.3.</span> <span class="nav-text">Inherit</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Question-1"><span class="nav-number">2.2.</span> <span class="nav-text">Question</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">2.2.1.</span> <span class="nav-text">ThreadLocal为什么会内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalMap%E7%9A%84key%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="nav-number">2.2.2.</span> <span class="nav-text">ThreadLocalMap的key为什么是弱引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalMap%E7%9A%84value%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="nav-number">2.2.3.</span> <span class="nav-text">ThreadLocalMap的value为什么是强引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8Thread%E5%81%9Akey"><span class="nav-number">2.2.4.</span> <span class="nav-text">ThreadLocalMap为什么不用Thread做key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AE%9A%E4%B9%89%E6%88%90%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">2.2.5.</span> <span class="nav-text">ThreadLocal为什么要定义成静态变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.2.6.</span> <span class="nav-text">ThreadLocal和局部变量的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Safe"><span class="nav-number">3.</span> <span class="nav-text">Safe</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-2"><span class="nav-number">3.1.</span> <span class="nav-text">Basic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Advanced"><span class="nav-number">3.2.</span> <span class="nav-text">Advanced</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="nav-number">3.2.1.</span> <span class="nav-text">线程安全之基本原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="nav-number">3.2.2.</span> <span class="nav-text">线程安全之实现方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AE%89%E5%85%A8"><span class="nav-number">3.2.3.</span> <span class="nav-text">线程安全之变量安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%AE%89%E5%85%A8"><span class="nav-number">3.2.4.</span> <span class="nav-text">线程安全之对象安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8"><span class="nav-number">3.2.5.</span> <span class="nav-text">线程安全之内存安全</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Question-2"><span class="nav-number">3.3.</span> <span class="nav-text">Question</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">3.3.1.</span> <span class="nav-text">什么是线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">3.3.2.</span> <span class="nav-text">如何保证线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile%E8%83%BD%E7%A1%AE%E4%BF%9D%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E5%90%97"><span class="nav-number">3.3.3.</span> <span class="nav-text">volatile能确保线程安全性吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.3.4.</span> <span class="nav-text">volatile的底层实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%8C%E6%A3%80%E6%9F%A5%E5%AE%9E%E7%8E%B0%E4%B8%ADvolatile%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">3.3.5.</span> <span class="nav-text">单例模式的双检查实现中volatile的作用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lock"><span class="nav-number">4.</span> <span class="nav-text">Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-3"><span class="nav-number">4.1.</span> <span class="nav-text">Basic</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.1.1.</span> <span class="nav-text">锁的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">并发操作的控制方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E7%9A%84%E8%AF%BB%E5%86%99%E6%8E%A7%E5%88%B6"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">并发操作的读写控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">4.1.2.</span> <span class="nav-text">锁的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">锁的类型分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E7%B1%BB"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">锁的实现分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E8%8C%83%E5%9B%B4%E5%88%86%E7%B1%BB"><span class="nav-number">4.1.2.3.</span> <span class="nav-text">锁的范围分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">4.1.3.</span> <span class="nav-text">锁的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">4.1.4.</span> <span class="nav-text">锁的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.1.5.</span> <span class="nav-text">锁的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DeadLock%EF%BC%88%E6%AD%BB%E9%94%81%EF%BC%89"><span class="nav-number">4.1.5.1.</span> <span class="nav-text">DeadLock（死锁）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Starvation%EF%BC%88%E9%A5%A5%E9%A5%BF%EF%BC%89"><span class="nav-number">4.1.5.2.</span> <span class="nav-text">Starvation（饥饿）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Usage"><span class="nav-number">4.2.</span> <span class="nav-text">Usage</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized"><span class="nav-number">4.2.1.</span> <span class="nav-text">synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E9%94%81%E5%8E%9F%E7%90%86"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">synchronized锁原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E9%94%81%E4%BC%98%E5%8C%96"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">synchronized锁优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E9%94%81%E8%86%A8%E8%83%80"><span class="nav-number">4.2.1.3.</span> <span class="nav-text">synchronized锁膨胀</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E9%94%81%E6%B6%88%E9%99%A4"><span class="nav-number">4.2.1.4.</span> <span class="nav-text">synchronized锁消除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E9%94%81%E7%B2%97%E5%8C%96"><span class="nav-number">4.2.1.5.</span> <span class="nav-text">synchronized锁粗化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E9%94%81%E8%87%AA%E6%97%8B"><span class="nav-number">4.2.1.6.</span> <span class="nav-text">synchronized锁自旋</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">4.2.2.</span> <span class="nav-text">ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lock-lock-%E5%86%99%E5%9C%A8-try-%E4%BB%A3%E7%A0%81%E5%9D%97%E5%86%85%E9%83%A8%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">lock.lock() 写在 try 代码块内部行吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E7%9A%84unlock"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">如何安全的unlock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantReadWriteLock"><span class="nav-number">4.2.3.</span> <span class="nav-text">ReentrantReadWriteLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Atomic"><span class="nav-number">4.2.4.</span> <span class="nav-text">Atomic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS"><span class="nav-number">4.2.5.</span> <span class="nav-text">CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OptimisticLock%EF%BC%88%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%89"><span class="nav-number">4.2.5.1.</span> <span class="nav-text">OptimisticLock（乐观锁）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpinLock%EF%BC%88%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%89"><span class="nav-number">4.2.5.2.</span> <span class="nav-text">SpinLock（自旋锁）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS"><span class="nav-number">4.2.6.</span> <span class="nav-text">AQS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LockSupport"><span class="nav-number">4.2.7.</span> <span class="nav-text">LockSupport</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Question-3"><span class="nav-number">4.3.</span> <span class="nav-text">Question</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized%E5%92%8Cvolatile%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.1.</span> <span class="nav-text">synchronized和volatile的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.2.</span> <span class="nav-text">synchronized和Lock的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized%E5%92%8CReentrantLock%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E7%9A%84"><span class="nav-number">4.3.3.</span> <span class="nav-text">synchronized和ReentrantLock为什么默认是非公平的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%85%AC%E5%B9%B3%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E6%80%A7%E7%9A%84"><span class="nav-number">4.3.4.</span> <span class="nav-text">ReentrantLock是如何实现公平和非公平性的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84"><span class="nav-number">4.3.5.</span> <span class="nav-text">synchronized是如何保证线程安全的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait%E5%92%8Cnotify%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%8D%E4%BA%8Esynchronized%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%AD"><span class="nav-number">4.3.6.</span> <span class="nav-text">wait和notify为什么要位于synchronized代码块中</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Task"><span class="nav-number">5.</span> <span class="nav-text">Task</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-4"><span class="nav-number">5.1.</span> <span class="nav-text">Basic</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.1.</span> <span class="nav-text">任务的运行方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">并发和并行的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.1.2.</span> <span class="nav-text">集群和分布式的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.1.3.</span> <span class="nav-text">同步和异步的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.2.</span> <span class="nav-text">任务的调度方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E8%B0%83%E5%BA%A6%EF%BC%88normal%EF%BC%89"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">普通调度（normal）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E6%97%B6%E8%B0%83%E5%BA%A6%EF%BC%88delay%EF%BC%89"><span class="nav-number">5.1.2.2.</span> <span class="nav-text">延时调度（delay）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%EF%BC%88timing%EF%BC%89"><span class="nav-number">5.1.2.3.</span> <span class="nav-text">定时调度（timing）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Usage-1"><span class="nav-number">5.2.</span> <span class="nav-text">Usage</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SyncTask"><span class="nav-number">5.2.1.</span> <span class="nav-text">SyncTask</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Future"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">Future</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FutureTask"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">FutureTask</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Basic-5"><span class="nav-number">5.2.1.2.1.</span> <span class="nav-text">Basic</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#State-1"><span class="nav-number">5.2.1.2.2.</span> <span class="nav-text">State</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Exception"><span class="nav-number">5.2.1.2.3.</span> <span class="nav-text">Exception</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Cancel"><span class="nav-number">5.2.1.2.4.</span> <span class="nav-text">Cancel</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Timeout"><span class="nav-number">5.2.1.2.5.</span> <span class="nav-text">Timeout</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AsyncTask"><span class="nav-number">5.2.2.</span> <span class="nav-text">AsyncTask</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CompletionStage"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">CompletionStage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CompletableFuture"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">CompletableFuture</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Basic-6"><span class="nav-number">5.2.2.2.1.</span> <span class="nav-text">Basic</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%EF%BC%88createTask%EF%BC%89"><span class="nav-number">5.2.2.2.1.1.</span> <span class="nav-text">创建任务（createTask）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C%EF%BC%88handleResult%EF%BC%89"><span class="nav-number">5.2.2.2.1.2.</span> <span class="nav-text">处理结果（handleResult）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%BB%93%E6%9E%9C%EF%BC%88setResult%EF%BC%89"><span class="nav-number">5.2.2.2.1.3.</span> <span class="nav-text">设置结果（setResult）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%9C%EF%BC%88getResult%EF%BC%89"><span class="nav-number">5.2.2.2.1.4.</span> <span class="nav-text">获取结果（getResult）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%8A%B6%E6%80%81%EF%BC%88checkState%EF%BC%89"><span class="nav-number">5.2.2.2.1.5.</span> <span class="nav-text">检查状态（checkState）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BC%96%E6%8E%92%E4%BB%BB%E5%8A%A1%EF%BC%88Choreography%EF%BC%89"><span class="nav-number">5.2.2.2.1.6.</span> <span class="nav-text">编排任务（Choreography）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#State-2"><span class="nav-number">5.2.2.2.2.</span> <span class="nav-text">State</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Exception-1"><span class="nav-number">5.2.2.2.3.</span> <span class="nav-text">Exception</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Cancel-1"><span class="nav-number">5.2.2.2.4.</span> <span class="nav-text">Cancel</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Timeout-1"><span class="nav-number">5.2.2.2.5.</span> <span class="nav-text">Timeout</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#More"><span class="nav-number">5.2.2.3.</span> <span class="nav-text">More</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AsyncTask%EF%BC%88python%EF%BC%89"><span class="nav-number">5.2.2.3.1.</span> <span class="nav-text">AsyncTask（python）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#async%E5%92%8Cawait%EF%BC%88python%EF%BC%89"><span class="nav-number">5.2.2.3.1.1.</span> <span class="nav-text">async和await（python）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#coroutine%EF%BC%88python%EF%BC%89"><span class="nav-number">5.2.2.3.1.2.</span> <span class="nav-text">coroutine（python）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#asyncio%EF%BC%88python%EF%BC%89"><span class="nav-number">5.2.2.3.1.3.</span> <span class="nav-text">asyncio（python）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#aiohttp%EF%BC%88python%EF%BC%89"><span class="nav-number">5.2.2.3.1.4.</span> <span class="nav-text">aiohttp（python）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Tornado%EF%BC%88python%EF%BC%89"><span class="nav-number">5.2.2.3.1.5.</span> <span class="nav-text">Tornado（python）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Celery%EF%BC%88python%EF%BC%89"><span class="nav-number">5.2.2.3.1.6.</span> <span class="nav-text">Celery（python）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AsyncTask%EF%BC%88javascript%EF%BC%89"><span class="nav-number">5.2.2.3.2.</span> <span class="nav-text">AsyncTask（javascript）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#async%E5%92%8Cawait%EF%BC%88javascript%EF%BC%89"><span class="nav-number">5.2.2.3.2.1.</span> <span class="nav-text">async和await（javascript）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Promise%EF%BC%88javascript%EF%BC%89"><span class="nav-number">5.2.2.3.2.2.</span> <span class="nav-text">Promise（javascript）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ScheduledTask"><span class="nav-number">5.2.3.</span> <span class="nav-text">ScheduledTask</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ScheduledFuture"><span class="nav-number">5.2.3.1.</span> <span class="nav-text">ScheduledFuture</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ScheduledFutureTask"><span class="nav-number">5.2.3.2.</span> <span class="nav-text">ScheduledFutureTask</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Question-4"><span class="nav-number">5.3.</span> <span class="nav-text">Question</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FutureTask%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%AF%E6%8C%81%E4%BC%A0%E9%80%92%E7%BB%99%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.3.1.</span> <span class="nav-text">FutureTask为什么支持传递给线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Executor"><span class="nav-number">6.</span> <span class="nav-text">Executor</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-7"><span class="nav-number">6.1.</span> <span class="nav-text">Basic</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">6.1.1.</span> <span class="nav-text">线程池的创建方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="nav-number">6.1.2.</span> <span class="nav-text">线程池的核心参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8F%90%E4%BA%A4%E7%AD%96%E7%95%A5"><span class="nav-number">6.1.3.</span> <span class="nav-text">线程池的提交策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F"><span class="nav-number">6.1.4.</span> <span class="nav-text">线程池的线程数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-number">6.1.5.</span> <span class="nav-text">线程池的工作队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5"><span class="nav-number">6.1.6.</span> <span class="nav-text">线程池的饱和策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F"><span class="nav-number">6.1.7.</span> <span class="nav-text">线程池的提交方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#submit%E5%92%8Cexecute%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.1.7.1.</span> <span class="nav-text">submit和execute的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7"><span class="nav-number">6.1.8.</span> <span class="nav-text">线程池的异常捕获</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%85%B3%E9%97%AD%E6%96%B9%E5%BC%8F"><span class="nav-number">6.1.9.</span> <span class="nav-text">线程池的关闭方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#shutdown%E5%92%8CshutdownNow%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.1.9.1.</span> <span class="nav-text">shutdown和shutdownNow的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Usage-2"><span class="nav-number">6.2.</span> <span class="nav-text">Usage</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Executors"><span class="nav-number">6.2.1.</span> <span class="nav-text">Executors</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">快速创建线程池的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Executors-newSingleThreadExecutor"><span class="nav-number">6.2.1.1.1.</span> <span class="nav-text">Executors.newSingleThreadExecutor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Executors-newFixedThreadPool"><span class="nav-number">6.2.1.1.2.</span> <span class="nav-text">Executors.newFixedThreadPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Executors-newCachedThreadPool"><span class="nav-number">6.2.1.1.3.</span> <span class="nav-text">Executors.newCachedThreadPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Executors-newScheduledThreadPool"><span class="nav-number">6.2.1.1.4.</span> <span class="nav-text">Executors.newScheduledThreadPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Executors-newSingleThreadScheduledExecutor"><span class="nav-number">6.2.1.1.5.</span> <span class="nav-text">Executors.newSingleThreadScheduledExecutor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Executors-newWorkStealingPool"><span class="nav-number">6.2.1.1.6.</span> <span class="nav-text">Executors.newWorkStealingPool</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.1.2.</span> <span class="nav-text">快速创建线程池的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ExecutorService"><span class="nav-number">6.2.2.</span> <span class="nav-text">ExecutorService</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">6.2.2.1.</span> <span class="nav-text">ThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#State-3"><span class="nav-number">6.2.2.1.1.</span> <span class="nav-text">State</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ScheduledExecutorService"><span class="nav-number">6.2.3.</span> <span class="nav-text">ScheduledExecutorService</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ScheduledThreadPoolExecutor"><span class="nav-number">6.2.3.1.</span> <span class="nav-text">ScheduledThreadPoolExecutor</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CompletionService"><span class="nav-number">6.2.4.</span> <span class="nav-text">CompletionService</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ExecutorCompletionService"><span class="nav-number">6.2.4.1.</span> <span class="nav-text">ExecutorCompletionService</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ForkJoinPool"><span class="nav-number">6.2.5.</span> <span class="nav-text">ForkJoinPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Timer"><span class="nav-number">6.2.6.</span> <span class="nav-text">Timer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Question-5"><span class="nav-number">6.3.</span> <span class="nav-text">Question</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E4%B8%8D%E8%A2%AB%E9%94%80%E6%AF%81%E7%9A%84"><span class="nav-number">6.3.1.</span> <span class="nav-text">线程池是如何保证核心线程不被销毁的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%87%8C%E7%9A%84%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%B7%B2%E7%BB%8F%E5%AE%8C%E6%88%90%E4%BA%86"><span class="nav-number">6.3.2.</span> <span class="nav-text">如何知道线程池里的的任务已经完成了</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Cooperation"><span class="nav-number">7.</span> <span class="nav-text">Cooperation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Communication"><span class="nav-number">7.1.</span> <span class="nav-text">Communication</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="nav-number">7.1.1.</span> <span class="nav-text">线程通信机制详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Object%E7%9A%84wait%E5%92%8Cnotify"><span class="nav-number">7.1.1.1.</span> <span class="nav-text">Object的wait和notify</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition%E7%9A%84await%E5%92%8Csignal"><span class="nav-number">7.1.1.2.</span> <span class="nav-text">Condition的await和signal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LockSupport%E7%9A%84park%E5%92%8Cunpark"><span class="nav-number">7.1.1.3.</span> <span class="nav-text">LockSupport的park和unpark</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E6%AF%94%E8%BE%83"><span class="nav-number">7.1.2.</span> <span class="nav-text">线程通信机制比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collaboration"><span class="nav-number">7.2.</span> <span class="nav-text">Collaboration</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mutex"><span class="nav-number">7.2.1.</span> <span class="nav-text">Mutex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore"><span class="nav-number">7.2.2.</span> <span class="nav-text">Semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphore%E5%92%8CMutex%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.2.2.1.</span> <span class="nav-text">Semaphore和Mutex的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphore%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.2.2.2.</span> <span class="nav-text">Semaphore和Lock的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">7.2.3.</span> <span class="nav-text">CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch%E5%92%8CSemaphore%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.2.3.1.</span> <span class="nav-text">CountDownLatch和Semaphore的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">7.2.4.</span> <span class="nav-text">CyclicBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CyclicBarrier%E5%92%8CCountDownLatch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.2.4.1.</span> <span class="nav-text">CyclicBarrier和CountDownLatch的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exchanger"><span class="nav-number">7.2.5.</span> <span class="nav-text">Exchanger</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Other"><span class="nav-number">8.</span> <span class="nav-text">Other</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Utils"><span class="nav-number">9.</span> <span class="nav-text">Utils</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java"><span class="nav-number">9.1.</span> <span class="nav-text">Java</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Apache-Commons"><span class="nav-number">9.2.</span> <span class="nav-text">Apache Commons</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Google-Guava"><span class="nav-number">9.3.</span> <span class="nav-text">Google Guava</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="朱继鹏"
      src="/images/avatar/zhujipeng.jpg">
  <p class="site-author-name" itemprop="name">朱继鹏</p>
  <div class="site-description" itemprop="description">在全栈的路上狂奔不止</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">107</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jipengzhu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jipengzhu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jipengzhu@qq.com" title="E-Mail → mailto:jipengzhu@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朱继鹏</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
