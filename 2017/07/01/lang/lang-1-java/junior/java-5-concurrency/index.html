<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="java并发篇">
<meta property="og:type" content="article">
<meta property="og:title" content="concurrency">
<meta property="og:url" content="http://example.com/2017/07/01/lang/lang-1-java/junior/java-5-concurrency/index.html">
<meta property="og:site_name" content="朱继鹏的博客">
<meta property="og:description" content="java并发篇">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-06-30T17:05:00.000Z">
<meta property="article:modified_time" content="2023-11-13T07:17:29.782Z">
<meta property="article:author" content="朱继鹏">
<meta property="article:tag" content="+ java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2017/07/01/lang/lang-1-java/junior/java-5-concurrency/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>concurrency | 朱继鹏的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">朱继鹏的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">天道酬勤，全栈不停</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/07/01/lang/lang-1-java/junior/java-5-concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar/zhujipeng.jpg">
      <meta itemprop="name" content="朱继鹏">
      <meta itemprop="description" content="在全栈的路上狂奔不止">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朱继鹏的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          concurrency
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-07-01 01:05:00" itemprop="dateCreated datePublished" datetime="2017-07-01T01:05:00+08:00">2017-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-13 15:17:29" itemprop="dateModified" datetime="2023-11-13T15:17:29+08:00">2023-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/lang-java-junior/" itemprop="url" rel="index"><span itemprop="name">+ lang + java + junior</span></a>
                </span>
            </span>

          
            <div class="post-description">java并发篇</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38721537/article/details/124581201">Thread详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/alex_xfboy/article/details/90722654">线程上下文切换详解</a></li>
</ul>
</blockquote>
<ul>
<li>线程（Thread）是执行任务的基本单位</li>
<li>进程（Process）是分配资源的基本单位</li>
</ul>
<h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangyechi/article/details/88079983">Thread之线程的创建方式详解</a></li>
</ul>
</blockquote>
<ul>
<li>继承Thread，并实现run方法，然后调用start启动</li>
<li>实现Runnable，并作为target传递给线程进行启动</li>
<li>实现Callable，并用FutureTask包装后作为target传递给线程进行启动</li>
</ul>
<h3 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_37139197/article/details/81989749">Thread之线程的优先级详解</a></li>
</ul>
</blockquote>
<h3 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40087231/article/details/90031253">Thread之守护线程入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41063141/article/details/91939540">Thread之守护线程详解</a></li>
</ul>
</blockquote>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/muzhixi/article/details/105197446">Thread之线程状态入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Elephant_King/article/details/122559577">Thread之线程状态详解</a></li>
</ul>
</blockquote>
<p>NEW、READY、RUNNING、WAITING、TIMED_WAITING、BLOCKED、TERMINATED</p>
<ul>
<li>NEW（新建）：创建线程后进入此状态</li>
<li>READY（就绪）：创建后调用Thread.start或者运行时调用Thread.yield进入此状态</li>
<li>RUNNING（运行）：获取资源（cpu和lock）成功后进入此状态</li>
<li>WAITING（等待）：调用Thread.join、Object.wait、LockSupport.park的非超时方法后进入此状态</li>
<li>TIMED_WAITING（超时等待）：调用Thread.sleep、Thread.join、Object.wait、LockSupport.park的超时方法后进入此状态</li>
<li>BLOCKED（阻塞）：获取lock失败后进入此状态</li>
<li>TERMINATED（死亡）：结束线程后进入此状态</li>
</ul>
<h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lbh199466/article/details/104691252">Thread之线程资源详解</a></li>
</ul>
</blockquote>
<ul>
<li>cpu：中央处理器资源</li>
<li>lock：锁资源</li>
</ul>
<h3 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41540362/article/details/102809420">Thread之线程控制入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011047968/article/details/106954649">Thread之线程控制详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/fengyuyeguirenenen/article/details/122589605">Thread之线程控制之Thread.sleep(0)的意义</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_29384657/article/details/52228578">Thread之线程控制之join详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010983881/article/details/80257703">Thread之线程控制之join原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/shangguoli/article/details/108453551">Thread之线程控制之join唤醒</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/succing/article/details/123023851">Thread之线程控制之join和锁</a></li>
</ul>
</blockquote>
<ul>
<li>Thread.yield：让出cpu资源并进入<code>就绪状态</code>，<code>不释放锁资源</code></li>
<li>Thread.sleep：让出cpu资源并进入<code>等待状态</code>，<code>不释放锁资源</code></li>
<li>Thread.join：让出cpu资源并进入<code>等待状态</code>，<code>会释放锁资源</code></li>
</ul>
<blockquote>
<p>ps：join的作用是阻塞当前线程c（调用t.join的那个线程）并等待线程t结束后继续运行<br>ps：join内部是基于wait（当前线程c调用线程t的wait方法后在t上wait）实现的，JVM会在线程t结束后自动notify在t上wait的线程</p>
</blockquote>
<h3 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41512783/article/details/108943193">Thread之线程中断入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/hl_java/article/details/79162097">Thread之线程中断详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40378837/article/details/116503069">Thread之InterruptedException详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yytree123/article/details/108896876">Thread之interrupt和interrupted的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39682377/article/details/81449451">Thread之interrupted和isInterrupted的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34167819/article/details/85629990">Thread之阻塞IO如何中断</a></li>
</ul>
</blockquote>
<blockquote>
<p>ps： <code>interrupt</code> 可以中断 <code>sleep</code> 、 <code>join</code> 、 <code>wait</code> 等那些判断了 <code>isInterrupted</code> 的操作</p>
</blockquote>
<h3 id="Terminate"><a href="#Terminate" class="headerlink" title="Terminate"></a>Terminate</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26482855/article/details/118676625">Thread之线程终止入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/x541211190/article/details/109428620">Thread之线程终止详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44715697/article/details/114494899">Thread之不推荐使用volatile修饰的标记终止线程</a></li>
</ul>
</blockquote>
<h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated"></a>Deprecated</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/gediseer/article/details/53835295">Thread之废弃的方法入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/hchaoh/article/details/103907661">Thread之废弃的方法详解</a></li>
</ul>
</blockquote>
<p>suspend&#x2F;resume、stop、destroy</p>
<ul>
<li>suspend：不会释放锁，会导致死锁问题</li>
<li>stop：会立即终止线程，导致操作被中断，会导致数据不一致和资源未释放等问题</li>
<li>destroy：从来都没有被实现过，且已经被废弃了（相当于suspend且没有后续的resume）</li>
</ul>
<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ThinkWon/article/details/102021274">线程和进程的区别详解</a></li>
</ul>
</blockquote>
<h3 id="Runnable和Callable的区别"><a href="#Runnable和Callable的区别" class="headerlink" title="Runnable和Callable的区别"></a>Runnable和Callable的区别</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_39634657/article/details/81456810">Runnable和Callable的区别</a></li>
</ul>
</blockquote>
<ul>
<li>Runnable不能获取返回值</li>
<li>Callable和Future、FutureTask配合可以获取返回值</li>
</ul>
<h3 id="Thread的start和run的区别"><a href="#Thread的start和run的区别" class="headerlink" title="Thread的start和run的区别"></a>Thread的start和run的区别</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Mypromise_TFS/article/details/81096007">run和start的区别</a></li>
</ul>
</blockquote>
<ul>
<li>start是本地方法，会启动线程</li>
<li>run是普通方法，不会启动线程</li>
</ul>
<blockquote>
<p>start调用了start0，start0是本地方法</p>
</blockquote>
<h3 id="Thread的start能调用多次吗"><a href="#Thread的start能调用多次吗" class="headerlink" title="Thread的start能调用多次吗"></a>Thread的start能调用多次吗</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Vae023/article/details/106985222">Thread的start能调用多次吗</a></li>
</ul>
</blockquote>
<p>不能，再次调用时会检测到状态变化后抛出 <code>IllegalThreadStateException</code> 异常</p>
<h3 id="Thread的sleep和yield的区别"><a href="#Thread的sleep和yield的区别" class="headerlink" title="Thread的sleep和yield的区别"></a>Thread的sleep和yield的区别</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/rod0320/article/details/123167174">sleep和yield的区别</a></li>
</ul>
</blockquote>
<ul>
<li>方法：都是Thread的静态方法</li>
<li>锁：都不释放锁</li>
<li>状态：sleep进入到等待状态，yield进入到就绪状态</li>
</ul>
<h3 id="Thread的sleep和join的区别"><a href="#Thread的sleep和join的区别" class="headerlink" title="Thread的sleep和join的区别"></a>Thread的sleep和join的区别</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/rod0320/article/details/123167174">sleep和join的区别</a></li>
</ul>
</blockquote>
<ul>
<li>方法：sleep是Thread的静态方法，join是Thread的实例方法</li>
<li>锁：sleep不释放锁，join释放锁</li>
<li>状态：都是进入到等待状态</li>
</ul>
<h3 id="Thread的join和wait的区别"><a href="#Thread的join和wait的区别" class="headerlink" title="Thread的join和wait的区别"></a>Thread的join和wait的区别</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/rod0320/article/details/123167174">join和wait的区别</a></li>
</ul>
</blockquote>
<ul>
<li>方法：join是Thread的实例方法，wait是Object的实例方法</li>
<li>锁：都会释放锁</li>
<li>状态：都是进入到等待状态</li>
</ul>
<blockquote>
<p>ps：join是通过wait来实现的，所以和wait没区别</p>
</blockquote>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="Basic-1"><a href="#Basic-1" class="headerlink" title="Basic"></a>Basic</h2><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lisheng19870305/article/details/110100947">ThreadLocal入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010445301/article/details/111322569">ThreadLocal进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangnanwlw/article/details/108866086">ThreadLocal详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42285585/article/details/119035982">ThreadLocal精进</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/meism5/article/details/90413860">ThreadLocal原理入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38293564/article/details/80459827">ThreadLocal原理进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44377709/article/details/105962734">ThreadLocal原理详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39192827/article/details/85611873">ThreadLocal之强弱引用</a></li>
</ul>
</blockquote>
<h3 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN2497242041/article/details/120192343">ThreadLocal使用场景</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37609060/article/details/122410302">ThreadLocal保证DateFormat的线程安全</a></li>
</ul>
</blockquote>
<h3 id="Leak"><a href="#Leak" class="headerlink" title="Leak"></a>Leak</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u022812849/article/details/107513876">ThreadLocal内存泄漏入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/y5492853/article/details/123984840">ThreadLocal内存泄漏详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Weixiaohuai/article/details/120351275">内存泄漏详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sushuiyuzhou/article/details/108463530">内存溢出详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/golden_zhj/article/details/86574481">内存泄漏和内存溢出的区别入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44798288/article/details/119641944">内存泄漏和内存溢出的区别详解</a></li>
</ul>
</blockquote>
<h3 id="Inherit"><a href="#Inherit" class="headerlink" title="Inherit"></a>Inherit</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/a837199685/article/details/52712547">ThreadLocal之子线程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/liubenlong007/article/details/107050929">ThreadLocal之线程池</a></li>
</ul>
</blockquote>
<h2 id="Question-1"><a href="#Question-1" class="headerlink" title="Question"></a>Question</h2><h3 id="ThreadLocal为什么会内存泄漏"><a href="#ThreadLocal为什么会内存泄漏" class="headerlink" title="ThreadLocal为什么会内存泄漏"></a>ThreadLocal为什么会内存泄漏</h3><ol>
<li>ThreadLocal是基于ThreadLocalMap实现的</li>
<li>Thread引用了ThreadLocalMap</li>
<li>ThreadLocalMap引用了key和value</li>
<li>key弱引用了ThreadLocal</li>
<li>当ThreadLocal不在使用时，即没有强引用时</li>
<li>由于key是弱引用，所以ThreadLocal会被回收</li>
<li>此时无法通过ThreadLocal访问value，value应该被回收</li>
<li>由于Thread间接强引用了value，所以要先回收Thread</li>
<li>但是如果Thread是线程池时，Thread不能被回收，所以value不能回收</li>
<li>此时value既不能访问又不能回收，就造成了内存泄漏</li>
</ol>
<blockquote>
<p>ps：ThreadLocal在get和set时会自动检测哪些key指向null的entry并清除，可以一定程度减轻内存泄漏的影响</p>
</blockquote>
<h3 id="ThreadLocalMap的key为什么是弱引用"><a href="#ThreadLocalMap的key为什么是弱引用" class="headerlink" title="ThreadLocalMap的key为什么是弱引用"></a>ThreadLocalMap的key为什么是弱引用</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/BruceLiu_code/article/details/118518148">ThreadLocalMap的key为什么是弱引用</a></li>
</ul>
</blockquote>
<p>当ThreadLocal不再使用时，即没有强引用时，key为弱引用可以保证ThreadLocal被回收来避免内存泄漏</p>
<h3 id="ThreadLocalMap的value为什么是强引用"><a href="#ThreadLocalMap的value为什么是强引用" class="headerlink" title="ThreadLocalMap的value为什么是强引用"></a>ThreadLocalMap的value为什么是强引用</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/foxException/article/details/123496254">ThreadLocalMap的value为什么是强引用</a></li>
</ul>
</blockquote>
<p>如果value是弱引用，垃圾回收后value指向了null，此时ThreadLocal还活着却获取不到value对象就不符合逻辑</p>
<h3 id="ThreadLocalMap为什么不用Thread做key"><a href="#ThreadLocalMap为什么不用Thread做key" class="headerlink" title="ThreadLocalMap为什么不用Thread做key"></a>ThreadLocalMap为什么不用Thread做key</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_72088858/article/details/126699225">ThreadLocalMap为什么不用Thread做key</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/trayvonnn/article/details/112524314">HashMap线程不安全导致的死循环和数据丢失</a></li>
</ul>
</blockquote>
<ul>
<li>如果用ThreadLocalMap做key（此时ThreadLocalMap就会是ThreadLocal的实例），就会有多个线程访问map，就需要保证线程安全，复杂性会提高，并且并发性也会降低</li>
<li>如果用ThreadLocal做key（此时ThreadLocalMap就会是Thread的实例），那么访问map的线程都是持有map的那一个线程，就不需要保证线程安全，复杂性会降低，并且并发性也会提高</li>
<li>如果是用二级map，那就会和ThreadLocalMap做key一样，就会有多个线程访问map，就需要保证线程安全，还需要两次寻址，复杂性会更高，并且并发性也会更低</li>
</ul>
<h3 id="ThreadLocal为什么要定义成静态变量"><a href="#ThreadLocal为什么要定义成静态变量" class="headerlink" title="ThreadLocal为什么要定义成静态变量"></a>ThreadLocal为什么要定义成静态变量</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/justlpf/article/details/106097539">ThreadLocal为什么要定义成静态变量</a></li>
</ul>
</blockquote>
<p>定义成实例变量，容易重复创建，造成内存浪费</p>
<h3 id="ThreadLocal和局部变量的区别"><a href="#ThreadLocal和局部变量的区别" class="headerlink" title="ThreadLocal和局部变量的区别"></a>ThreadLocal和局部变量的区别</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yk20091201/article/details/88844954">ThreadLocal和局部变量的区别</a></li>
</ul>
</blockquote>
<p>ThreadLocal是线程（隔离）变量，局部变量是方法（隔离）或者代码块（隔离）变量</p>
<h1 id="Safe"><a href="#Safe" class="headerlink" title="Safe"></a>Safe</h1><h2 id="Basic-2"><a href="#Basic-2" class="headerlink" title="Basic"></a>Basic</h2><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/q669239799/article/details/90614077">线程安全详解</a></li>
</ul>
</blockquote>
<ul>
<li>不可变：不可变对象一定是安全的</li>
<li>绝对安全：对象的单个操作和复合操作都是安全的</li>
<li>相对安全：对象的单个操作是安全的，复合操作需要额外的同步措施来保证安全</li>
<li>兼容安全：对象的所有操作都不安全，但可以通过额外的同步措施来保证安全</li>
<li>安全对立：即使采取了额外的同步措施也无法保证安全</li>
</ul>
<h2 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h2><h3 id="线程安全之基本原则"><a href="#线程安全之基本原则" class="headerlink" title="线程安全之基本原则"></a>线程安全之基本原则</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/songzi1228/article/details/102506136">线程安全之基本原则入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_58196614/article/details/126257857">线程安全之基本原则详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014191624/article/details/118991744">线程安全之基本原则之volatile</a></li>
</ul>
</blockquote>
<ul>
<li>原子性：某个操作不可被中断（synchronized、lock、atomic）</li>
<li>可见性：对主存的修改可以及时地被其他线程看到（synchronized、lock、volatile）</li>
<li>有序性：指令没有被重新排列（synchronized、lock、volatile）</li>
</ul>
<blockquote>
<p>ps：volatile只能保证可见性和有序性，atomic只能保证原子性<br>所以volatile只能修饰哪些已经保证了原子性的操作，比如 <code>flag读写</code> 、 <code>atomic类</code> 、 <code>cas操作</code></p>
</blockquote>
<h3 id="线程安全之实现方案"><a href="#线程安全之实现方案" class="headerlink" title="线程安全之实现方案"></a>线程安全之实现方案</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lililuni/article/details/86534388">线程安全之实现方案入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014454538/article/details/98515807">线程安全之实现方案详解</a></li>
</ul>
</blockquote>
<ul>
<li>共享<ul>
<li>不可变<ul>
<li>不可变对象（Immutable）：通过对象不可变机制实现</li>
</ul>
</li>
<li>访问控制<ul>
<li>悲观锁（LOCK）：通过Mutex机制实现</li>
<li>乐观锁（CAS）：通过CAS机制实现</li>
</ul>
</li>
<li>读写分离<ul>
<li>写时复制（COW）：通过COW机制实现</li>
</ul>
</li>
</ul>
</li>
<li>私有<ul>
<li>方法局部对象（LocalVariable）：通过方法私有机制实现</li>
<li>线程隔离对象（ThreadLocal）：通过线程私有机制实现</li>
</ul>
</li>
</ul>
<h3 id="线程安全之对象安全"><a href="#线程安全之对象安全" class="headerlink" title="线程安全之对象安全"></a>线程安全之对象安全</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/tiandao321/article/details/81300489">线程安全之对象安全入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22701869/article/details/107271921">线程安全之对象安全进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/CsWarmSun/article/details/122050509">线程安全之对象安全详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/dream_weave/article/details/105506795">线程安全之对象发布和溢出详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010963948/article/details/77672429">线程安全之对象发布溢出和线程封闭详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/songzi1228/article/details/90714122">线程安全之单例模式和volatile入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/java_1996/article/details/87472644">线程安全之单例模式和volatile详解</a></li>
</ul>
</blockquote>
<p>单例模式中volatile的作用</p>
<ul>
<li>保证可见性：volatile保证可见性，避免双重判断时没有读到最新的状态从而重复创建对象</li>
<li>保证有序性：volatile禁止指令重排，避免对象创建时还没有构造完成就交付引用从而错误的使用不完整的对象</li>
</ul>
<h3 id="线程安全之变量安全"><a href="#线程安全之变量安全" class="headerlink" title="线程安全之变量安全"></a>线程安全之变量安全</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42924666/article/details/121293321">线程安全之静态变量详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/nihui123/article/details/102824471">线程安全之实例变量详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44143902/article/details/116067285">线程安全之方法变量详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45950109/article/details/116723700">线程安全之局部变量详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/f641385712/article/details/104573489">线程安全之线程变量详解</a></li>
</ul>
</blockquote>
<ul>
<li>可共享变量：静态变量、实例变量</li>
<li>只私有变量：局部变量、线程变量</li>
</ul>
<blockquote>
<p>ps：可共享变量需要安全控制，只私有变量不需要安全控制，但是局部变量如果通过返回发布到方法之外后就需要安全控制了</p>
</blockquote>
<h3 id="线程安全之内存安全"><a href="#线程安全之内存安全" class="headerlink" title="线程安全之内存安全"></a>线程安全之内存安全</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ChineseSoftware/article/details/118356699">线程安全之内存安全入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31960623/article/details/115353065">线程安全之内存安全详解</a></li>
</ul>
</blockquote>
<h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_50370837/article/details/124471888">Lock详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38004638/article/details/114736314">Lock分类</a></li>
</ul>
</blockquote>
<h2 id="Basic-3"><a href="#Basic-3" class="headerlink" title="Basic"></a>Basic</h2><h3 id="锁的作用"><a href="#锁的作用" class="headerlink" title="锁的作用"></a>锁的作用</h3><p>对并发操作进行安全控制</p>
<ul>
<li>保证原子性：通过Mutex机制保证同时只有一个操作者使用资源</li>
<li>保证可见性：加锁时触发Load屏障，解锁时触发Store屏障</li>
<li>保证有序性：禁止指令重排</li>
</ul>
<h4 id="并发操作的控制方式"><a href="#并发操作的控制方式" class="headerlink" title="并发操作的控制方式"></a>并发操作的控制方式</h4><blockquote>
<ol>
<li>悲观锁（LOCK）：适合 <code>低并发</code> 、 <code>常规读写</code> 、 <code>强一致性</code> 的场景</li>
<li>乐观锁（CAS ）：适合 <code>高并发</code> 、 <code>读多写少</code> 、 <code>弱一致性</code> 的场景</li>
<li>写时复制（COW）：适合 <code>高并发</code> 、 <code>读多写少</code> 、 <code>弱一致性</code> 的场景</li>
</ol>
</blockquote>
<blockquote>
<p>ps：CAS如果写多的话，竞争激烈时大量的操作失败会浪费cpu资源<br>ps：COW如果写多的话，频繁分配内存时来不及回收会造成内存占用过高</p>
</blockquote>
<h4 id="并发操作的互斥机制"><a href="#并发操作的互斥机制" class="headerlink" title="并发操作的互斥机制"></a>并发操作的互斥机制</h4><blockquote>
<ol>
<li>悲观锁（LOCK）：写写互斥，读写互斥，读读不互斥</li>
<li>乐观锁（CAS ）：写写互斥，读写不互斥，读读不互斥</li>
<li>写时复制（COW）：写写互斥，读写不互斥，读读不互斥</li>
</ol>
</blockquote>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><h4 id="锁的类型分类"><a href="#锁的类型分类" class="headerlink" title="锁的类型分类"></a>锁的类型分类</h4><ul>
<li>是否锁住资源：悲观锁（锁住资源）、乐观锁（不锁住资源）</li>
<li>是否独占资源：排他锁（独占资源）、共享锁（共享资源）、读写锁（读共享和写独占）</li>
<li>是否阻塞线程：同步锁（阻塞）、自旋锁（不阻塞）、读写锁（读写之间互斥时阻塞）</li>
</ul>
<h4 id="锁的实现分类"><a href="#锁的实现分类" class="headerlink" title="锁的实现分类"></a>锁的实现分类</h4><ul>
<li>是否锁住资源：悲观锁（synchronized、ReentrantLock、ReentrantReadWriteLock）、乐观锁（StampedLock）</li>
<li>是否共享资源：排他锁（synchronized、ReentrantLock）、共享锁（Semaphore）、读写锁（ReentrantReadWriteLock、StampedLock）</li>
<li>是否阻塞线程：同步锁（synchronized、ReentrantLock、ReentrantReadWriteLock、StampedLock）、自旋锁（SpinLock）</li>
</ul>
<h4 id="锁的范围分类"><a href="#锁的范围分类" class="headerlink" title="锁的范围分类"></a>锁的范围分类</h4><ul>
<li>线程锁</li>
<li>进程锁</li>
<li>分布式锁</li>
</ul>
<blockquote>
<p>ps：数据库锁</p>
</blockquote>
<h3 id="锁的原理"><a href="#锁的原理" class="headerlink" title="锁的原理"></a>锁的原理</h3><ul>
<li>悲观锁：Mutex + 阻塞 + 唤醒</li>
<li>乐观锁：CAS + 自旋 + 重试</li>
<li>读写锁：COW</li>
</ul>
<h3 id="锁的特性"><a href="#锁的特性" class="headerlink" title="锁的特性"></a>锁的特性</h3><ul>
<li>是否支持重入：同一个线程是否可以多次获取锁</li>
<li>是否支持中断：线程是否可以响应中断请求</li>
<li>是否支持公平：线程是否能够公平的处理请求</li>
</ul>
<blockquote>
<p>ps：公平（排队且先进先出）、非公平（先插队，如果失败后再排队）</p>
</blockquote>
<h3 id="锁的问题"><a href="#锁的问题" class="headerlink" title="锁的问题"></a>锁的问题</h3><h4 id="DeadLock（死锁）"><a href="#DeadLock（死锁）" class="headerlink" title="DeadLock（死锁）"></a>DeadLock（死锁）</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/SUKI547/article/details/102678560">死锁问题入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/chow__zh/article/details/123968286">死锁问题详解</a></li>
</ul>
</blockquote>
<p>死锁的产生必要的条件</p>
<ul>
<li>互斥使用：即当资源被一个线程占用时，别的线程不能使用</li>
<li>不可抢占：资源请求者不能强制从资源占有者手中抢夺资源，资源只能由占有者主动释放</li>
<li>资源保持：当资源请求者在请求其他资源的同时保持对现有资源的占有</li>
<li>循环等待：多个线程存在环路的锁依赖关系而永远等待下去（例如T1占有T2需要的资源，T2占有T3需要的资源，T3占有T1需要的资源，这种情况可能会形成一个等待环路）</li>
</ul>
<h4 id="Starvation（饥饿）"><a href="#Starvation（饥饿）" class="headerlink" title="Starvation（饥饿）"></a>Starvation（饥饿）</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37734042/article/details/108417432">饥饿和公平问题详解</a></li>
</ul>
</blockquote>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zgcy123456/article/details/124231957">synchronized锁入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/chenzengnian123/article/details/122686371">synchronized锁详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_73311735/article/details/131304965">synchronized锁为什么默认策略是非公平的</a></li>
</ul>
</blockquote>
<ul>
<li>修饰类和静态方法，锁是当前类的Class对象</li>
<li>修饰实例方法，锁是当前实例对象</li>
<li>修饰代码块，锁是括号里面的对象</li>
</ul>
<h4 id="synchronized锁原理"><a href="#synchronized锁原理" class="headerlink" title="synchronized锁原理"></a>synchronized锁原理</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/javazejian/article/details/72828483">synchronized锁原理入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41590779/article/details/107821829">synchronized锁原理详解</a></li>
</ul>
</blockquote>
<ul>
<li>锁方法：通过方法的<code>ACC_SYNCHRONIZED</code>标识实现</li>
<li>锁代码块：通过<code>monitorenter</code>和<code>monitorexit</code>指令实现</li>
</ul>
<h4 id="synchronized锁膨胀"><a href="#synchronized锁膨胀" class="headerlink" title="synchronized锁膨胀"></a>synchronized锁膨胀</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41477034/article/details/119775535">synchronized锁膨胀</a></li>
</ul>
</blockquote>
<ul>
<li>无锁：没有线程获取锁</li>
<li>偏向锁：只有一个线程获取锁时进入此状态（通过CAS对象的标记头获取锁）</li>
<li>轻量级锁：多个线程获取锁时进入此状态（通过CAS对象的标记头获取锁，获取锁失败的线程需进行自旋）</li>
<li>重量级锁：多个线程获取锁并且有线程自旋失败（10次且可配置）时进入此状态（通过操作系统的Mutex机制获取锁）</li>
</ul>
<h4 id="synchronized锁消除"><a href="#synchronized锁消除" class="headerlink" title="synchronized锁消除"></a>synchronized锁消除</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yuan_qh/article/details/100195185">synchronized锁消除</a></li>
</ul>
</blockquote>
<h4 id="synchronized锁粗化"><a href="#synchronized锁粗化" class="headerlink" title="synchronized锁粗化"></a>synchronized锁粗化</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27471405/article/details/115410412">synchronized锁粗化</a></li>
</ul>
</blockquote>
<h4 id="synchronized锁自旋"><a href="#synchronized锁自旋" class="headerlink" title="synchronized锁自旋"></a>synchronized锁自旋</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yzpbright/article/details/105483620">synchronized锁自旋</a></li>
</ul>
</blockquote>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42411214/article/details/105100303">ReentrantLock详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/every__day/article/details/108818343">ReentrantLock原理</a></li>
</ul>
</blockquote>
<h4 id="lock-lock-写在-try-代码块内部行吗？"><a href="#lock-lock-写在-try-代码块内部行吗？" class="headerlink" title="lock.lock() 写在 try 代码块内部行吗？"></a>lock.lock() 写在 try 代码块内部行吗？</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013568373/article/details/98480603">lock.lock() 写在 try 代码块内部行吗？</a></li>
</ul>
</blockquote>
<p>不能，如果写在try里面，当lock异常时，finally会执行unlock，unlock的时候检测到线程没有先持有锁会抛出 <code>IllegalMonitorStateException</code> 异常</p>
<h4 id="如何安全的unlock"><a href="#如何安全的unlock" class="headerlink" title="如何安全的unlock"></a>如何安全的unlock</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/w8y56f/article/details/115608666">如何安全的unlock</a></li>
</ul>
</blockquote>
<h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wtopps/article/details/106202418">读写锁之ReentrantReadWriteLock和StampedLock入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Longstar_L/article/details/112241559">读写锁之ReentrantReadWriteLock和StampedLock详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43631716/article/details/121492528">ReentrantReadWriteLock详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42039228/article/details/123181145">ReentrantReadWriteLock原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42634696/article/details/105135368">StampedLock详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangnanwlw/article/details/109848035">StampedLock原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiangyue1221/article/details/123518116">读写锁之读写之间互斥吗</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38737992/article/details/92796403">读写锁之锁降级和锁升级入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/GDUT_Trim/article/details/120796255">读写锁之锁降级和锁升级详解</a></li>
</ul>
</blockquote>
<ul>
<li>ReentrantReadWriteLock（悲观读写锁）：写写互斥，<code>读写互斥</code>，读读不互斥</li>
<li>StampedLock（乐观读写锁）：写写互斥，<code>读写不互斥</code>，读读不互斥</li>
</ul>
<blockquote>
<p><code>悲观读写</code> ： <code>读写互斥</code> ， <code>乐观读写</code> ： <code>读写不互斥</code></p>
</blockquote>
<h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40276626/article/details/119900143">Atomic详解</a></li>
</ul>
</blockquote>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lwang_IT/article/details/121638089">CAS入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43232955/article/details/107452893">CAS进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_41632451/article/details/124754457">CAS详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/hl_java/article/details/90520405">CAS存在的问题以及解决方案</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/rekingman/article/details/89464001">CAS和volatile配合使用保证线程安全</a></li>
</ul>
</blockquote>
<p>CAS的问题</p>
<ul>
<li>ABA问题：可以加版本号解决</li>
<li>竞争激烈时大量的操作失败会浪费cpu资源：需要限制失败次数</li>
<li>自旋循环时间长的话会占用和浪费cpu资源：需要控制循环次数</li>
<li>只能保证单个变量操作的原子性：可以合并多个变量的操作为单个操作</li>
</ul>
<h4 id="OptimisticLock（乐观锁）"><a href="#OptimisticLock（乐观锁）" class="headerlink" title="OptimisticLock（乐观锁）"></a>OptimisticLock（乐观锁）</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/LyySwx/article/details/125634783">乐观锁详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_32421529/article/details/104992791">乐观锁的优点和缺点</a></li>
</ul>
</blockquote>
<p>乐观锁的优点和缺点</p>
<ul>
<li>优点：避免冲突时等待造成的耗时</li>
<li>缺点：竞争激烈时大量的操作失败会浪费cpu资源</li>
</ul>
<h4 id="SpinLock（自旋锁）"><a href="#SpinLock（自旋锁）" class="headerlink" title="SpinLock（自旋锁）"></a>SpinLock（自旋锁）</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46146718/article/details/120647711">自旋锁详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/vincent_wen0766/article/details/108558656">自旋锁的优点和缺点</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46311811/article/details/122354855">自旋锁和单核处理器</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/fengyuyeguirenenen/article/details/122554553">CAS和自旋到底是一个概念吗</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wodetongnian/article/details/104044865">CAS自旋实现样例</a></li>
</ul>
</blockquote>
<p>自旋锁的优点和缺点</p>
<ul>
<li>优点：避免上下文切换带来的耗时</li>
<li>缺点：自旋循环时间长的话会占用和浪费cpu资源</li>
</ul>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/long199366/article/details/112506704">AQS详解</a></li>
</ul>
</blockquote>
<ul>
<li>isHeldExclusively()：该线程是否正在独占资源（只有用到Condition时才需要去实现它）</li>
<li>tryAcquire(int)：独占方式，成功则返回true，失败则返回false</li>
<li>tryRelease(int)：独占方式，成功则返回true，失败则返回false</li>
<li>tryAcquireShared(int)：共享方式，负数表示失败，0表示成功但没有剩余资源，正数表示成功且有剩余资源</li>
<li>tryReleaseShared(int)：共享方式，如果释放后允许唤醒后续等待对象则返回true，否则返回false</li>
</ul>
<h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangliangluang/article/details/123033352">LockSupport详解</a></li>
</ul>
</blockquote>
<p>LockSupport.park可以实现 <code>阻塞</code> 功能但不能实现 <code>互斥</code> 功能</p>
<h2 id="Question-2"><a href="#Question-2" class="headerlink" title="Question"></a>Question</h2><h3 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/z123456789XDW/article/details/100031621">synchronized和volatile的区别</a></li>
</ul>
</blockquote>
<ul>
<li>synchronized可以修饰类、字段、方法，volatile只能修饰字段</li>
<li>synchronized保证原子性、可见性、有序性，volatile只保证可见性、有序性</li>
<li>synchronized会阻塞线程，volatile不会阻塞线程</li>
</ul>
<h3 id="synchronized和Lock的区别"><a href="#synchronized和Lock的区别" class="headerlink" title="synchronized和Lock的区别"></a>synchronized和Lock的区别</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/drrzh/article/details/119519455">synchronized和Lock的区别</a></li>
</ul>
</blockquote>
<ul>
<li>位置：<ul>
<li>synchronized是java关键字，Lock是java类</li>
</ul>
</li>
<li>实现：<ul>
<li>synchronized基于操作系统mutex机制实现，Lock基于java的AQS机制实现</li>
</ul>
</li>
<li>操作：<ul>
<li>synchronized会自动释放锁，Lock需要手动释放</li>
</ul>
</li>
<li>超时：<ul>
<li>synchronized不能设置等待超时时间，Lock可以设置等待超时时间</li>
</ul>
</li>
<li>状态：<ul>
<li>synchronized无法判断是否获取了锁，Lock可以判断是否获取了锁</li>
</ul>
</li>
<li>特性：<ul>
<li>synchronized支持重入，Lock也支持重入</li>
<li>synchronized不支持中断，Lock可支持中断（也支持不可中断）</li>
<li>synchronized不支持公平锁，Lock可支持公平锁（也支持非公平）</li>
</ul>
</li>
</ul>
<h1 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h1><h2 id="Basic-4"><a href="#Basic-4" class="headerlink" title="Basic"></a>Basic</h2><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ChenRui_yz/article/details/126926950">java异步编程入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_73493267/article/details/126611222">java异步编程进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/afreon/article/details/128825831">java异步编程详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/a321123b/article/details/123389278">java并发编程入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/a321123b/article/details/123482491">java并发编程进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/a321123b/article/details/123482812">java并发编程详解</a></li>
</ul>
</blockquote>
<ul>
<li>Future：普通任务的接口，核心实现类为FutureTask</li>
<li>RunnableFuture：对Runnable进行包装的Future</li>
<li>FutureTask：Future的实现类</li>
<li>ScheduledFuture：调度任务的接口，核心实现类为ScheduledFutureTask</li>
<li>RunnableScheduledFuture：对Runnable进行包装的ScheduledFuture</li>
<li>ScheduledFutureTask：ScheduledFuture的实现类</li>
<li>Delayed：延迟任务的接口，继承了Comparable</li>
<li>ExecutorService：普通任务执行器，核心实现类为ThreadPoolExecutor</li>
<li>ScheduledExecutorService：调度任务执行器，核心实现类为ScheduledThreadPoolExecutor</li>
<li>CompletionStage：异步任务调度和计算的接口</li>
<li>CompletableFuture：异步任务调度和计算的实现类</li>
</ul>
<h3 id="任务的运行方式"><a href="#任务的运行方式" class="headerlink" title="任务的运行方式"></a>任务的运行方式</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013288190/article/details/114257211">任务的运行方式</a></li>
</ul>
</blockquote>
<p><code>任务（Task）</code> 的 <code>控制</code> 方式如下</p>
<ul>
<li>顺序：sequential</li>
<li>并发：concurrent</li>
</ul>
<p><code>执行器（Executor）</code> 的 <code>执行</code> 方式如下</p>
<ul>
<li>串行：serial</li>
<li>并行：parallel</li>
</ul>
<blockquote>
<p>ps：顺序和并发描述的是任务能否同时 <code>开始</code> ，串行和并行描述的是任务能否同时 <code>执行</code></p>
</blockquote>
<h4 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/kevin_mails/article/details/80251234">并发和并行的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Cai_deLong/article/details/108302842">并发和并行图解</a></li>
</ul>
</blockquote>
<ul>
<li>并发（Concurrency）：一个人<code>分时</code>干多件事</li>
<li>并行（Parallelism）：多个人<code>分工</code>干一件事</li>
</ul>
<h4 id="集群和分布式的区别"><a href="#集群和分布式的区别" class="headerlink" title="集群和分布式的区别"></a>集群和分布式的区别</h4><ul>
<li>集群（Cluster）：多个人<code>轮流</code>干一件事</li>
<li>分布式（Distributed）：多个人<code>分工</code>干一件事</li>
</ul>
<h4 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h4><ul>
<li>同步（Synchronization）：<code>主动</code>获取结果，不一定<code>阻塞</code>的（轮询获取结果就不是阻塞的）</li>
<li>异步（Asynchronization）：<code>被动</code>获取结果，一般是<code>非阻塞</code>的</li>
</ul>
<h3 id="任务的调度方式"><a href="#任务的调度方式" class="headerlink" title="任务的调度方式"></a>任务的调度方式</h3><h4 id="普通调度（normal）"><a href="#普通调度（normal）" class="headerlink" title="普通调度（normal）"></a>普通调度（normal）</h4><p>可以使用ScheduledThreadPoolExecutor的 <code>schedule</code> 方法实现</p>
<h4 id="延时调度（delay）"><a href="#延时调度（delay）" class="headerlink" title="延时调度（delay）"></a>延时调度（delay）</h4><p>可以使用ScheduledThreadPoolExecutor的 <code>schedule</code> 方法中的 <code>delay</code> 参数实现</p>
<h4 id="定时调度（timing）"><a href="#定时调度（timing）" class="headerlink" title="定时调度（timing）"></a>定时调度（timing）</h4><p>可以使用ScheduledThreadPoolExecutor的如下方法实现</p>
<ul>
<li><code>scheduleAtFixedRate</code>：固定<code>频率</code>的触发任务的执行</li>
<li><code>scheduleWithFixedDelay</code>：固定<code>延迟</code>后触发任务的执行</li>
</ul>
<h2 id="Usage-1"><a href="#Usage-1" class="headerlink" title="Usage"></a>Usage</h2><h3 id="SyncTask"><a href="#SyncTask" class="headerlink" title="SyncTask"></a>SyncTask</h3><p>java中没有SyncTask类，对应的类为FutureTask</p>
<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014209205/article/details/80598209">Future详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43145361/article/details/97049103">RunnableFuture详解</a></li>
</ul>
</blockquote>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lp284558195/article/details/115670103">FutureTask使用入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40685275/article/details/99838677">FutureTask使用详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27264789/article/details/100129323">FutureTask原理详解</a></li>
</ul>
</blockquote>
<h5 id="Basic-5"><a href="#Basic-5" class="headerlink" title="Basic"></a>Basic</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/kking_edc/article/details/108297917">FutureTask调用之使用Thread运行</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38750084/article/details/84801211">FutureTask调用之使用线程池运行</a></li>
</ul>
</blockquote>
<h5 id="State-1"><a href="#State-1" class="headerlink" title="State"></a>State</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39654841/article/details/90631795">FutureTask的状态详解</a></li>
</ul>
</blockquote>
<ul>
<li>NEW（已创建）：创建FutureTask之后</li>
<li>COMPLETING（完成中）：设置结果开始时，是一个中间过渡态</li>
<li>NORMAL（已正常完成）：设置结果（正常完成）结束后</li>
<li>EXCEPTIONAL（已异常完成）：设置结果（异常完成）结束后</li>
<li>CANCELLED（已取消）：取消任务后</li>
<li>INTERRUPTING（中断中）：中断开始时，是一个中间过渡态</li>
<li>INTERRUPTED（已断中）：中断结束后</li>
</ul>
<h5 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zn0999/article/details/109034085">FutureTask.get异常捕获详解</a></li>
</ul>
</blockquote>
<p>FutureTask.get异常如下</p>
<ul>
<li>CancellationException：任务提交后<code>取消</code>抛出的异常</li>
<li>InterruptedException：任务执行时<code>中断</code>抛出的异常</li>
<li>ExecutionException：任务执行时<code>出错</code>抛出的异常</li>
<li>TimeoutException：任务执行时<code>超时</code>抛出的异常</li>
</ul>
<blockquote>
<p>ps：cancel时如果任务还在执行中，就会抛出CancellationException（RuntimeException），否则就可能抛出InterruptedException</p>
</blockquote>
<h5 id="Cancel"><a href="#Cancel" class="headerlink" title="Cancel"></a>Cancel</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014644574/article/details/114327939">FutureTask.cancel取消任务详解</a></li>
</ul>
</blockquote>
<blockquote>
<p>ps：cancel时如果任务已经执行，会调用 <code>Thread.interrupt</code> 对 <code>当前</code> 线程进行中断</p>
</blockquote>
<h5 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/cuiwjava/article/details/108186030">FutureTask.get超时原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/cenjianteng/article/details/91873019">FutureTask之实现超时任务</a></li>
</ul>
</blockquote>
<blockquote>
<p>ps：get的阻塞效果是通过LockSupport.park或者LockSupport.parkNanos实现的</p>
</blockquote>
<h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/afreon/article/details/128825831">java异步编程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_62789540/article/details/123223427">python异步编程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/howgod/article/details/93978297">javascript异步编程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/a645293829/article/details/125324761">java异步编程多线程和MQ哪个好</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sky_jiangcheng/article/details/82025154">java异步编程线程池和MQ哪个好</a></li>
</ul>
</blockquote>
<p>java中没有AsyncTask类，对应的类为CompletableFuture</p>
<h4 id="CompletionStage"><a href="#CompletionStage" class="headerlink" title="CompletionStage"></a>CompletionStage</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42695485/article/details/110407485">CompletionStage详解</a></li>
</ul>
</blockquote>
<h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><h5 id="Basic-6"><a href="#Basic-6" class="headerlink" title="Basic"></a>Basic</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/duke_ding2/article/details/107562881">CompletableFuture使用入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43631716/article/details/121766969">CompletableFuture使用详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44337445/article/details/121710515">CompletableFuture方法总结</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39332800/article/details/108185931">CompletableFuture原理详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/q258523454/article/details/117967874">CompletableFuture非async方法和async方法的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/leon_wzm/article/details/80560081">CompletableFuture非async方法的执行线程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43722048/article/details/121942164">CompletableFuture.allOf获取所有结果</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014526725/article/details/96474500">java9 CompletableFuture改进</a></li>
</ul>
</blockquote>
<ul>
<li>包含async方法和非async方法</li>
<li>包含async的有两种方法，一种使用默认的forkjoin线程池，一种是使用自定义线程池</li>
<li>包含apply的都使用Function回调，有输入，有返回值</li>
<li>包含accept的都使用Consumer回调，有输入，没有返回</li>
<li>包含supply的都使用Supplier回调，没有输入，有返回</li>
<li>包含run的都使用Runnable回调，没有输入，没有返回</li>
</ul>
<h6 id="创建任务（createTask）"><a href="#创建任务（createTask）" class="headerlink" title="创建任务（createTask）"></a>创建任务（createTask）</h6><p>####### supplyAsync</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span><br></pre></td></tr></table></figure>

<p>####### runAsync</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span></span><br></pre></td></tr></table></figure>

<p>####### completedFuture</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">completedFuture</span><span class="params">(U value)</span></span><br></pre></td></tr></table></figure>

<h6 id="处理结果（handleResult）"><a href="#处理结果（handleResult）" class="headerlink" title="处理结果（handleResult）"></a>处理结果（handleResult）</h6><blockquote>
<p>result &#x3D; value or error</p>
</blockquote>
<p>####### thenApply（thenApplyValue）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span></span><br></pre></td></tr></table></figure>

<p>####### thenAccept（thenAcceptValue）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAccept</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span></span><br></pre></td></tr></table></figure>

<p>####### thenRun（thenRun）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRun</span><span class="params">(Runnable action)</span></span><br></pre></td></tr></table></figure>

<p>####### exceptionally（thenApplyError）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">exceptionally</span><span class="params">(Function&lt;Throwable,? extends T&gt; fn)</span></span><br></pre></td></tr></table></figure>

<p>####### handle（thenApplyResult）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handle</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> T,Throwable,? extends U&gt; fn)</span></span><br></pre></td></tr></table></figure>

<p>####### whenComplete（thenAcceptResult）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> Throwable&gt; action)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>thenRun不关心值，也不关心异常（??? 会吃掉异常，支持从异常中恢复并继续后面的操作）</li>
<li>thenApply和thenAccept只关心值，不关心异常（??? 会吃掉异常，支持从异常中恢复并继续后面的操作）</li>
<li>exceptionally不关心值，只关心异常（会吃掉异常，支持从异常中恢复并继续后面的操作）</li>
<li>handle既关心值，也关心异常（会吃掉异常，支持从异常中恢复并继续后面的操作）</li>
<li>whenComplete既关心值，也关心异常（不会吃掉异常，不支持从异常中恢复并中断后面的操作）</li>
</ul>
</blockquote>
<h6 id="设置结果（setResult）"><a href="#设置结果（setResult）" class="headerlink" title="设置结果（setResult）"></a>设置结果（setResult）</h6><p>####### 设置结果（setValue）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">complete</span><span class="params">(T value)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtrudeValue</span><span class="params">(T value)</span></span><br></pre></td></tr></table></figure>

<p>####### 设置结果（setError）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">completeExceptionally</span><span class="params">(Throwable ex)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtrudeException</span><span class="params">(Throwable ex)</span></span><br></pre></td></tr></table></figure>

<h6 id="获取结果（getResult）"><a href="#获取结果（getResult）" class="headerlink" title="获取结果（getResult）"></a>获取结果（getResult）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">join</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getNow</span><span class="params">(T valueIfAbsent)</span></span><br></pre></td></tr></table></figure>

<h6 id="检查状态（checkState）"><a href="#检查状态（checkState）" class="headerlink" title="检查状态（checkState）"></a>检查状态（checkState）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompletedExceptionally</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h6 id="编排任务（Choreography）"><a href="#编排任务（Choreography）" class="headerlink" title="编排任务（Choreography）"></a>编排任务（Choreography）</h6><p>####### 链式调用（chain）</p>
<p>######## thenCompose（thenChain）</p>
<p>将当前异步任务的结果交给另一个异步任务处理，并返回另一个异步任务，即串联执行两个任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenCompose</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends CompletionStage&lt;U&gt;&gt; fn)</span></span><br></pre></td></tr></table></figure>

<p>####### 组合调用（group）</p>
<p>组合处理两个或多个任务</p>
<p>######## 组合调用（and）</p>
<p>解决任务之间的 <code>与</code> 编排（choreography）关系，等待两个任务同时完成，并处理两个任务的结果</p>
<p>######### thenCombine（thenApplyBoth）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title function_">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn)</span></span><br></pre></td></tr></table></figure>

<p>######### thenAcceptBoth（thenAcceptBoth）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptBoth</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U&gt; action)</span></span><br></pre></td></tr></table></figure>

<p>######### runAfterBoth（thenRunBoth）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span></span><br></pre></td></tr></table></figure>

<p>######## 组合调用（or）</p>
<p>解决任务之间的 <code>或</code> 编排（choreography）关系，等待任意一个任务完成，并处理快的任务的结果</p>
<p>######### applyToEither（thenApplyEither）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">applyToEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T,U&gt; fn)</span></span><br></pre></td></tr></table></figure>

<p>######### acceptEither（thenAcceptEither）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">acceptEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span></span><br></pre></td></tr></table></figure>

<p>######### runAfterEither（thenRunEither）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAfterEither</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span></span><br></pre></td></tr></table></figure>

<p>######## 组合调用（all）</p>
<p>解决任务之间的 <code>与</code> 编排（choreography）关系，等待所有任务同时完成，并忽略所有任务的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span><br></pre></td></tr></table></figure>

<p>######## 组合调用（any）</p>
<p>解决任务之间的 <code>或</code> 编排（choreography）关系，等待任意一个任务完成，并返回快的任务的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title function_">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span><br></pre></td></tr></table></figure>

<h5 id="State-2"><a href="#State-2" class="headerlink" title="State"></a>State</h5><h5 id="Exception-1"><a href="#Exception-1" class="headerlink" title="Exception"></a>Exception</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://mincong.io/2020/05/30/exception-handling-in-completable-future/">CompletableFuture异常处理详解</a></li>
</ul>
</blockquote>
<h5 id="Cancel-1"><a href="#Cancel-1" class="headerlink" title="Cancel"></a>Cancel</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/listeningsea/article/details/123168224">CompletableFuture.cancel取消任务详解</a></li>
</ul>
</blockquote>
<h5 id="Timeout-1"><a href="#Timeout-1" class="headerlink" title="Timeout"></a>Timeout</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013905744/article/details/109134516">CompletableFuture之实现超时任务</a></li>
</ul>
</blockquote>
<h4 id="More"><a href="#More" class="headerlink" title="More"></a>More</h4><h5 id="AsyncTask（python）"><a href="#AsyncTask（python）" class="headerlink" title="AsyncTask（python）"></a>AsyncTask（python）</h5><h6 id="async和await（python）"><a href="#async和await（python）" class="headerlink" title="async和await（python）"></a>async和await（python）</h6><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43380180/article/details/111573642">python async和await详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/permike/article/details/110821246">python async和await原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_51078229/article/details/112343124">python await必须在async函数中使用</a></li>
</ul>
</blockquote>
<h6 id="coroutine（python）"><a href="#coroutine（python）" class="headerlink" title="coroutine（python）"></a>coroutine（python）</h6><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yifengchaoran/article/details/113854853">python 迭代器和生成器详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_36338224/article/details/109231279">python 生成器和协程详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Smile_Mr/article/details/86624376">python 协程详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27825451/article/details/85226239">python 协程之yield详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27825451/article/details/85234610">python 协程之yield实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27825451/article/details/85244237">python 协程之yield from详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/JENREY/article/details/121231495">python yield详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/jpch89/article/details/87776528">python yield from详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43192617/article/details/117791470">python yield和yield from的区别</a></li>
</ul>
</blockquote>
<h6 id="asyncio（python）"><a href="#asyncio（python）" class="headerlink" title="asyncio（python）"></a>asyncio（python）</h6><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xixihahalelehehe/article/details/106398084">python asyncio详解</a></li>
</ul>
</blockquote>
<h6 id="aiohttp（python）"><a href="#aiohttp（python）" class="headerlink" title="aiohttp（python）"></a>aiohttp（python）</h6><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhb_feng/article/details/118081327">python aiohttp详解</a></li>
</ul>
</blockquote>
<h6 id="Tornado（python）"><a href="#Tornado（python）" class="headerlink" title="Tornado（python）"></a>Tornado（python）</h6><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44634704/article/details/115917628">python tornado异步使用详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013421629/article/details/101293065">python tornado异步原理入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/runner668/article/details/82930988">python tornado异步原理详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/jazywoo123/article/details/17566357">python tornado异步和协程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lyc2016012170/article/details/127219152">python tornado异步库</a></li>
</ul>
</blockquote>
<h6 id="Celery（python）"><a href="#Celery（python）" class="headerlink" title="Celery（python）"></a>Celery（python）</h6><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/aaahtml/article/details/115131246">Celery详解</a></li>
<li><a target="_blank" rel="noopener" href="https://celeryproject.readthedocs.io/zh_CN/latest/userguide/canvas.html">Celery工作流详解</a></li>
<li><a target="_blank" rel="noopener" href="https://celery-docs-cn.readthedocs.io/zh/latest/getting-started/first-steps-with-celery.html">Celery结果存储和通信代理详解</a></li>
</ul>
</blockquote>
<p>celery backend：结果存储<br>celery broker：通信代理</p>
<h5 id="AsyncTask（javascript）"><a href="#AsyncTask（javascript）" class="headerlink" title="AsyncTask（javascript）"></a>AsyncTask（javascript）</h5><h6 id="async和await（javascript）"><a href="#async和await（javascript）" class="headerlink" title="async和await（javascript）"></a>async和await（javascript）</h6><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/MrWangJB/article/details/107881183">javascript async和await详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/codebay118/article/details/72596951">javascript async和await解决地狱回调</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lgno2/article/details/109446348">javascript await必须在async函数中使用</a></li>
</ul>
</blockquote>
<h6 id="Promise（javascript）"><a href="#Promise（javascript）" class="headerlink" title="Promise（javascript）"></a>Promise（javascript）</h6><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yes1983/article/details/83629647">javascript Promise入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_53993283/article/details/119945800">javascript Promise详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21980517/article/details/103908747">javascript Promise链式调用</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42681555/article/details/121974050">javascript Promise中then使用详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44776206/article/details/109402410">javascript Promise中catch使用详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38211541/article/details/106261991">javascript Promise中finally使用详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32644987/article/details/117842230">javascript Promise手写实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sunshinessx/article/details/88666179">javascript Promise和Rxjs对比</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39341415/article/details/121716810">javascript Promise和axios</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lingliu0824/article/details/108547842">javascript axios请求的数据格式</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/github_39319000/article/details/89472033">javascript箭头函数的返回值</a></li>
</ul>
</blockquote>
<h3 id="ScheduleTask"><a href="#ScheduleTask" class="headerlink" title="ScheduleTask"></a>ScheduleTask</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lijianqingfeng/article/details/112465288">Timer与ExecutorService对比入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37113604/article/details/89429986">Timer与ExecutorService对比详解</a></li>
</ul>
</blockquote>
<h4 id="ScheduledFuture"><a href="#ScheduledFuture" class="headerlink" title="ScheduledFuture"></a>ScheduledFuture</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013851082/article/details/70175394">ScheduledFuture详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/a355586533/article/details/78455788">RunnableScheduledFuture详解</a></li>
</ul>
</blockquote>
<h4 id="ScheduledFutureTask"><a href="#ScheduledFutureTask" class="headerlink" title="ScheduledFutureTask"></a>ScheduledFutureTask</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_50518271/article/details/119087739">ScheduledFutureTask详解</a></li>
</ul>
</blockquote>
<h2 id="Question-3"><a href="#Question-3" class="headerlink" title="Question"></a>Question</h2><h3 id="FutureTask为什么支持传递给线程"><a href="#FutureTask为什么支持传递给线程" class="headerlink" title="FutureTask为什么支持传递给线程"></a>FutureTask为什么支持传递给线程</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33591903/article/details/108422098">FutureTask为什么支持传递给线程</a></li>
</ul>
</blockquote>
<h1 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h1><h2 id="Basic-7"><a href="#Basic-7" class="headerlink" title="Basic"></a>Basic</h2><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/tongdanping/article/details/79604637">Executor框架入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40093255/article/details/116990431">Executor框架详解</a></li>
</ul>
</blockquote>
<h3 id="线程池的创建方式"><a href="#线程池的创建方式" class="headerlink" title="线程池的创建方式"></a>线程池的创建方式</h3><ul>
<li>使用Executors快速创建</li>
<li>使用ExecutorService手动创建</li>
</ul>
<h3 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/riemann_/article/details/104704197">线程池的核心参数</a></li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>corePoolSize：核心线程数</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程保活时间大小</li>
<li>unit：线程保活时间单位</li>
<li>workQueue：工作队列</li>
<li>threadFactory：线程工厂</li>
<li>handler：任务饱和策略处理器</li>
</ul>
<h3 id="线程池的提交策略"><a href="#线程池的提交策略" class="headerlink" title="线程池的提交策略"></a>线程池的提交策略</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/chzphoenix/article/details/78968075">线程池的提交策略</a></li>
</ul>
</blockquote>
<ul>
<li><code>poolSize &lt; corePoolSize</code>时增加线程</li>
<li><code>poolSize = corePoolSize</code>时放入队列</li>
<li>队列满了之后再增加线程</li>
<li>线程达到<code>maximumPoolSize</code>后执行RejectedExecutionHandler</li>
<li>根据RejectedExecutionHandler指定的拒绝策略来处理新的任务</li>
</ul>
<h3 id="线程池的饱和策略"><a href="#线程池的饱和策略" class="headerlink" title="线程池的饱和策略"></a>线程池的饱和策略</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/jgteng/article/details/54411423">线程池的饱和策略</a></li>
</ul>
</blockquote>
<ul>
<li>AbortPolicy：丢弃任务并且抛出RejectedExecutionException异常（默认策略）</li>
<li>DiscardPolicy：丢弃任务但不抛出异常</li>
<li>DiscardOldestPolicy：丢弃最老的（队列头部）任务</li>
<li>CallerRunsPolicy：在提交的线程中直接执行任务</li>
</ul>
<h3 id="线程池的提交方式"><a href="#线程池的提交方式" class="headerlink" title="线程池的提交方式"></a>线程池的提交方式</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/whiteBearClimb/article/details/113249833">线程池的提交方式</a></li>
</ul>
</blockquote>
<ul>
<li>使用submit方法提交（普通任务有返回值时使用）</li>
<li>使用execute方法提交（普通任务无返回值时使用）</li>
<li>使用schedule方法提交（延时任务和定时任务时使用）</li>
</ul>
<h4 id="submit和execute的区别"><a href="#submit和execute的区别" class="headerlink" title="submit和execute的区别"></a>submit和execute的区别</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qing040513/article/details/111667627">submit和execute的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43901882/article/details/106017061">submit和execute的异常处理区别</a></li>
</ul>
</blockquote>
<ul>
<li>execute只支持Runnable，submit可以支持Runnable和Callable</li>
<li>execute没有返回值，submit有返回值</li>
<li>execute有异常会直接打印，submit在Future.get的时候才会打印异常</li>
</ul>
<h3 id="线程池的异常捕获"><a href="#线程池的异常捕获" class="headerlink" title="线程池的异常捕获"></a>线程池的异常捕获</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/feiying0canglang/article/details/121093876">线程异常之全局捕获</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/silyvin/article/details/80025165">线程池异常之异常捕获入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_20009015/article/details/100569976">线程池异常之异常捕获进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45076180/article/details/114552567">线程池异常之异常捕获详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/LiZhen314/article/details/119609565">线程池异常之线程异常了线程池会怎么处理</a></li>
</ul>
</blockquote>
<ul>
<li>execute方式提交时<ul>
<li>在方法内部捕获异常并处理</li>
<li>在ThreadFactory里使用Thread.setUncaughtExceptionHandler拦截处理</li>
<li>在ThreadPoolExecutor.afterExecute里面处理</li>
</ul>
</li>
<li>submit方式提交时<ul>
<li>在方法内部捕获异常并处理</li>
<li>调用Future.get的时候捕获异常并处理</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：线程池里面的某个线程异常了，线程池会移除这个线程并创建一个新的线程</p>
</blockquote>
<h3 id="线程池的关闭方式"><a href="#线程池的关闭方式" class="headerlink" title="线程池的关闭方式"></a>线程池的关闭方式</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47872288/article/details/124225574">线程池的关闭方式入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zlp1992/article/details/104197515">线程池的关闭方式进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36691683/article/details/84856516">线程池的关闭方式详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/LiZhen314/article/details/119948776">线程池需要关闭吗</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Hellowenpan/article/details/119960517">JVM安全退出之关闭的时候到底会不会等待线程池线程任务执行完毕</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wmq880204/article/details/115408498">JVM安全退出之如何优雅的关闭线程池</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Dongguabai/article/details/106309527">JVM安全退出之如何优雅的关闭java服务</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44902907/article/details/105055041">JVM安全退出之如何优雅的释放连接</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36689178/article/details/104705606">JVM安全退出之如何优雅的释放资源</a></li>
</ul>
</blockquote>
<ul>
<li>shutdown：线程池的状态变为SHUTDOWN，不再接受新任务了，但是队列里的任务会执行完毕</li>
<li>shutdownNow：线程池的状态变为STOP，会终止当前正在运行的任务，并停止处理排队的任务，返回等待执行的任务列表</li>
</ul>
<h4 id="shutdown和shutdownNow的区别"><a href="#shutdown和shutdownNow的区别" class="headerlink" title="shutdown和shutdownNow的区别"></a>shutdown和shutdownNow的区别</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaojin21cen/article/details/81778651">shutdown和shutdownNow的区别</a></li>
</ul>
</blockquote>
<h2 id="Usage-2"><a href="#Usage-2" class="headerlink" title="Usage"></a>Usage</h2><h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_47770103/article/details/117562941">Timer入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44667083/article/details/114385096">Timer详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21539375/article/details/124049553">定时器实现方案入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42956653/article/details/126237909">定时器实现方案进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_52622200/article/details/123381196">定时器实现方案详解</a></li>
</ul>
</blockquote>
<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u022812849/article/details/109097171">Executors入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Think_and_work/article/details/123667645">Executors详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31439011/article/details/100824461">Executors方法选择</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40096897/article/details/121660747">Executors方法区别</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/asd136912/article/details/87908629">Executors问题说明</a></li>
</ul>
</blockquote>
<h4 id="快速创建线程池的方法"><a href="#快速创建线程池的方法" class="headerlink" title="快速创建线程池的方法"></a>快速创建线程池的方法</h4><p>快速创建线程池的本质是ThreadPoolExecutor和ScheduledThreadPoolExecutor的快速构造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<h5 id="Executors-newSingleThreadExecutor"><a href="#Executors-newSingleThreadExecutor" class="headerlink" title="Executors.newSingleThreadExecutor"></a>Executors.newSingleThreadExecutor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程数固定（一个），队列容量无限大，适合需要串行执行的任务</p>
<h5 id="Executors-newFixedThreadPool"><a href="#Executors-newFixedThreadPool" class="headerlink" title="Executors.newFixedThreadPool"></a>Executors.newFixedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程数固定（多个），队列容量无限大，线程数量固定且不回收线程，任务需要排队，适合耗时长的少量任务</p>
<h5 id="Executors-newCachedThreadPool"><a href="#Executors-newCachedThreadPool" class="headerlink" title="Executors.newCachedThreadPool"></a>Executors.newCachedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程数无限大，队列容量固定（0个），线程数量充足且有保活时间，任务不用排队，适合耗时短的大量任务</p>
<h5 id="Executors-newScheduledThreadPool"><a href="#Executors-newScheduledThreadPool" class="headerlink" title="Executors.newScheduledThreadPool"></a>Executors.newScheduledThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程数无限大，队列容量无限大，支持延时和定时任务</p>
<h5 id="Executors-newSingleThreadScheduledExecutor"><a href="#Executors-newSingleThreadScheduledExecutor" class="headerlink" title="Executors.newSingleThreadScheduledExecutor"></a>Executors.newSingleThreadScheduledExecutor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newSingleThreadScheduledExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DelegatedScheduledExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程数无限大，队列容量无限大，支持延时和定时任务</p>
<h5 id="Executors-newWorkStealingPool"><a href="#Executors-newWorkStealingPool" class="headerlink" title="Executors.newWorkStealingPool"></a>Executors.newWorkStealingPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span></span><br><span class="line">            (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">             <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ForkJoinPool(int parallelism,</span><br><span class="line">                        ForkJoinWorkerThreadFactory factory,</span><br><span class="line">                        UncaughtExceptionHandler handler,</span><br><span class="line">                        boolean asyncMode) &#123;</span><br><span class="line">        this(checkParallelism(parallelism),</span><br><span class="line">             checkFactory(factory),</span><br><span class="line">             handler,</span><br><span class="line">             asyncMode ? FIFO_QUEUE : LIFO_QUEUE,</span><br><span class="line">             &quot;ForkJoinPool-&quot; + nextPoolId() + &quot;-worker-&quot;);</span><br><span class="line">        checkPermission();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ForkJoinPool</span><span class="params">(<span class="type">int</span> parallelism,</span></span><br><span class="line"><span class="params">                         ForkJoinWorkerThreadFactory factory,</span></span><br><span class="line"><span class="params">                         UncaughtExceptionHandler handler,</span></span><br><span class="line"><span class="params">                         <span class="type">int</span> mode,</span></span><br><span class="line"><span class="params">                         String workerNamePrefix)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">        <span class="built_in">this</span>.ueh = handler;</span><br><span class="line">        <span class="built_in">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">        <span class="type">long</span> <span class="variable">np</span> <span class="operator">=</span> (<span class="type">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">        <span class="built_in">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速创建线程池的问题"><a href="#快速创建线程池的问题" class="headerlink" title="快速创建线程池的问题"></a>快速创建线程池的问题</h4><ul>
<li>Executors.newSingleThreadExecutor：队列容量无限大，容易导致内存耗尽引发OOM</li>
<li>Executors.newFixedThreadPool：队列容量无限大，容易导致内存耗尽引发OOM</li>
<li>Executors.newCachedThreadPool：线程数量无限大，容易导致内存耗尽引发OOM</li>
<li>Executors.newScheduledThreadPool：线程数量无限大，容易导致内存耗尽引发OOM</li>
</ul>
<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/suifeng3051/article/details/49443835">ExecutorService详解</a></li>
</ul>
</blockquote>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xu_yong_lin/article/details/117521773">ThreadPoolExecutor详解</a></li>
</ul>
</blockquote>
<h5 id="State-3"><a href="#State-3" class="headerlink" title="State"></a>State</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/AlbenXie/article/details/84702331">ThreadPoolExecutor的状态详解</a></li>
</ul>
</blockquote>
<p>RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED</p>
<ul>
<li>RUNNING（运行）：创建线程池后的初始状态</li>
<li>SHUTDOWN（关闭）：执行shutdown()后，不接收新任务，但会处理已排队的任务和当前任务</li>
<li>STOP（停止）：执行shutdownNow()后，不接收新任务，不处理已排队的任务并中断当前任务</li>
<li>TIDYING（清扫）：线程池中的任务队列为空后</li>
<li>TERMINATED（终结）：执行terminated()后</li>
</ul>
<h3 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22076345/article/details/115404421">ScheduledExecutorService详解</a></li>
</ul>
</blockquote>
<h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/huangzhilin2015/article/details/116246043">ScheduledThreadPoolExecutor详解</a></li>
</ul>
</blockquote>
<h3 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuyu973971883/article/details/108055564">CompletionService详解</a></li>
</ul>
</blockquote>
<h4 id="ExecutorCompletionService"><a href="#ExecutorCompletionService" class="headerlink" title="ExecutorCompletionService"></a>ExecutorCompletionService</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012060033/article/details/129720991">ExecutorCompletionService详解</a></li>
</ul>
</blockquote>
<h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41432730/article/details/121308729">ForkJoinPool详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bof_jangle/article/details/108297499">ForkJoinPool异常处理</a></li>
</ul>
</blockquote>
<h2 id="Question-4"><a href="#Question-4" class="headerlink" title="Question"></a>Question</h2><h3 id="线程池是如何保证核心线程不被销毁的"><a href="#线程池是如何保证核心线程不被销毁的" class="headerlink" title="线程池是如何保证核心线程不被销毁的"></a>线程池是如何保证核心线程不被销毁的</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/smile_from_2015/article/details/105259789">线程池是如何保证核心线程不被销毁的</a></li>
</ul>
</blockquote>
<h1 id="Cooperation"><a href="#Cooperation" class="headerlink" title="Cooperation"></a>Cooperation</h1><h2 id="Communication"><a href="#Communication" class="headerlink" title="Communication"></a>Communication</h2><p>线程间通信（Communication）是线程间协作（Cooperation）的基础</p>
<h3 id="线程通信机制详解"><a href="#线程通信机制详解" class="headerlink" title="线程通信机制详解"></a>线程通信机制详解</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xianyu_x/article/details/127419036">线程通信机制详解</a></li>
</ul>
</blockquote>
<ul>
<li>Object：wait和notify、notifyAll</li>
<li>Condition：await和signal、signalAll</li>
<li>LockSupport：park和unpark</li>
</ul>
<blockquote>
<p>ps：Thread.join是在Thread对象上手动wait和自动notify的线程通信快捷方式</p>
</blockquote>
<h4 id="Object的wait和notify"><a href="#Object的wait和notify" class="headerlink" title="Object的wait和notify"></a>Object的wait和notify</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lizhengze1117/article/details/106342359">Object的wait和notify详解</a></li>
</ul>
</blockquote>
<h4 id="Condition的await和signal"><a href="#Condition的await和signal" class="headerlink" title="Condition的await和signal"></a>Condition的await和signal</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38293564/article/details/80554516">Condition的await和signal详解</a></li>
</ul>
</blockquote>
<h4 id="LockSupport的park和unpark"><a href="#LockSupport的park和unpark" class="headerlink" title="LockSupport的park和unpark"></a>LockSupport的park和unpark</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_63566550/article/details/125712631">LockSupport的park和unpark详解</a></li>
</ul>
</blockquote>
<h3 id="线程通信机制比较"><a href="#线程通信机制比较" class="headerlink" title="线程通信机制比较"></a>线程通信机制比较</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44245828/article/details/109410117">线程通信机制比较</a></li>
</ul>
</blockquote>
<p>Object只有一个等待队列，Condition可以有多个等待队列</p>
<h2 id="Collaboration"><a href="#Collaboration" class="headerlink" title="Collaboration"></a>Collaboration</h2><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41727218/article/details/88376773">互斥和同步详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/cyan20115/article/details/106549012">Mutex、Semaphore详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44808472/article/details/126315732">Semaphore、CountDownLatch、CyclicBarrier详解</a></li>
</ul>
</blockquote>
<ul>
<li>Mutex解决互斥问题</li>
<li>Semaphore解决同步问题</li>
<li>synchronized和Lock解决互斥和同步的问题</li>
<li>CountDownLatch解决计数器的问题</li>
<li>CyclicBarrier解决同步点的问题</li>
</ul>
<h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_29952235/article/details/114308860">Mutex详解</a></li>
</ul>
</blockquote>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/warybee/article/details/111316932">Semaphore详解</a></li>
</ul>
</blockquote>
<h4 id="Semaphore和Mutex的区别"><a href="#Semaphore和Mutex的区别" class="headerlink" title="Semaphore和Mutex的区别"></a>Semaphore和Mutex的区别</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shangdawei/p/3520102.html">Semaphore和Mutex的区别详解</a></li>
</ul>
</blockquote>
<p>Semaphore：解决同步问题，可以他人释放资源<br>Mutex：解决互斥问题，且只能自己释放资源</p>
<h4 id="Semaphore和Lock的区别"><a href="#Semaphore和Lock的区别" class="headerlink" title="Semaphore和Lock的区别"></a>Semaphore和Lock的区别</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/gengyiping18/article/details/60142300">Semaphore和Lock的区别</a></li>
</ul>
</blockquote>
<p>Semaphore：释放许可前不要求先获取许可，并且任何人都能释放许可<br>Lock：解锁前必须先持有这个锁，且只能自己释放锁</p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><h4 id="CountDownLatch和Semaphore的区别"><a href="#CountDownLatch和Semaphore的区别" class="headerlink" title="CountDownLatch和Semaphore的区别"></a>CountDownLatch和Semaphore的区别</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_70734549/article/details/125982906">CountDownLatch和Semaphore的区别</a></li>
</ul>
</blockquote>
<ul>
<li>CountDownLatch：计数器，只能递减数量（count），归零后通知等待的线程继续运行</li>
<li>Semaphore：信号量，可以释放许可（permit），归还许可给其他线程使用</li>
</ul>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><h4 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/dgh112233/article/details/104649531">CyclicBarrier和CountDownLatch的区别</a></li>
</ul>
</blockquote>
<ul>
<li>CyclicBarrier：屏障栏，可以重复使用，归零后通知等待的<code>所有</code>线程继续运行</li>
<li>CountDownLatch：计数器，只能使用一次，归零后通知等待的<code>监听</code>线程继续运行</li>
</ul>
<h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_58554082/article/details/118254227">Exchanger详解</a></li>
</ul>
</blockquote>
<h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42569136/article/details/122888783">java如何实现阻塞等待功能</a></li>
</ul>
</blockquote>
<ul>
<li>while + check + sleep</li>
<li>wait + notify</li>
<li>BlockingQueue</li>
</ul>
<h1 id="Utils"><a href="#Utils" class="headerlink" title="Utils"></a>Utils</h1><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27828675/article/details/114068266">并发工具入门</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ruan_luqingnian/article/details/118529835">并发工具进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/swadian2008/article/details/127028509">并发工具详解</a></li>
</ul>
</blockquote>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h2 id="Apache-Commons"><a href="#Apache-Commons" class="headerlink" title="Apache Commons"></a>Apache Commons</h2><h2 id="Google-Guava"><a href="#Google-Guava" class="headerlink" title="Google Guava"></a>Google Guava</h2>
    </div>

    
    
    
        <div class="reward-container">
  <div>只想买包辣条</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/pay/wechatpay.jpeg" alt="朱继鹏 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># + java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/07/01/lang/lang-1-java/junior/java-4-exception/" rel="prev" title="exception">
      <i class="fa fa-chevron-left"></i> exception
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/07/01/lang/lang-1-java/junior/java-6-io/" rel="next" title="io">
      io <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Thread"><span class="nav-number">1.</span> <span class="nav-text">Thread</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic"><span class="nav-number">1.1.</span> <span class="nav-text">Basic</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Create"><span class="nav-number">1.1.1.</span> <span class="nav-text">Create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Priority"><span class="nav-number">1.1.2.</span> <span class="nav-text">Priority</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Daemon"><span class="nav-number">1.1.3.</span> <span class="nav-text">Daemon</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#State"><span class="nav-number">1.1.4.</span> <span class="nav-text">State</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Resource"><span class="nav-number">1.1.5.</span> <span class="nav-text">Resource</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Control"><span class="nav-number">1.1.6.</span> <span class="nav-text">Control</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interrupt"><span class="nav-number">1.1.7.</span> <span class="nav-text">Interrupt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Terminate"><span class="nav-number">1.1.8.</span> <span class="nav-text">Terminate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Deprecated"><span class="nav-number">1.1.9.</span> <span class="nav-text">Deprecated</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Question"><span class="nav-number">1.2.</span> <span class="nav-text">Question</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.1.</span> <span class="nav-text">线程和进程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Runnable%E5%92%8CCallable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.2.</span> <span class="nav-text">Runnable和Callable的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E7%9A%84start%E5%92%8Crun%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.3.</span> <span class="nav-text">Thread的start和run的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E7%9A%84start%E8%83%BD%E8%B0%83%E7%94%A8%E5%A4%9A%E6%AC%A1%E5%90%97"><span class="nav-number">1.2.4.</span> <span class="nav-text">Thread的start能调用多次吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E7%9A%84sleep%E5%92%8Cyield%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.5.</span> <span class="nav-text">Thread的sleep和yield的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E7%9A%84sleep%E5%92%8Cjoin%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.6.</span> <span class="nav-text">Thread的sleep和join的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E7%9A%84join%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.7.</span> <span class="nav-text">Thread的join和wait的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">2.</span> <span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-1"><span class="nav-number">2.1.</span> <span class="nav-text">Basic</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Scene"><span class="nav-number">2.1.1.</span> <span class="nav-text">Scene</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leak"><span class="nav-number">2.1.2.</span> <span class="nav-text">Leak</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Inherit"><span class="nav-number">2.1.3.</span> <span class="nav-text">Inherit</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Question-1"><span class="nav-number">2.2.</span> <span class="nav-text">Question</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">2.2.1.</span> <span class="nav-text">ThreadLocal为什么会内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalMap%E7%9A%84key%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="nav-number">2.2.2.</span> <span class="nav-text">ThreadLocalMap的key为什么是弱引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalMap%E7%9A%84value%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="nav-number">2.2.3.</span> <span class="nav-text">ThreadLocalMap的value为什么是强引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8Thread%E5%81%9Akey"><span class="nav-number">2.2.4.</span> <span class="nav-text">ThreadLocalMap为什么不用Thread做key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AE%9A%E4%B9%89%E6%88%90%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">2.2.5.</span> <span class="nav-text">ThreadLocal为什么要定义成静态变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.2.6.</span> <span class="nav-text">ThreadLocal和局部变量的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Safe"><span class="nav-number">3.</span> <span class="nav-text">Safe</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-2"><span class="nav-number">3.1.</span> <span class="nav-text">Basic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Advanced"><span class="nav-number">3.2.</span> <span class="nav-text">Advanced</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="nav-number">3.2.1.</span> <span class="nav-text">线程安全之基本原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="nav-number">3.2.2.</span> <span class="nav-text">线程安全之实现方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%AE%89%E5%85%A8"><span class="nav-number">3.2.3.</span> <span class="nav-text">线程安全之对象安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AE%89%E5%85%A8"><span class="nav-number">3.2.4.</span> <span class="nav-text">线程安全之变量安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8"><span class="nav-number">3.2.5.</span> <span class="nav-text">线程安全之内存安全</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lock"><span class="nav-number">4.</span> <span class="nav-text">Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-3"><span class="nav-number">4.1.</span> <span class="nav-text">Basic</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.1.1.</span> <span class="nav-text">锁的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">并发操作的控制方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BA%92%E6%96%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">并发操作的互斥机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">4.1.2.</span> <span class="nav-text">锁的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">锁的类型分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E7%B1%BB"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">锁的实现分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E8%8C%83%E5%9B%B4%E5%88%86%E7%B1%BB"><span class="nav-number">4.1.2.3.</span> <span class="nav-text">锁的范围分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">4.1.3.</span> <span class="nav-text">锁的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">4.1.4.</span> <span class="nav-text">锁的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.1.5.</span> <span class="nav-text">锁的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DeadLock%EF%BC%88%E6%AD%BB%E9%94%81%EF%BC%89"><span class="nav-number">4.1.5.1.</span> <span class="nav-text">DeadLock（死锁）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Starvation%EF%BC%88%E9%A5%A5%E9%A5%BF%EF%BC%89"><span class="nav-number">4.1.5.2.</span> <span class="nav-text">Starvation（饥饿）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Usage"><span class="nav-number">4.2.</span> <span class="nav-text">Usage</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized"><span class="nav-number">4.2.1.</span> <span class="nav-text">synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E9%94%81%E5%8E%9F%E7%90%86"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">synchronized锁原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E9%94%81%E8%86%A8%E8%83%80"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">synchronized锁膨胀</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E9%94%81%E6%B6%88%E9%99%A4"><span class="nav-number">4.2.1.3.</span> <span class="nav-text">synchronized锁消除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E9%94%81%E7%B2%97%E5%8C%96"><span class="nav-number">4.2.1.4.</span> <span class="nav-text">synchronized锁粗化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E9%94%81%E8%87%AA%E6%97%8B"><span class="nav-number">4.2.1.5.</span> <span class="nav-text">synchronized锁自旋</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">4.2.2.</span> <span class="nav-text">ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lock-lock-%E5%86%99%E5%9C%A8-try-%E4%BB%A3%E7%A0%81%E5%9D%97%E5%86%85%E9%83%A8%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">lock.lock() 写在 try 代码块内部行吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E7%9A%84unlock"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">如何安全的unlock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantReadWriteLock"><span class="nav-number">4.2.3.</span> <span class="nav-text">ReentrantReadWriteLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Atomic"><span class="nav-number">4.2.4.</span> <span class="nav-text">Atomic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS"><span class="nav-number">4.2.5.</span> <span class="nav-text">CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OptimisticLock%EF%BC%88%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%89"><span class="nav-number">4.2.5.1.</span> <span class="nav-text">OptimisticLock（乐观锁）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpinLock%EF%BC%88%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%89"><span class="nav-number">4.2.5.2.</span> <span class="nav-text">SpinLock（自旋锁）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS"><span class="nav-number">4.2.6.</span> <span class="nav-text">AQS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LockSupport"><span class="nav-number">4.2.7.</span> <span class="nav-text">LockSupport</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Question-2"><span class="nav-number">4.3.</span> <span class="nav-text">Question</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized%E5%92%8Cvolatile%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.1.</span> <span class="nav-text">synchronized和volatile的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.2.</span> <span class="nav-text">synchronized和Lock的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Task"><span class="nav-number">5.</span> <span class="nav-text">Task</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-4"><span class="nav-number">5.1.</span> <span class="nav-text">Basic</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.1.</span> <span class="nav-text">任务的运行方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">并发和并行的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.1.2.</span> <span class="nav-text">集群和分布式的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.1.3.</span> <span class="nav-text">同步和异步的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.2.</span> <span class="nav-text">任务的调度方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E8%B0%83%E5%BA%A6%EF%BC%88normal%EF%BC%89"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">普通调度（normal）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E6%97%B6%E8%B0%83%E5%BA%A6%EF%BC%88delay%EF%BC%89"><span class="nav-number">5.1.2.2.</span> <span class="nav-text">延时调度（delay）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%EF%BC%88timing%EF%BC%89"><span class="nav-number">5.1.2.3.</span> <span class="nav-text">定时调度（timing）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Usage-1"><span class="nav-number">5.2.</span> <span class="nav-text">Usage</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SyncTask"><span class="nav-number">5.2.1.</span> <span class="nav-text">SyncTask</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Future"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">Future</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FutureTask"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">FutureTask</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Basic-5"><span class="nav-number">5.2.1.2.1.</span> <span class="nav-text">Basic</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#State-1"><span class="nav-number">5.2.1.2.2.</span> <span class="nav-text">State</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Exception"><span class="nav-number">5.2.1.2.3.</span> <span class="nav-text">Exception</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Cancel"><span class="nav-number">5.2.1.2.4.</span> <span class="nav-text">Cancel</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Timeout"><span class="nav-number">5.2.1.2.5.</span> <span class="nav-text">Timeout</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AsyncTask"><span class="nav-number">5.2.2.</span> <span class="nav-text">AsyncTask</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CompletionStage"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">CompletionStage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CompletableFuture"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">CompletableFuture</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Basic-6"><span class="nav-number">5.2.2.2.1.</span> <span class="nav-text">Basic</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%EF%BC%88createTask%EF%BC%89"><span class="nav-number">5.2.2.2.1.1.</span> <span class="nav-text">创建任务（createTask）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C%EF%BC%88handleResult%EF%BC%89"><span class="nav-number">5.2.2.2.1.2.</span> <span class="nav-text">处理结果（handleResult）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%BB%93%E6%9E%9C%EF%BC%88setResult%EF%BC%89"><span class="nav-number">5.2.2.2.1.3.</span> <span class="nav-text">设置结果（setResult）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%9C%EF%BC%88getResult%EF%BC%89"><span class="nav-number">5.2.2.2.1.4.</span> <span class="nav-text">获取结果（getResult）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%8A%B6%E6%80%81%EF%BC%88checkState%EF%BC%89"><span class="nav-number">5.2.2.2.1.5.</span> <span class="nav-text">检查状态（checkState）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BC%96%E6%8E%92%E4%BB%BB%E5%8A%A1%EF%BC%88Choreography%EF%BC%89"><span class="nav-number">5.2.2.2.1.6.</span> <span class="nav-text">编排任务（Choreography）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#State-2"><span class="nav-number">5.2.2.2.2.</span> <span class="nav-text">State</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Exception-1"><span class="nav-number">5.2.2.2.3.</span> <span class="nav-text">Exception</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Cancel-1"><span class="nav-number">5.2.2.2.4.</span> <span class="nav-text">Cancel</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Timeout-1"><span class="nav-number">5.2.2.2.5.</span> <span class="nav-text">Timeout</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#More"><span class="nav-number">5.2.2.3.</span> <span class="nav-text">More</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AsyncTask%EF%BC%88python%EF%BC%89"><span class="nav-number">5.2.2.3.1.</span> <span class="nav-text">AsyncTask（python）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#async%E5%92%8Cawait%EF%BC%88python%EF%BC%89"><span class="nav-number">5.2.2.3.1.1.</span> <span class="nav-text">async和await（python）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#coroutine%EF%BC%88python%EF%BC%89"><span class="nav-number">5.2.2.3.1.2.</span> <span class="nav-text">coroutine（python）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#asyncio%EF%BC%88python%EF%BC%89"><span class="nav-number">5.2.2.3.1.3.</span> <span class="nav-text">asyncio（python）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#aiohttp%EF%BC%88python%EF%BC%89"><span class="nav-number">5.2.2.3.1.4.</span> <span class="nav-text">aiohttp（python）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Tornado%EF%BC%88python%EF%BC%89"><span class="nav-number">5.2.2.3.1.5.</span> <span class="nav-text">Tornado（python）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Celery%EF%BC%88python%EF%BC%89"><span class="nav-number">5.2.2.3.1.6.</span> <span class="nav-text">Celery（python）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AsyncTask%EF%BC%88javascript%EF%BC%89"><span class="nav-number">5.2.2.3.2.</span> <span class="nav-text">AsyncTask（javascript）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#async%E5%92%8Cawait%EF%BC%88javascript%EF%BC%89"><span class="nav-number">5.2.2.3.2.1.</span> <span class="nav-text">async和await（javascript）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Promise%EF%BC%88javascript%EF%BC%89"><span class="nav-number">5.2.2.3.2.2.</span> <span class="nav-text">Promise（javascript）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ScheduleTask"><span class="nav-number">5.2.3.</span> <span class="nav-text">ScheduleTask</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ScheduledFuture"><span class="nav-number">5.2.3.1.</span> <span class="nav-text">ScheduledFuture</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ScheduledFutureTask"><span class="nav-number">5.2.3.2.</span> <span class="nav-text">ScheduledFutureTask</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Question-3"><span class="nav-number">5.3.</span> <span class="nav-text">Question</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FutureTask%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%AF%E6%8C%81%E4%BC%A0%E9%80%92%E7%BB%99%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.3.1.</span> <span class="nav-text">FutureTask为什么支持传递给线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Executor"><span class="nav-number">6.</span> <span class="nav-text">Executor</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-7"><span class="nav-number">6.1.</span> <span class="nav-text">Basic</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">6.1.1.</span> <span class="nav-text">线程池的创建方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="nav-number">6.1.2.</span> <span class="nav-text">线程池的核心参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8F%90%E4%BA%A4%E7%AD%96%E7%95%A5"><span class="nav-number">6.1.3.</span> <span class="nav-text">线程池的提交策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5"><span class="nav-number">6.1.4.</span> <span class="nav-text">线程池的饱和策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F"><span class="nav-number">6.1.5.</span> <span class="nav-text">线程池的提交方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#submit%E5%92%8Cexecute%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.1.5.1.</span> <span class="nav-text">submit和execute的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7"><span class="nav-number">6.1.6.</span> <span class="nav-text">线程池的异常捕获</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%85%B3%E9%97%AD%E6%96%B9%E5%BC%8F"><span class="nav-number">6.1.7.</span> <span class="nav-text">线程池的关闭方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#shutdown%E5%92%8CshutdownNow%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.1.7.1.</span> <span class="nav-text">shutdown和shutdownNow的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Usage-2"><span class="nav-number">6.2.</span> <span class="nav-text">Usage</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Timer"><span class="nav-number">6.2.1.</span> <span class="nav-text">Timer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executors"><span class="nav-number">6.2.2.</span> <span class="nav-text">Executors</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">6.2.2.1.</span> <span class="nav-text">快速创建线程池的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Executors-newSingleThreadExecutor"><span class="nav-number">6.2.2.1.1.</span> <span class="nav-text">Executors.newSingleThreadExecutor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Executors-newFixedThreadPool"><span class="nav-number">6.2.2.1.2.</span> <span class="nav-text">Executors.newFixedThreadPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Executors-newCachedThreadPool"><span class="nav-number">6.2.2.1.3.</span> <span class="nav-text">Executors.newCachedThreadPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Executors-newScheduledThreadPool"><span class="nav-number">6.2.2.1.4.</span> <span class="nav-text">Executors.newScheduledThreadPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Executors-newSingleThreadScheduledExecutor"><span class="nav-number">6.2.2.1.5.</span> <span class="nav-text">Executors.newSingleThreadScheduledExecutor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Executors-newWorkStealingPool"><span class="nav-number">6.2.2.1.6.</span> <span class="nav-text">Executors.newWorkStealingPool</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.2.2.</span> <span class="nav-text">快速创建线程池的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ExecutorService"><span class="nav-number">6.2.3.</span> <span class="nav-text">ExecutorService</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">6.2.3.1.</span> <span class="nav-text">ThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#State-3"><span class="nav-number">6.2.3.1.1.</span> <span class="nav-text">State</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ScheduledExecutorService"><span class="nav-number">6.2.4.</span> <span class="nav-text">ScheduledExecutorService</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ScheduledThreadPoolExecutor"><span class="nav-number">6.2.4.1.</span> <span class="nav-text">ScheduledThreadPoolExecutor</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CompletionService"><span class="nav-number">6.2.5.</span> <span class="nav-text">CompletionService</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ExecutorCompletionService"><span class="nav-number">6.2.5.1.</span> <span class="nav-text">ExecutorCompletionService</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ForkJoinPool"><span class="nav-number">6.2.6.</span> <span class="nav-text">ForkJoinPool</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Question-4"><span class="nav-number">6.3.</span> <span class="nav-text">Question</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E4%B8%8D%E8%A2%AB%E9%94%80%E6%AF%81%E7%9A%84"><span class="nav-number">6.3.1.</span> <span class="nav-text">线程池是如何保证核心线程不被销毁的</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Cooperation"><span class="nav-number">7.</span> <span class="nav-text">Cooperation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Communication"><span class="nav-number">7.1.</span> <span class="nav-text">Communication</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="nav-number">7.1.1.</span> <span class="nav-text">线程通信机制详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Object%E7%9A%84wait%E5%92%8Cnotify"><span class="nav-number">7.1.1.1.</span> <span class="nav-text">Object的wait和notify</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition%E7%9A%84await%E5%92%8Csignal"><span class="nav-number">7.1.1.2.</span> <span class="nav-text">Condition的await和signal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LockSupport%E7%9A%84park%E5%92%8Cunpark"><span class="nav-number">7.1.1.3.</span> <span class="nav-text">LockSupport的park和unpark</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E6%AF%94%E8%BE%83"><span class="nav-number">7.1.2.</span> <span class="nav-text">线程通信机制比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collaboration"><span class="nav-number">7.2.</span> <span class="nav-text">Collaboration</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mutex"><span class="nav-number">7.2.1.</span> <span class="nav-text">Mutex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore"><span class="nav-number">7.2.2.</span> <span class="nav-text">Semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphore%E5%92%8CMutex%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.2.2.1.</span> <span class="nav-text">Semaphore和Mutex的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphore%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.2.2.2.</span> <span class="nav-text">Semaphore和Lock的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">7.2.3.</span> <span class="nav-text">CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch%E5%92%8CSemaphore%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.2.3.1.</span> <span class="nav-text">CountDownLatch和Semaphore的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">7.2.4.</span> <span class="nav-text">CyclicBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CyclicBarrier%E5%92%8CCountDownLatch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.2.4.1.</span> <span class="nav-text">CyclicBarrier和CountDownLatch的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exchanger"><span class="nav-number">7.2.5.</span> <span class="nav-text">Exchanger</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Other"><span class="nav-number">8.</span> <span class="nav-text">Other</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Utils"><span class="nav-number">9.</span> <span class="nav-text">Utils</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java"><span class="nav-number">9.1.</span> <span class="nav-text">Java</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Apache-Commons"><span class="nav-number">9.2.</span> <span class="nav-text">Apache Commons</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Google-Guava"><span class="nav-number">9.3.</span> <span class="nav-text">Google Guava</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="朱继鹏"
      src="/images/avatar/zhujipeng.jpg">
  <p class="site-author-name" itemprop="name">朱继鹏</p>
  <div class="site-description" itemprop="description">在全栈的路上狂奔不止</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">101</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jipengzhu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jipengzhu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jipengzhu@qq.com" title="E-Mail → mailto:jipengzhu@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朱继鹏</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
