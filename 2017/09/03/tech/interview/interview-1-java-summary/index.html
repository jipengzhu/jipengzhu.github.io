<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="java面试总结">
<meta property="og:type" content="article">
<meta property="og:title" content="interview-java-summary">
<meta property="og:url" content="http://example.com/2017/09/03/tech/interview/interview-1-java-summary/index.html">
<meta property="og:site_name" content="朱继鹏的博客">
<meta property="og:description" content="java面试总结">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-09-02T17:03:00.000Z">
<meta property="article:modified_time" content="2024-04-05T10:07:17.833Z">
<meta property="article:author" content="朱继鹏">
<meta property="article:tag" content="+ interview">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2017/09/03/tech/interview/interview-1-java-summary/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>interview-java-summary | 朱继鹏的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">朱继鹏的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">天道酬勤，全栈不停</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/09/03/tech/interview/interview-1-java-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar/zhujipeng.jpg">
      <meta itemprop="name" content="朱继鹏">
      <meta itemprop="description" content="在全栈的路上狂奔不止">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朱继鹏的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          interview-java-summary
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-03 01:03:00" itemprop="dateCreated datePublished" datetime="2017-09-03T01:03:00+08:00">2017-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-05 18:07:17" itemprop="dateModified" datetime="2024-04-05T18:07:17+08:00">2024-04-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">+ interview</span></a>
                </span>
            </span>

          
            <div class="post-description">java面试总结</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="java面试重点（概览篇）"><a href="#java面试重点（概览篇）" class="headerlink" title="java面试重点（概览篇）"></a>java面试重点（概览篇）</h1><ul>
<li>Lang</li>
<li>Container</li>
<li>Concurrency</li>
<li>IO</li>
<li>JVM</li>
<li>Spring<ul>
<li>SpringBoot</li>
<li>SpringWeb</li>
<li>SpringData</li>
<li>SpringSecurity</li>
<li>SpringCloud</li>
</ul>
</li>
<li>Mysql</li>
<li>Redis</li>
<li>MQ</li>
<li>Network</li>
<li>Web</li>
<li>Distributed</li>
</ul>
<h1 id="java面试重点（语言篇）"><a href="#java面试重点（语言篇）" class="headerlink" title="java面试重点（语言篇）"></a>java面试重点（语言篇）</h1><h2 id="Lang"><a href="#Lang" class="headerlink" title="Lang"></a>Lang</h2><ul>
<li>字符串</li>
<li>数值</li>
<li>对象</li>
</ul>
<h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><ul>
<li>容器遍历</li>
<li>容器排序</li>
<li>容器空值</li>
<li>容器原理</li>
<li>容器安全</li>
<li>容器扩容</li>
</ul>
<h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h2><ul>
<li>线程基础</li>
<li>线程变量（ThreadLocal）</li>
<li>线程安全（Safe）</li>
<li>线程并发控制（Lock）</li>
<li>任务（Task）</li>
<li>线程池（Executor）</li>
<li>线程通信（wait&#x2F;notify、await&#x2F;signal）</li>
<li>线程协作（Semaphore、CountDownLatch、CyclicBarrier）</li>
</ul>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><ul>
<li>IO基础（BIO、NIO、AIO）</li>
<li>IO体系（流、缓冲区）</li>
<li>IO模型（同步、异步、阻塞、非阻塞）</li>
<li>多路复用（C10K、epoll）</li>
<li>并发模型（Reactor、Proactor）</li>
</ul>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ul>
<li>JVM主要组成</li>
<li>JVM核心功能</li>
<li>JVM运行数据分区</li>
<li>JVM内存分配策略</li>
<li>JVM垃圾数据回收</li>
<li>JVM类（类加载机制、双亲委派机制）</li>
<li>JVM对象（对象生命周期、对象初始化过程、对象内存结构）</li>
<li>JVM问题排查（CPU占用高、内存OOM和泄露、线程死锁）</li>
<li>JMM（三大原则、as-if-serial和happens-before、内存屏障）</li>
</ul>
<h1 id="java面试重点（通用篇）"><a href="#java面试重点（通用篇）" class="headerlink" title="java面试重点（通用篇）"></a>java面试重点（通用篇）</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring-1"><a href="#Spring-1" class="headerlink" title="Spring"></a>Spring</h3><ul>
<li>IOC（注册方法、注入方法、懒加载、循环依赖、Bean的生命周期、IOC容器启动流程）</li>
<li>AOP（使用场景、通知顺序、失效场景）</li>
<li>Proxy（静态代理和动态代理、代理的生成时机）</li>
</ul>
<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><ul>
<li>起步依赖</li>
<li>自动配置</li>
</ul>
<h3 id="SpringWeb"><a href="#SpringWeb" class="headerlink" title="SpringWeb"></a>SpringWeb</h3><ul>
<li>Mvc（流程、Filter和Interceptor、跨域）</li>
<li>Web（幂等、防重复提交）</li>
</ul>
<h3 id="SpringData"><a href="#SpringData" class="headerlink" title="SpringData"></a>SpringData</h3><ul>
<li>Mybatis（分页、缓存）</li>
<li>Transaction（事务失效场景、事务传播级别）</li>
</ul>
<h3 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h3><ul>
<li>单点登录流程（SSO）</li>
<li>扫码登录流程</li>
</ul>
<h3 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h3><ul>
<li>SpringCloud组件</li>
</ul>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><ul>
<li>mysql索引（索引分类、索引失效、B+索引）</li>
<li>mysql事务（四大特性、MVCC、Lock、undo日志、redo日志）</li>
<li>mysql问题（并发操作、读写分离、数据丢失）</li>
<li>mysql性能</li>
<li>mysql架构（主从复制、分表分库）</li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul>
<li>redis数据类型</li>
<li>redis数据结构</li>
<li>redis过期策略（惰性删除、定期删除）</li>
<li>redis淘汰策略（不淘汰、淘汰最先过期的、random、lru、lfu）</li>
<li>redis使用策略（旁路缓存、穿透写入、异步回写）</li>
<li>redis问题（缓存穿透、缓存击穿、缓存雪崩、缓存一致性、数据丢失）</li>
<li>redis性能（为什么很快，单线程、多线程、大key，热key）</li>
<li>redis架构（主从复制、集群、主从、哨兵、分布式）</li>
<li>redis分布式锁（分布式锁、红锁）</li>
</ul>
<h2 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h2><ul>
<li>消息延时</li>
<li>消息过期</li>
<li>消费分组</li>
<li>消费策略</li>
<li>消息丢失</li>
<li>消息重复</li>
<li>消息乱序</li>
<li>消息积压</li>
<li>消息溢出</li>
</ul>
<h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><ul>
<li>TCP和UDP的区别</li>
<li>TCP之三次握手和四次挥手</li>
<li>TCP之标志位</li>
<li>TCP之序列号和确认号</li>
<li>TCP之数据校验</li>
<li>TCP之超时重传</li>
<li>TCP之流量控制（滑动窗口）</li>
<li>TCP之拥塞控制（拥塞窗口）</li>
</ul>
<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><ul>
<li>Http和Https</li>
<li>Cookie和Session</li>
<li>Http之url（输入URL到显示页面的全过程）</li>
<li>Http之GET和POST（GET和POST的区别）</li>
<li>Http之Status（常见的Http状态码）</li>
<li>Https之握手过程</li>
</ul>
<h2 id="Distributed"><a href="#Distributed" class="headerlink" title="Distributed"></a>Distributed</h2><ul>
<li>分布式id（雪花id + 时钟回拨）</li>
<li>分布式锁（redis分布式锁 + redis红锁）</li>
<li>分布式事务</li>
</ul>
<h1 id="java面试总结（语言篇）"><a href="#java面试总结（语言篇）" class="headerlink" title="java面试总结（语言篇）"></a>java面试总结（语言篇）</h1><h2 id="Lang-1"><a href="#Lang-1" class="headerlink" title="Lang"></a>Lang</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String为什么是不可变的"><a href="#String为什么是不可变的" class="headerlink" title="String为什么是不可变的"></a>String为什么是不可变的</h4><ul>
<li>字符数组私有且被final修饰，并且没有提供修改的方法，保证不会被外部修改</li>
<li>类被final修饰，使得不可被继承，保证不会被子类修改</li>
</ul>
<h4 id="String为什么要设计成不可变的"><a href="#String为什么要设计成不可变的" class="headerlink" title="String为什么要设计成不可变的"></a>String为什么要设计成不可变的</h4><ul>
<li>String不可变时可以放到常量池里缓存并重复使用</li>
<li>String不可变时容器可以缓存String的hashCode并重复使用</li>
<li>String不可变时可以保证线程安全</li>
</ul>
<h4 id="String和StringBuilder、StringBuffer的区别"><a href="#String和StringBuilder、StringBuffer的区别" class="headerlink" title="String和StringBuilder、StringBuffer的区别"></a>String和StringBuilder、StringBuffer的区别</h4><ul>
<li>String是不可变的，StringBuilder、StringBuffer是可变的</li>
<li>String和StringBuffer是线程安全的，StringBuilder是线程不安全的</li>
</ul>
<h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><h4 id="Integer为什么不能使用-x3D-x3D-进行比较"><a href="#Integer为什么不能使用-x3D-x3D-进行比较" class="headerlink" title="Integer为什么不能使用&#x3D;&#x3D;进行比较"></a>Integer为什么不能使用&#x3D;&#x3D;进行比较</h4><ul>
<li>&#x3D;&#x3D;比较的是两个对象的地址是否相等，即是否是同一个对象</li>
<li>用数值字面量赋值给Integer对象时，会进行装箱操作</li>
<li>数值字面量小于等于127时会从缓存中取对象，这时候地址相等会返回true</li>
<li>数值字面量大于127时会新建对象，这时候地址不相等会返回false</li>
<li>所以Integer用&#x3D;&#x3D;比较时会导致数值相等但结果为false的错误问题</li>
<li>Integer对象的比较需要用equals方法</li>
</ul>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="Object的基本方法"><a href="#Object的基本方法" class="headerlink" title="Object的基本方法"></a>Object的基本方法</h4><p>getClass、hashCode、equals、toString、clone、wait、notify、notifyAll、finalize</p>
<h4 id="equals和-x3D-x3D-的区别"><a href="#equals和-x3D-x3D-的区别" class="headerlink" title="equals和&#x3D;&#x3D;的区别"></a>equals和&#x3D;&#x3D;的区别</h4><ul>
<li>equals：逻辑相等，比较对象是否是相同的对象</li>
<li>&#x3D;&#x3D;：引用相等，比较对象是否是同一个对象</li>
</ul>
<blockquote>
<p>注意：数值类对象比较使用 equals 可以避免以下问题</p>
<ul>
<li>用&#x3D;&#x3D;比较时，值相同但地址不同，带来的逻辑判断错误的问题</li>
<li>用&#x3D;&#x3D;比较时，包装类缓存，带来的逻辑判断错误的问题</li>
<li>用&#x3D;&#x3D;比较时，包装类拆箱，带来的空指针异常问题</li>
</ul>
</blockquote>
<h2 id="Container-1"><a href="#Container-1" class="headerlink" title="Container"></a>Container</h2><h3 id="Container-2"><a href="#Container-2" class="headerlink" title="Container"></a>Container</h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h5 id="Array和ArrayList的区别"><a href="#Array和ArrayList的区别" class="headerlink" title="Array和ArrayList的区别"></a>Array和ArrayList的区别</h5><ul>
<li>Array的占用空间是固定的，ArrayList的占用空间是动态的</li>
<li>Array支持原始类型，ArrayList只支持对象类型</li>
<li>Array的元素可以直接使用子类，ArrayList的元素需要使用类型通配符才能使用子类</li>
<li>Array获取大小是通过length属性，ArrayList获取大小是通过size方法</li>
<li>Array没有删除元素的方法，ArrayList有删除元素的方法</li>
</ul>
<h5 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h5><ul>
<li>结构：<ul>
<li>ArrayList是基于数组实现的</li>
<li>LinkedList是基于链表实现的</li>
</ul>
</li>
<li>性能：<ul>
<li>ArrayList读取时使用索引直接定位，所以读取（随机访问）较快，写入时需要移动元素，所以写入（插入和删除）较慢</li>
<li>LinkedList读取时需从头开始遍历，所以读取（随机访问）较慢，写入时不需要移动元素，所以写入（插入和删除）较快</li>
</ul>
</li>
<li>空间：<ul>
<li>LinkedList使用Node结构还需要存储前指针和后指针，比ArrayList更占内存</li>
</ul>
</li>
</ul>
<h5 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a>ArrayList和Vector的区别</h5><h5 id="Collections-synchronizedList和Vector的区别"><a href="#Collections-synchronizedList和Vector的区别" class="headerlink" title="Collections.synchronizedList和Vector的区别"></a>Collections.synchronizedList和Vector的区别</h5><h5 id="CopyOnWriteArrayList和Vector的区别"><a href="#CopyOnWriteArrayList和Vector的区别" class="headerlink" title="CopyOnWriteArrayList和Vector的区别"></a>CopyOnWriteArrayList和Vector的区别</h5><h5 id="CopyOnWriteArrayList和Collections-synchronizedList的区别"><a href="#CopyOnWriteArrayList和Collections-synchronizedList的区别" class="headerlink" title="CopyOnWriteArrayList和Collections.synchronizedList的区别"></a>CopyOnWriteArrayList和Collections.synchronizedList的区别</h5><h5 id="为什么ArrayList实现了RandomAccess接口而LinkedList却没有"><a href="#为什么ArrayList实现了RandomAccess接口而LinkedList却没有" class="headerlink" title="为什么ArrayList实现了RandomAccess接口而LinkedList却没有"></a>为什么ArrayList实现了RandomAccess接口而LinkedList却没有</h5><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><h5 id="HashMap和ConcurrentHashMap的区别"><a href="#HashMap和ConcurrentHashMap的区别" class="headerlink" title="HashMap和ConcurrentHashMap的区别"></a>HashMap和ConcurrentHashMap的区别</h5><h5 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h5><h5 id="Collections-synchronizedMap和Hashtable的区别"><a href="#Collections-synchronizedMap和Hashtable的区别" class="headerlink" title="Collections.synchronizedMap和Hashtable的区别"></a>Collections.synchronizedMap和Hashtable的区别</h5><h5 id="ConcurrentHashMap和Hashtable的区别"><a href="#ConcurrentHashMap和Hashtable的区别" class="headerlink" title="ConcurrentHashMap和Hashtable的区别"></a>ConcurrentHashMap和Hashtable的区别</h5><h5 id="ConcurrentHashMap和Collections-synchronizedMap的区别"><a href="#ConcurrentHashMap和Collections-synchronizedMap的区别" class="headerlink" title="ConcurrentHashMap和Collections.synchronizedMap的区别"></a>ConcurrentHashMap和Collections.synchronizedMap的区别</h5><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><h5 id="Queue方法的区别"><a href="#Queue方法的区别" class="headerlink" title="Queue方法的区别"></a>Queue方法的区别</h5><p>按照操作分</p>
<ul>
<li>add&#x2F;offer&#x2F;put：添加尾部元素</li>
<li>remove&#x2F;poll&#x2F;take：移除头部元素</li>
<li>element&#x2F;peek：查询头部元素</li>
</ul>
<p>按照结果分</p>
<ul>
<li>add&#x2F;remove&#x2F;element：操作元素失败的时候抛出异常</li>
<li>offer&#x2F;poll&#x2F;peek：操作元素失败的时候会返回值</li>
<li>put&#x2F;take：操作元素失败的时候会阻塞</li>
</ul>
<blockquote>
<p>ps：put&#x2F;take是BlockingQueue接口特有的阻塞方法，Queue接口里没有</p>
</blockquote>
<h5 id="双端队列的使用场景"><a href="#双端队列的使用场景" class="headerlink" title="双端队列的使用场景"></a>双端队列的使用场景</h5><ul>
<li>模拟栈</li>
<li>实现消息消费失败时回退的功能</li>
</ul>
<h5 id="ArrayDeque和LinkedList的区别"><a href="#ArrayDeque和LinkedList的区别" class="headerlink" title="ArrayDeque和LinkedList的区别"></a>ArrayDeque和LinkedList的区别</h5><ul>
<li>结构：<ul>
<li>ArrayDeque是基于数组实现的</li>
<li>LinkedList是基于链表实现的</li>
</ul>
</li>
<li>性能：<ul>
<li>ArrayDeque读取时使用索引直接定位，所以读取（随机访问）较快，写入时需要移动元素，所以写入（插入和删除）较慢</li>
<li>LinkedList读取时需从头开始遍历，所以读取（随机访问）较慢，写入时不需要移动元素，所以写入（插入和删除）较快</li>
</ul>
</li>
<li>空间：<ul>
<li>LinkedList使用Node结构还需要存储前指针和后指针，比ArrayDeque更占内存</li>
</ul>
</li>
</ul>
<h5 id="ArrayBlockingQueue和LinkedBlockingQueue的区别"><a href="#ArrayBlockingQueue和LinkedBlockingQueue的区别" class="headerlink" title="ArrayBlockingQueue和LinkedBlockingQueue的区别"></a>ArrayBlockingQueue和LinkedBlockingQueue的区别</h5><ul>
<li>结构：<ul>
<li>ArrayBlockingQueue是基于循环数组实现的，LinkedBlockingQueue基于链表实现的</li>
<li>ArrayBlockingQueue必须设置边界，LinkedBlockingQueue默认无界，但边界可配</li>
</ul>
</li>
<li>性能：<ul>
<li>ArrayBlockingQueue出队和入队使用同一把锁，LinkedBlockingQueue出队和入队使用不同的锁，因此LinkedBlockingQueue的并发支持更高</li>
</ul>
</li>
<li>空间：<ul>
<li>ArrayBlockingQueue因为使用循环数组会分配固定的内存，LinkedBlockingQueue按需使用内存，因此ArrayBlockingQueue在滞留元素较少时容易浪费空间</li>
<li>LinkedBlockingQueue使用Node结构还需要存储指针，比ArrayBlockingQueue更占内存</li>
<li>LinkedBlockingQueue会频繁的创建和销毁额外的Node对象，对GC存在较大影响</li>
</ul>
</li>
</ul>
<h5 id="LinkedBlockingQueue和ConcurrentLinkedQueue的区别"><a href="#LinkedBlockingQueue和ConcurrentLinkedQueue的区别" class="headerlink" title="LinkedBlockingQueue和ConcurrentLinkedQueue的区别"></a>LinkedBlockingQueue和ConcurrentLinkedQueue的区别</h5><ul>
<li>LinkedBlockingQueue是<code>阻塞队列</code></li>
<li>ConcurrentLinkedQueue是<code>非阻塞队列</code></li>
</ul>
<h5 id="SynchronousQueue和TransferQueue的区别"><a href="#SynchronousQueue和TransferQueue的区别" class="headerlink" title="SynchronousQueue和TransferQueue的区别"></a>SynchronousQueue和TransferQueue的区别</h5><ul>
<li>SynchronousQueue并发控制时使用的是锁，性能相对较低（会被阻塞）</li>
<li>TransferQueue并发控制时使用的是CAS，性能相对较高（不会阻塞）</li>
</ul>
<h5 id="DelayQueue和DelayedWorkQueue的区别"><a href="#DelayQueue和DelayedWorkQueue的区别" class="headerlink" title="DelayQueue和DelayedWorkQueue的区别"></a>DelayQueue和DelayedWorkQueue的区别</h5><ul>
<li>DelayQueue是通用的<code>延时消息队列</code>（基于PriorityQueue实现的），支持的元素的类型是 <code>Delayed</code></li>
<li>DelayedWorkQueue是专用的<code>延时任务队列</code>（是ScheduledThreadPoolExecutor的内部类），支持的元素类型是 <code>RunnableScheduledFuture</code></li>
</ul>
<h3 id="Traverse"><a href="#Traverse" class="headerlink" title="Traverse"></a>Traverse</h3><h4 id="Iterator和Itreable的区别"><a href="#Iterator和Itreable的区别" class="headerlink" title="Iterator和Itreable的区别"></a>Iterator和Itreable的区别</h4><ul>
<li>Iterator：迭代器，负责进行遍历</li>
<li>Itreable：可迭代，负责返回Iterator</li>
</ul>
<h4 id="Iterator和ListIterator的区别"><a href="#Iterator和ListIterator的区别" class="headerlink" title="Iterator和ListIterator的区别"></a>Iterator和ListIterator的区别</h4><ul>
<li>Iterator只能向后遍历</li>
<li>ListIterator还可以向前遍历</li>
</ul>
<h4 id="如何高效的遍历容器"><a href="#如何高效的遍历容器" class="headerlink" title="如何高效的遍历容器"></a>如何高效的遍历容器</h4><ul>
<li>List使用fori的遍历方式最高效</li>
<li>Set和Map使用size + fori + iterator.next的遍历方式效率比foreach更高</li>
</ul>
<h4 id="List遍历时调用list-remove删除元素会有什么问题"><a href="#List遍历时调用list-remove删除元素会有什么问题" class="headerlink" title="List遍历时调用list.remove删除元素会有什么问题"></a>List遍历时调用list.remove删除元素会有什么问题</h4><ul>
<li>迭代器会检查到迭代器的expectedModCount和list的modCount不一致而抛出ConcurrentModificationException异常</li>
</ul>
<h4 id="List遍历时怎么安全的删除元素"><a href="#List遍历时怎么安全的删除元素" class="headerlink" title="List遍历时怎么安全的删除元素"></a>List遍历时怎么安全的删除元素</h4><ul>
<li>使用迭代器遍历并使用哪个迭代器的删除方法</li>
<li>从后向前遍历时可以删除当前及当前之后元素</li>
<li>可以将不需要删除的元素添加到新的列表中去</li>
</ul>
<h3 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h3><h4 id="Comparator和Comparable的区别"><a href="#Comparator和Comparable的区别" class="headerlink" title="Comparator和Comparable的区别"></a>Comparator和Comparable的区别</h4><ul>
<li>Comparator：比较器，负责对任意两个对象进行比较</li>
<li>Comparable：可比较，负责比较当前对象和其他对象</li>
</ul>
<h3 id="Nullable"><a href="#Nullable" class="headerlink" title="Nullable"></a>Nullable</h3><h4 id="ConcurrentHashMap为什么key和value不能为null"><a href="#ConcurrentHashMap为什么key和value不能为null" class="headerlink" title="ConcurrentHashMap为什么key和value不能为null"></a>ConcurrentHashMap为什么key和value不能为null</h4><ul>
<li>如果允许value为null，当get返回null时无法区分value是不存在还是value为null</li>
<li>这时候就存在了存在二义性</li>
<li>需要用containsKey来判断value是否存在</li>
<li>如果value本来是不存在，当其他线程在当前线程的get和containsKey操作之间put了一个key相同的value，会导致当前线程判断value为存在，和实际情况不符而出现了bug</li>
<li>如果value本来是存在的，当其他线程在当前线程的get和containsKey操作之间remove了一个key相同的value，会导致当前线程判断value为不存在，和实际情况不符而出现了bug</li>
</ul>
<h3 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h3><h4 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h4><h5 id="ArrayList是如何扩容的"><a href="#ArrayList是如何扩容的" class="headerlink" title="ArrayList是如何扩容的"></a>ArrayList是如何扩容的</h5><ul>
<li>初始容量：10（可通过initialCapacity设置）</li>
<li>负载因子：1</li>
<li>扩容时机：存入数据前</li>
<li>扩容条件： <code>size + 1 &gt; capacity</code></li>
<li>扩容计算： <code>capacity + capacity &gt;&gt; 1</code></li>
<li>扩容迁移：不需要迁移</li>
</ul>
<h5 id="ArrayList为什么按大约1-5倍扩容"><a href="#ArrayList为什么按大约1-5倍扩容" class="headerlink" title="ArrayList为什么按大约1.5倍扩容"></a>ArrayList为什么按大约1.5倍扩容</h5><ul>
<li>小于1.5倍时太小，会导致频繁扩容</li>
<li>大于1.5倍时太大，会导致内存浪费</li>
</ul>
<h4 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h4><h5 id="Map-2"><a href="#Map-2" class="headerlink" title="Map"></a>Map</h5><h6 id="为什么重写equals时要重写hashCode"><a href="#为什么重写equals时要重写hashCode" class="headerlink" title="为什么重写equals时要重写hashCode"></a>为什么重写equals时要重写hashCode</h6><ul>
<li>为了避免equals相等而hashCode不相等时导致map可以将两个相等的key存在不同的槽位而违背了key不重复的原则</li>
<li>为了避免用另一个和A对象相等的B对象去map中找A时由于hashCode不相等而找不到A的情况</li>
</ul>
<h6 id="重写equals和hashCode的设计原则"><a href="#重写equals和hashCode的设计原则" class="headerlink" title="重写equals和hashCode的设计原则"></a>重写equals和hashCode的设计原则</h6><ul>
<li>equals相等，hashCode一定相等</li>
<li>equals不相等，hashCode不一定不相等</li>
<li>hashCode相等，equals不一定相等</li>
<li>hashCode不相等，equals一定不相等</li>
</ul>
<h6 id="hash冲突如何解决"><a href="#hash冲突如何解决" class="headerlink" title="hash冲突如何解决"></a>hash冲突如何解决</h6><ul>
<li>开放定址法：冲突后寻找下一个空位置插入，查找时会顺着冲突位置往下查找<ul>
<li>线性探测法</li>
<li>平方探测法</li>
<li>再哈希探测法</li>
</ul>
</li>
<li>链地址法：冲突的部分在同一个位置用链表链接起来，查找时会在链表中查找</li>
<li>公共溢出区：冲突的部分都放到另一个列表中，找不到时会在溢出表中顺序查找</li>
</ul>
<h6 id="hash方法为何要进行位移后异或"><a href="#hash方法为何要进行位移后异或" class="headerlink" title="hash方法为何要进行位移后异或"></a>hash方法为何要进行位移后异或</h6><p>是为了让hash值更加分散，减少hash冲突</p>
<h6 id="Map的容量大小为什么必须是2的幂次方"><a href="#Map的容量大小为什么必须是2的幂次方" class="headerlink" title="Map的容量大小为什么必须是2的幂次方"></a>Map的容量大小为什么必须是2的幂次方</h6><ol>
<li>加快索引计算：计算索引位时可以使用按位与运算代替求余运算来加快运算速度</li>
<li>加快索引计算：扩容后重新计算索引位时可以通过hash的第n位来快速确定新位置</li>
<li>减少哈希冲突：按位与运算时其中一个数都是1，增大了hash分布范围，减少了hash冲突</li>
</ol>
<h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><h6 id="HashMap的实现原理和核心逻辑"><a href="#HashMap的实现原理和核心逻辑" class="headerlink" title="HashMap的实现原理和核心逻辑"></a>HashMap的实现原理和核心逻辑</h6><h6 id="java7和java8的HashMap区别"><a href="#java7和java8的HashMap区别" class="headerlink" title="java7和java8的HashMap区别"></a>java7和java8的HashMap区别</h6><table>
<thead>
<tr>
<th>区别点</th>
<th>jdk7</th>
<th>jdk8</th>
</tr>
</thead>
<tbody><tr>
<td>存储结构</td>
<td>数组 + 链表</td>
<td>数组 + 链表 + 红黑树</td>
</tr>
<tr>
<td>逻辑结构</td>
<td>Entry</td>
<td>Node</td>
</tr>
<tr>
<td>结点插法</td>
<td>头插法</td>
<td>尾插法</td>
</tr>
<tr>
<td>哈希（hash）算法</td>
<td>较复杂</td>
<td>较简单（冲突了可以树化）</td>
</tr>
<tr>
<td>下标（index）算法</td>
<td>较复杂</td>
<td>较简单（使用了按位与运算代替求余运算）</td>
</tr>
<tr>
<td>扩容时机</td>
<td>存入数据前判断</td>
<td>存入数据后判断</td>
</tr>
<tr>
<td>扩容条件</td>
<td>大小超过阈值且存在hash冲突</td>
<td>大小超过阈值 或者 链表大小大于8且桶个数小于64</td>
</tr>
<tr>
<td>扩容迁移</td>
<td>所有元素重新求槽位</td>
<td>用新容量的最高有效位与hash中的相同位进行异或来快速确定新槽位</td>
</tr>
</tbody></table>
<blockquote>
<p>ps：大小超过阈值 &#x3D;》 <code>size &gt; threshold</code></p>
</blockquote>
<blockquote>
<p>ps：hash冲突 &#x3D;》 <code>entry != null</code></p>
</blockquote>
<h6 id="java8的HashMap为什么要用红黑树"><a href="#java8的HashMap为什么要用红黑树" class="headerlink" title="java8的HashMap为什么要用红黑树"></a>java8的HashMap为什么要用红黑树</h6><p>红黑树是查找树，可以使用二分查找，查找次数比链表少</p>
<ul>
<li>跳表需要数据有序<ul>
<li>HashMap中查找使用的hashcode是散列无序的</li>
</ul>
</li>
<li>跳表占用的空间比红黑树多<ul>
<li>跳表需要维护额外的多层链表，需要占用额外的空间</li>
<li>红黑树不需要占用额外的空间</li>
</ul>
</li>
</ul>
<h6 id="java8的HashMap中的红黑树是排序规则"><a href="#java8的HashMap中的红黑树是排序规则" class="headerlink" title="java8的HashMap中的红黑树是排序规则"></a>java8的HashMap中的红黑树是排序规则</h6><ul>
<li>实现了Comparable接口则用Comparable接口排序</li>
<li>否则用类的名字的自然顺序排序</li>
<li>类名相同的使用对象的hashcode的自然顺序排序</li>
</ul>
<h6 id="java8的HashMap中链表和红黑树的转换条件"><a href="#java8的HashMap中链表和红黑树的转换条件" class="headerlink" title="java8的HashMap中链表和红黑树的转换条件"></a>java8的HashMap中链表和红黑树的转换条件</h6><p>树化：链表大小大于8，且桶个数大于或等于64（小于64时会扩容而不会树化）<br>链化：链表大小小于或等于6</p>
<h6 id="HashMap是如何扩容的"><a href="#HashMap是如何扩容的" class="headerlink" title="HashMap是如何扩容的"></a>HashMap是如何扩容的</h6><ul>
<li>初始容量：16（可通过initialCapacity设置）</li>
<li>负载因子：0.75</li>
<li>扩容时机：<ul>
<li>java7：存入数据前</li>
<li>java8：存入数据后</li>
</ul>
</li>
<li>扩容条件<ul>
<li>java7：大小超过阈值且存在hash冲突</li>
<li>java8：大小超过阈值 或者 链表大小大于8且桶个数小于64</li>
</ul>
</li>
<li>扩容计算：<ul>
<li>java7：扩容到原来的2倍</li>
<li>java8：扩容到原来的2倍</li>
</ul>
</li>
<li>扩容迁移：<ul>
<li>java7：所有元素重新求槽位</li>
<li>java8：用新容量的最高有效位与hash中的相同位进行异或来快速确定新槽位</li>
</ul>
</li>
</ul>
<h6 id="HashMap有哪些并发问题"><a href="#HashMap有哪些并发问题" class="headerlink" title="HashMap有哪些并发问题"></a>HashMap有哪些并发问题</h6><ul>
<li>并发更新时导致更新丢失</li>
<li>并发扩容时导致链表插入死循环（java8时已通过尾插法解决）</li>
</ul>
<p>TODO：HashMap插入死循环</p>
<h6 id="HashMap使用时如何保证线程安全"><a href="#HashMap使用时如何保证线程安全" class="headerlink" title="HashMap使用时如何保证线程安全"></a>HashMap使用时如何保证线程安全</h6><h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><h6 id="ConcurrentHashMap的实现原理和核心逻辑"><a href="#ConcurrentHashMap的实现原理和核心逻辑" class="headerlink" title="ConcurrentHashMap的实现原理和核心逻辑"></a>ConcurrentHashMap的实现原理和核心逻辑</h6><h6 id="java7和java8的ConcurrentHashMap区别"><a href="#java7和java8的ConcurrentHashMap区别" class="headerlink" title="java7和java8的ConcurrentHashMap区别"></a>java7和java8的ConcurrentHashMap区别</h6><table>
<thead>
<tr>
<th>区别点</th>
<th>jdk7</th>
<th>jdk8</th>
</tr>
</thead>
<tbody><tr>
<td>存储结构</td>
<td>数组 + 链表</td>
<td>数组 + 链表 + 红黑树</td>
</tr>
<tr>
<td>逻辑结构</td>
<td>Segment + HashEntry + lock（segment）</td>
<td>Node + cas + synchronized（head）</td>
</tr>
<tr>
<td>结点插法</td>
<td>头插法</td>
<td>尾插法</td>
</tr>
<tr>
<td>哈希（hash）算法</td>
<td>和HashMap一样</td>
<td>和HashMap一样</td>
</tr>
<tr>
<td>下标（index）算法</td>
<td>需要index两次</td>
<td>只需要index一次</td>
</tr>
<tr>
<td>扩容时机</td>
<td>和HashMap一样</td>
<td>和HashMap一样</td>
</tr>
<tr>
<td>扩容条件</td>
<td>和HashMap一样</td>
<td>和HashMap一样</td>
</tr>
<tr>
<td>扩容迁移</td>
<td>单线程扩容迁移</td>
<td>多线程扩容迁移</td>
</tr>
<tr>
<td>大小计算</td>
<td>先无锁计算三次，如果结果一样则返回计算结果，否则就会锁住所有的Segment求和</td>
<td>通过baseCount和遍历CounterCell数组计算出size</td>
</tr>
</tbody></table>
<h6 id="java7的ConcurrentHashMap的并发度是什么"><a href="#java7的ConcurrentHashMap的并发度是什么" class="headerlink" title="java7的ConcurrentHashMap的并发度是什么"></a>java7的ConcurrentHashMap的并发度是什么</h6><p>ConcurrentHashMap的并发度是指ConcurrentHashMap支持同时读写的线程数</p>
<h6 id="java8的ConcurrentHashMap为什么放弃了分段锁"><a href="#java8的ConcurrentHashMap为什么放弃了分段锁" class="headerlink" title="java8的ConcurrentHashMap为什么放弃了分段锁"></a>java8的ConcurrentHashMap为什么放弃了分段锁</h6><h6 id="ConcurrentHashMap是如何计算size的"><a href="#ConcurrentHashMap是如何计算size的" class="headerlink" title="ConcurrentHashMap是如何计算size的"></a>ConcurrentHashMap是如何计算size的</h6><p>java7通过比较前后两次的所有Segment的size之和，如果结果一样则返回计算结果，如果不一样则继续计算并比较最多计算3次后还不一样，就会锁住所有的Segment求和<br>java8通过baseCount和遍历CounterCell数组计算出size</p>
<h6 id="ConcurrentHashMap是如何扩容的"><a href="#ConcurrentHashMap是如何扩容的" class="headerlink" title="ConcurrentHashMap是如何扩容的"></a>ConcurrentHashMap是如何扩容的</h6><p>整体流程和HashMap一样，并支持多线程扩容和分桶迁移</p>
<ul>
<li>写入和迁移的流程<ul>
<li>读取头结点并判断是否为null，为null则cas<ul>
<li>写入时cas的新值是新结点</li>
<li>迁移时cas的新值是fwd结点</li>
</ul>
</li>
<li>头结点不为null时，判断是否是迁移中(头结点的hash等于MOVED代表迁移中)<ul>
<li>写入时如果是迁移中就帮助迁移（helpTransfer）</li>
<li>迁移时如果是迁移中就什么也不做</li>
</ul>
</li>
<li>否则就锁住头结点进行操作</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：迁移时是按照桶为单位分配给线程进行迁移的<br>ps：迁移中是指整个表还在迁移中，而不是某个桶还在迁移中<br>ps：头结点不为null且头结点的hash等于MOVED代表迁移中</p>
</blockquote>
<ul>
<li>写入时的迁移操作<ul>
<li>写入时如果桶为空，由于CAS写入时是原子操作，则迁移操作会在写入完成之后执行</li>
<li>写入时如果桶不为空，由于写入时会锁住头结点，则迁移操作获取头结点的锁时会被阻塞</li>
</ul>
</li>
<li>迁移时的读操作<ul>
<li>如果桶的头结点是fwd结点，则表示迁移完成，可以通过fwd结点的nextTable找到新表进行读取</li>
<li>如果检测到正在迁移中，由于迁移时是复制结点的引用而不是删除，所以在原表中还可以读到结点</li>
</ul>
</li>
<li>迁移时的写操作<ul>
<li>如果桶的头结点是fwd结点，则表示迁移完成，可以通过fwd结点的nextTable找到新表进行写入</li>
<li>如果检测到正在迁移中，则先放弃写入操作并帮助扩容迁移，扩容迁移完后再写入</li>
</ul>
</li>
</ul>
<p>扩容相关的属性</p>
<ul>
<li>table：当前表（旧表）</li>
<li>nextTable: 新表</li>
<li>sizeCtl: 表状态<ul>
<li>sizeCtl &#x3D; 0：表示没有指定初始容量</li>
<li>sizeCtl &gt; 0：表示初始容量(可以使用阶段)</li>
<li>sizeCtl &#x3D; -1, 标记作用，告知其他线程，正在初始化</li>
<li>sizeCtl &#x3D; 0.75n , 扩容阈值</li>
<li>sizeCtl &lt; 0 : 表示有其他线程正在执行扩容or初始化(不能使用阶段)</li>
<li>sizeCtl &#x3D; (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2 : 表示此时只有一个线程在执行扩容</li>
</ul>
</li>
<li>transferIndex: 正在迁移的桶索引</li>
<li>ForwardingNode结点: fwd结点，标记此结点的数据已经迁移完毕</li>
</ul>
<h6 id="ConcurrentHashMap是如何保证线程安全的"><a href="#ConcurrentHashMap是如何保证线程安全的" class="headerlink" title="ConcurrentHashMap是如何保证线程安全的"></a>ConcurrentHashMap是如何保证线程安全的</h6><p>cas（槽位值为null） + synchronized（锁链表头部）</p>
<h6 id="ConcurrentHashMap还有并发问题吗"><a href="#ConcurrentHashMap还有并发问题吗" class="headerlink" title="ConcurrentHashMap还有并发问题吗"></a>ConcurrentHashMap还有并发问题吗</h6><p>有，单个操作是安全的，复合操作不是安全的</p>
<h4 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h4><h5 id="ArrayBlockingQueue是如何实现阻塞功能的"><a href="#ArrayBlockingQueue是如何实现阻塞功能的" class="headerlink" title="ArrayBlockingQueue是如何实现阻塞功能的"></a>ArrayBlockingQueue是如何实现阻塞功能的</h5><p>使用了ReentrantLock的Condition来实现阻塞和唤醒的</p>
<ul>
<li>notEmptyCondition：入队时signal，出队时如果为空则await</li>
<li>notFullCondition：出队时signal，入队时如果为满则await</li>
</ul>
<h2 id="Concurrency-1"><a href="#Concurrency-1" class="headerlink" title="Concurrency"></a>Concurrency</h2><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><h4 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h4><ul>
<li>继承Thread，并实现run方法，然后调用start启动</li>
<li>实现Runnable，并作为target传递给线程进行启动</li>
<li>实现Callable，并用FutureTask包装后作为target传递给线程进行启动</li>
<li>使用线程池的execute方法执行Runnable</li>
<li>使用线程池的submit方法提交Runnable或者Callable</li>
<li>使用CompletableFuture类</li>
</ul>
<h4 id="线程的状态变化"><a href="#线程的状态变化" class="headerlink" title="线程的状态变化"></a>线程的状态变化</h4><p>NEW、READY、RUNNING、WAITING、TIMED_WAITING、BLOCKED、TERMINATED</p>
<ul>
<li>NEW（新建）：创建线程后进入此状态</li>
<li>READY（就绪）：创建后调用Thread.start或者运行时调用Thread.yield进入此状态</li>
<li>RUNNING（运行）：获取资源（cpu和lock）成功后进入此状态</li>
<li>WAITING（等待）：调用Thread.join、Object.wait、LockSupport.park的非超时方法后进入此状态</li>
<li>TIMED_WAITING（超时等待）：调用Thread.sleep、Thread.join、Object.wait、LockSupport.park的超时方法后进入此状态</li>
<li>BLOCKED（阻塞）：获取lock失败后进入此状态</li>
<li>TERMINATED（死亡）：结束线程后进入此状态</li>
</ul>
<h4 id="线程的控制方法"><a href="#线程的控制方法" class="headerlink" title="线程的控制方法"></a>线程的控制方法</h4><ul>
<li>Thread.yield：让出cpu资源并进入<code>就绪状态</code>，<code>不释放锁资源</code></li>
<li>Thread.sleep：让出cpu资源并进入<code>等待状态</code>，<code>不释放锁资源</code></li>
<li>Thread.join：让出cpu资源并进入<code>等待状态</code>，<code>会释放锁资源</code></li>
</ul>
<h4 id="线程的废弃方法"><a href="#线程的废弃方法" class="headerlink" title="线程的废弃方法"></a>线程的废弃方法</h4><p>suspend&#x2F;resume、stop、destroy</p>
<ul>
<li>suspend：不会释放锁，会导致死锁问题</li>
<li>stop：会立即终止线程，导致操作被中断，会导致数据不一致和资源未释放等问题</li>
<li>destroy：从来都没有被实现过，且已经被废弃了（相当于suspend且没有后续的resume）</li>
</ul>
<h4 id="线程的相关疑问"><a href="#线程的相关疑问" class="headerlink" title="线程的相关疑问"></a>线程的相关疑问</h4><h5 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h5><ul>
<li>线程是任务调度和指令执行的最小单元，进程是资源分配的最小单元</li>
<li>线程开销小，进程开销大，线程又被称作轻量级进程</li>
<li>进程可以包含多个线程，至少包含一个线程</li>
<li>同一个进程的线程共享资源，不同进程之间的资源相互独立</li>
<li>线程异常如果不处理会导致线程所属的进程挂掉，进程挂掉则不会影响其他进程</li>
</ul>
<h5 id="Runnable和Callable的区别"><a href="#Runnable和Callable的区别" class="headerlink" title="Runnable和Callable的区别"></a>Runnable和Callable的区别</h5><ul>
<li>Runnable不能获取返回值</li>
<li>Callable和Future、FutureTask配合可以获取返回值</li>
</ul>
<h5 id="Thread的start和run的区别"><a href="#Thread的start和run的区别" class="headerlink" title="Thread的start和run的区别"></a>Thread的start和run的区别</h5><ul>
<li>start是本地方法，会启动线程</li>
<li>run是普通方法，不会启动线程</li>
</ul>
<blockquote>
<p>start调用了start0，start0是本地方法</p>
</blockquote>
<h5 id="Thread的start能调用多次吗"><a href="#Thread的start能调用多次吗" class="headerlink" title="Thread的start能调用多次吗"></a>Thread的start能调用多次吗</h5><p>不能，再次调用时会检测到状态变化后抛出 <code>IllegalThreadStateException</code> 异常</p>
<h5 id="Thread的sleep和yield的区别"><a href="#Thread的sleep和yield的区别" class="headerlink" title="Thread的sleep和yield的区别"></a>Thread的sleep和yield的区别</h5><ul>
<li>方法：都是Thread的静态方法</li>
<li>锁：都不释放锁</li>
<li>状态：sleep进入到等待状态，yield进入到就绪状态</li>
</ul>
<h5 id="Thread的sleep和join的区别"><a href="#Thread的sleep和join的区别" class="headerlink" title="Thread的sleep和join的区别"></a>Thread的sleep和join的区别</h5><ul>
<li>方法：sleep是Thread的静态方法，join是Thread的实例方法</li>
<li>锁：sleep不释放锁，join释放锁</li>
<li>状态：都是进入到等待状态</li>
</ul>
<h5 id="Thread的join和wait的区别"><a href="#Thread的join和wait的区别" class="headerlink" title="Thread的join和wait的区别"></a>Thread的join和wait的区别</h5><ul>
<li>方法：join是Thread的实例方法，wait是Object的实例方法</li>
<li>锁：都会释放锁</li>
<li>状态：都是进入到等待状态</li>
</ul>
<blockquote>
<p>ps：join是通过wait来实现的，所以和wait没区别</p>
</blockquote>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h4 id="ThreadLocal为什么会内存泄漏"><a href="#ThreadLocal为什么会内存泄漏" class="headerlink" title="ThreadLocal为什么会内存泄漏"></a>ThreadLocal为什么会内存泄漏</h4><ol>
<li>ThreadLocal是基于ThreadLocalMap实现的</li>
<li>Thread引用了ThreadLocalMap</li>
<li>ThreadLocalMap引用了key和value</li>
<li>key弱引用了ThreadLocal</li>
<li>当ThreadLocal不再使用时，即没有强引用时</li>
<li>由于key是弱引用，所以ThreadLocal会被回收</li>
<li>此时无法通过ThreadLocal访问value，value应该被回收</li>
<li>由于Thread通过ThreadLocalMap间接强引用了value，所以要先回收Thread</li>
<li>但是如果Thread是线程池时，Thread不能被回收，所以value不能回收</li>
<li>此时value既不能访问又不能回收，就造成了内存泄漏</li>
</ol>
<blockquote>
<p>ps：ThreadLocal在get和set时会自动检测哪些key指向null的entry并清除，可以一定程度减轻内存泄漏的影响</p>
</blockquote>
<h4 id="ThreadLocalMap的key为什么是弱引用"><a href="#ThreadLocalMap的key为什么是弱引用" class="headerlink" title="ThreadLocalMap的key为什么是弱引用"></a>ThreadLocalMap的key为什么是弱引用</h4><ul>
<li>如果ThreadLocalMap的key为强引用，此时Thread就会通过ThreadLocalMap间接强引用了key</li>
<li>如果Thread不回收，比如是线程池时，即使ThreadLocal不再使用了</li>
<li>由于ThreadLocal还被Thread引用着，所以ThreadLocal会无法回收而导致内存泄漏</li>
</ul>
<h4 id="ThreadLocalMap的value为什么是强引用"><a href="#ThreadLocalMap的value为什么是强引用" class="headerlink" title="ThreadLocalMap的value为什么是强引用"></a>ThreadLocalMap的value为什么是强引用</h4><p>如果value是弱引用，垃圾回收后value指向了null，此时ThreadLocal还活着却获取不到value对象就不符合逻辑</p>
<h4 id="ThreadLocalMap为什么不用Thread做key"><a href="#ThreadLocalMap为什么不用Thread做key" class="headerlink" title="ThreadLocalMap为什么不用Thread做key"></a>ThreadLocalMap为什么不用Thread做key</h4><ul>
<li>如果用Thread做key（且ThreadLocalMap是ThreadLocal的实例），就会有多个线程访问map，就需要保证线程安全，复杂性会提高，并且并发性也会降低</li>
<li>如果用ThreadLocal做key（且ThreadLocalMap是Thread的实例），那么访问map的线程都是持有map的那一个线程，就不需要保证线程安全，复杂性会降低，并且并发性也会提高</li>
<li>如果是用二级map，那就会和ThreadLocalMap做key一样，就会有多个线程访问map，就需要保证线程安全，还需要两次寻址，复杂性会更高，并且并发性也会更低</li>
</ul>
<h4 id="ThreadLocal为什么要定义成静态变量"><a href="#ThreadLocal为什么要定义成静态变量" class="headerlink" title="ThreadLocal为什么要定义成静态变量"></a>ThreadLocal为什么要定义成静态变量</h4><p>定义成实例变量，容易重复创建，造成内存浪费</p>
<h4 id="ThreadLocal和局部变量的区别"><a href="#ThreadLocal和局部变量的区别" class="headerlink" title="ThreadLocal和局部变量的区别"></a>ThreadLocal和局部变量的区别</h4><p>ThreadLocal是线程（隔离）变量，局部变量是方法（隔离）变量</p>
<blockquote>
<p>ps：局部变量不溢出时本质上还是线程（隔离）变量，因为方法变量是线程私有的</p>
</blockquote>
<h3 id="Safe"><a href="#Safe" class="headerlink" title="Safe"></a>Safe</h3><h4 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h4><p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的</p>
<h4 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全"></a>如何保证线程安全</h4><ul>
<li>共享<ul>
<li>不可变<ul>
<li>不可变对象（Immutable）：通过对象不可变机制实现</li>
</ul>
</li>
<li>访问控制<ul>
<li>悲观锁（LOCK）：通过Mutex机制实现</li>
<li>乐观锁（CAS）：通过CAS机制实现</li>
</ul>
</li>
<li>读写分离<ul>
<li>写时复制（COW）：通过COW机制实现</li>
</ul>
</li>
</ul>
</li>
<li>私有<ul>
<li>方法局部对象（LocalVariable）：通过方法私有机制实现</li>
<li>线程隔离对象（ThreadLocal）：通过线程私有机制实现</li>
</ul>
</li>
</ul>
<h4 id="volatile能确保线程安全性吗"><a href="#volatile能确保线程安全性吗" class="headerlink" title="volatile能确保线程安全性吗"></a>volatile能确保线程安全性吗</h4><ul>
<li>volatile只能保证可见性和有序性，不能保证原子性</li>
<li>volatile只能保证原子操作（比如读和写操作）的线程安全</li>
<li>volatile不能保证非原子操作（比如自增和自减操作）的线程安全</li>
</ul>
<blockquote>
<p>所以volatile只能用来修饰哪些已经保证了原子性的操作，比如 <code>flag读写</code> 和 <code>cas操作</code></p>
</blockquote>
<blockquote>
<p>如果要想保证非原子性的操作的安全，可以使用 <code>atomic类</code> （atomic类内部依赖了volatile）</p>
</blockquote>
<h4 id="volatile的底层实现原理"><a href="#volatile的底层实现原理" class="headerlink" title="volatile的底层实现原理"></a>volatile的底层实现原理</h4><ul>
<li>保证可见性：内存屏障</li>
<li>保证有序性：内存屏障</li>
</ul>
<blockquote>
<p>ps：内存屏障存在的意义就是为了解决程序在运行过程中出现的内存访问乱序的问题<br>ps：内存屏障是靠cpu的lock前缀指令实现的</p>
</blockquote>
<h4 id="单例模式的双检查实现中volatile的作用"><a href="#单例模式的双检查实现中volatile的作用" class="headerlink" title="单例模式的双检查实现中volatile的作用"></a>单例模式的双检查实现中volatile的作用</h4><ul>
<li>保证可见性：volatile可以保证可见性，避免双重判断时没有读到最新的状态从而重复创建对象</li>
<li>保证有序性：volatile会禁止指令重排，避免还没初始化完成的对象被提前暴露引用并使用</li>
</ul>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><h4 id="锁的作用"><a href="#锁的作用" class="headerlink" title="锁的作用"></a>锁的作用</h4><p>通过互斥机制和队列机制将并发操作变为串行操作从而保证并发操作的线程安全</p>
<h5 id="并发操作的控制方式"><a href="#并发操作的控制方式" class="headerlink" title="并发操作的控制方式"></a>并发操作的控制方式</h5><blockquote>
<ol>
<li>悲观锁（LOCK）：适合 <code>低并发</code> 、 <code>常规读写</code> 、 <code>强一致性</code> 的场景</li>
<li>乐观锁（CAS ）：适合 <code>高并发</code> 、 <code>读多写少</code> 、 <code>弱一致性</code> 的场景</li>
<li>写时复制（COW）：适合 <code>高并发</code> 、 <code>读多写少</code> 、 <code>弱一致性</code> 的场景</li>
</ol>
</blockquote>
<blockquote>
<p>ps：CAS如果写多的话，竞争激烈时大量的失败导致cpu做了很多无用功从而占用和浪费cpu资源<br>ps：COW如果写多的话，频繁分配内存时来不及回收会造成内存占用过高<br>ps：CAS比COW的效率更高，但CAS支持设置操作却不支持插入和删除的操作</p>
</blockquote>
<h5 id="并发操作的读写控制"><a href="#并发操作的读写控制" class="headerlink" title="并发操作的读写控制"></a>并发操作的读写控制</h5><blockquote>
<ol>
<li>悲观锁（LOCK）：写写互斥，读写互斥，读读互斥</li>
<li>乐观锁（CAS ）：写写互斥，读写不互斥，读读不互斥</li>
<li>写时复制（COW）：写写互斥，读写不互斥，读读不互斥</li>
</ol>
</blockquote>
<blockquote>
<p>ps：读写不互斥时会存在弱一致性的问题</p>
</blockquote>
<h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><h5 id="锁的类型分类"><a href="#锁的类型分类" class="headerlink" title="锁的类型分类"></a>锁的类型分类</h5><ul>
<li>是否锁住资源：悲观锁（锁住资源）、乐观锁（不锁住资源）</li>
<li>是否独占资源：排他锁（独占资源）、共享锁（共享资源）</li>
<li>是否阻塞线程：同步锁（阻塞）、自旋锁（不阻塞）</li>
</ul>
<blockquote>
<p>ps：读写锁一般是写独占和读共享的，即写写互斥，读写互斥，读读不互斥</p>
</blockquote>
<h5 id="锁的实现分类"><a href="#锁的实现分类" class="headerlink" title="锁的实现分类"></a>锁的实现分类</h5><ul>
<li>是否锁住资源：悲观锁（synchronized、ReentrantLock）、乐观锁（ReentrantReadWriteLock、StampedLock）</li>
<li>是否共享资源：排他锁（synchronized、ReentrantLock）、共享锁（Semaphore）、读写锁（ReentrantReadWriteLock、StampedLock）</li>
<li>是否阻塞线程：同步锁（synchronized、ReentrantLock、ReentrantReadWriteLock、StampedLock）、自旋锁（SpinLock）</li>
</ul>
<blockquote>
<p>ps：ReentrantReadWriteLock是 <code>读写互斥</code> 的，而StampedLock是 <code>读写不互斥</code> 的</p>
</blockquote>
<h5 id="锁的范围分类"><a href="#锁的范围分类" class="headerlink" title="锁的范围分类"></a>锁的范围分类</h5><ul>
<li>线程锁</li>
<li>进程锁</li>
<li>分布式锁</li>
</ul>
<blockquote>
<p>ps：java锁、redis锁、数据库锁</p>
</blockquote>
<h4 id="锁的原理"><a href="#锁的原理" class="headerlink" title="锁的原理"></a>锁的原理</h4><ul>
<li>悲观锁：Mutex + 阻塞 + 唤醒</li>
<li>乐观锁：CAS + 自旋 + 重试</li>
</ul>
<h4 id="锁的特性"><a href="#锁的特性" class="headerlink" title="锁的特性"></a>锁的特性</h4><ul>
<li>是否支持重入：同一个线程是否可以多次获取锁</li>
<li>是否支持中断：线程是否可以响应中断请求</li>
<li>是否支持公平：线程是否能够公平的处理请求</li>
</ul>
<blockquote>
<p>ps：公平（排队且先进先出）、非公平（先插队，如果失败后再排队）</p>
</blockquote>
<h4 id="锁的问题"><a href="#锁的问题" class="headerlink" title="锁的问题"></a>锁的问题</h4><h5 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h5><p>死锁的形成条件</p>
<ul>
<li>互斥使用：即当资源被一个线程占用时，别的线程不能使用</li>
<li>不可抢占：资源请求者不能强制从资源占有者手中抢夺资源，资源只能由占有者主动释放</li>
<li>资源保持：当资源请求者在请求其他资源的同时保持对现有资源的占有</li>
<li>循环等待：多个线程存在环路的锁依赖关系而永远等待下去（例如T1占有T2需要的资源，T2占有T3需要的资源，T3占有T1需要的资源，这种情况可能会形成一个等待环路）</li>
</ul>
<p>死锁的解决办法</p>
<ul>
<li>预防死锁<ul>
<li>破坏不可抢占条件：当请求不到其他资源超时时释放自己持有的资源</li>
<li>破坏资源保持条件：申请资源时一次性申请全部所需的资源</li>
<li>破坏循环等待条件：给资源分配编号并按照编号顺序进行申请</li>
</ul>
</li>
<li>避免死锁<ul>
<li>银行家算法</li>
</ul>
</li>
<li>检测和解除死锁</li>
</ul>
<h5 id="饥饿问题"><a href="#饥饿问题" class="headerlink" title="饥饿问题"></a>饥饿问题</h5><p>饥饿的解决办法</p>
<ul>
<li>分配资源时使用公平的算法</li>
</ul>
<blockquote>
<p>ps：公平（排队且先进先出）、非公平（先插队，如果失败后再排队）</p>
</blockquote>
<h4 id="synchronized同步锁"><a href="#synchronized同步锁" class="headerlink" title="synchronized同步锁"></a>synchronized同步锁</h4><h5 id="synchronized锁原理"><a href="#synchronized锁原理" class="headerlink" title="synchronized锁原理"></a>synchronized锁原理</h5><ul>
<li>锁方法：通过方法的<code>ACC_SYNCHRONIZED</code>标识实现</li>
<li>锁代码块：通过对象的<code>monitor</code>锁和系统的<code>monitorenter</code>和<code>monitorexit</code>指令实现</li>
</ul>
<h5 id="synchronized锁优化"><a href="#synchronized锁优化" class="headerlink" title="synchronized锁优化"></a>synchronized锁优化</h5><ul>
<li>锁膨胀</li>
<li>锁消除</li>
<li>锁粗化</li>
<li>自适应自旋锁</li>
</ul>
<h5 id="synchronized锁膨胀"><a href="#synchronized锁膨胀" class="headerlink" title="synchronized锁膨胀"></a>synchronized锁膨胀</h5><ul>
<li>无锁：没有线程获取锁</li>
<li>偏向锁：只有一个线程获取锁时进入此状态（通过CAS对象的标记头获取锁）</li>
<li>轻量级锁：多个线程获取锁时进入此状态（通过CAS对象的标记头获取锁，获取锁失败的线程需进行自旋）</li>
<li>重量级锁：多个线程获取锁并且有线程自旋失败（10次且可配置）时进入此状态（通过操作系统的Mutex机制获取锁）</li>
</ul>
<h5 id="synchronized锁消除"><a href="#synchronized锁消除" class="headerlink" title="synchronized锁消除"></a>synchronized锁消除</h5><h5 id="synchronized锁粗化"><a href="#synchronized锁粗化" class="headerlink" title="synchronized锁粗化"></a>synchronized锁粗化</h5><h5 id="synchronized锁自旋"><a href="#synchronized锁自旋" class="headerlink" title="synchronized锁自旋"></a>synchronized锁自旋</h5><h5 id="synchronized锁疑问"><a href="#synchronized锁疑问" class="headerlink" title="synchronized锁疑问"></a>synchronized锁疑问</h5><h6 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h6><ul>
<li>synchronized可以修饰类、字段、方法，volatile只能修饰字段</li>
<li>synchronized保证原子性、可见性、有序性，volatile只保证可见性、有序性</li>
<li>synchronized会阻塞线程，volatile不会阻塞线程</li>
</ul>
<h6 id="synchronized和Lock的区别"><a href="#synchronized和Lock的区别" class="headerlink" title="synchronized和Lock的区别"></a>synchronized和Lock的区别</h6><ul>
<li>位置：<ul>
<li>synchronized是java关键字，Lock是java类</li>
</ul>
</li>
<li>实现：<ul>
<li>synchronized基于操作系统mutex机制实现，Lock基于java的AQS机制实现</li>
</ul>
</li>
<li>操作：<ul>
<li>synchronized会自动释放锁，Lock需要手动释放</li>
</ul>
</li>
<li>超时：<ul>
<li>synchronized不能设置等待超时时间，Lock可以设置等待超时时间</li>
</ul>
</li>
<li>状态：<ul>
<li>synchronized无法判断是否获取了锁，Lock可以判断是否获取了锁</li>
</ul>
</li>
<li>特性：<ul>
<li>synchronized支持重入，Lock也支持重入</li>
<li>synchronized不支持中断，Lock可支持中断（也支持不可中断）</li>
<li>synchronized不支持公平锁，Lock可支持公平锁（也支持非公平）</li>
</ul>
</li>
</ul>
<h6 id="synchronized和ReentrantLock为什么默认是非公平的"><a href="#synchronized和ReentrantLock为什么默认是非公平的" class="headerlink" title="synchronized和ReentrantLock为什么默认是非公平的"></a>synchronized和ReentrantLock为什么默认是非公平的</h6><p>因为非公平锁在释放后可以省去唤醒某个线程的开销直接让另一个线程获得锁，从而提高整体的效率</p>
<blockquote>
<p>ps：但是非公平锁可能会导致饥饿问题</p>
</blockquote>
<h6 id="ReentrantLock是如何实现公平和非公平性的"><a href="#ReentrantLock是如何实现公平和非公平性的" class="headerlink" title="ReentrantLock是如何实现公平和非公平性的"></a>ReentrantLock是如何实现公平和非公平性的</h6><ul>
<li>公平：线程在竞争锁资源的时候先判断AQS同步队列里面有没有在等待的线程，如果有的话就加入到队列的尾部等待，没有的话就直接获取锁</li>
<li>非公平：线程在竞争锁资源的时候先尝试获取锁，失败后再加入到队列的尾部等待</li>
</ul>
<h6 id="synchronized是如何保证线程安全的"><a href="#synchronized是如何保证线程安全的" class="headerlink" title="synchronized是如何保证线程安全的"></a>synchronized是如何保证线程安全的</h6><p>synchronized通过锁的互斥机制保证了原子性，使得同一时间只有一个线程能够操作资源来保证了线程安全，同时通过内存屏障来保证了线程安全中的可见性和有序性</p>
<p>synchronized的底层原理</p>
<ul>
<li>锁方法：通过方法的<code>ACC_SYNCHRONIZED</code>标识实现</li>
<li>锁代码块：通过对象的<code>monitor</code>锁和系统的<code>monitorenter</code>和<code>monitorexit</code>指令实现</li>
</ul>
<h6 id="wait和notify为什么要位于synchronized代码块中"><a href="#wait和notify为什么要位于synchronized代码块中" class="headerlink" title="wait和notify为什么要位于synchronized代码块中"></a>wait和notify为什么要位于synchronized代码块中</h6><ul>
<li>wait和notify是用来实现线程间通信的，是基于共享变量实现的</li>
<li>为了保证共享变量的线程安全，需要用synchronized来对共享变量加锁</li>
</ul>
<h4 id="ReentrantLock和ReentrantReadWriteLock"><a href="#ReentrantLock和ReentrantReadWriteLock" class="headerlink" title="ReentrantLock和ReentrantReadWriteLock"></a>ReentrantLock和ReentrantReadWriteLock</h4><h5 id="lock-lock-写在-try-代码块内部行吗"><a href="#lock-lock-写在-try-代码块内部行吗" class="headerlink" title="lock.lock() 写在 try 代码块内部行吗"></a>lock.lock() 写在 try 代码块内部行吗</h5><p>不能，如果写在try里面，当lock异常时，finally会执行unlock，unlock的时候检测到线程没有先持有锁会抛出 <code>IllegalMonitorStateException</code> 异常</p>
<h5 id="如何安全的unlock"><a href="#如何安全的unlock" class="headerlink" title="如何安全的unlock"></a>如何安全的unlock</h5><ul>
<li>用try-catch包住异常，并且不处理任何异常，不打印日志</li>
<li>可以用ReentrantLock对象的isHeldByCurrentThread方法进行判断</li>
</ul>
<blockquote>
<p>ps：并不是所有的Lock实现类都有isHeldByCurrentThread方法，所以可以统一使用try-catch包住异常</p>
</blockquote>
<h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><h5 id="CAS存在的问题"><a href="#CAS存在的问题" class="headerlink" title="CAS存在的问题"></a>CAS存在的问题</h5><ul>
<li>ABA问题：可以加版本号或者时间戳解决</li>
<li>只能保证单个变量操作的原子性：可以合并多个变量为单个对象进行操作</li>
<li>竞争激烈时大量的失败导致cpu做了很多无用功从而占用和浪费cpu资源：可以限制重试次数</li>
</ul>
<blockquote>
<p>ps：cas需要配合volatile来实现线程安全，atomic类就是这样实现的</p>
</blockquote>
<h5 id="乐观锁的优点和缺点"><a href="#乐观锁的优点和缺点" class="headerlink" title="乐观锁的优点和缺点"></a>乐观锁的优点和缺点</h5><ul>
<li>优点：避免冲突时等待造成的耗时</li>
<li>缺点：失败后需要重新处理并重试</li>
</ul>
<h5 id="自旋锁的优点和缺点"><a href="#自旋锁的优点和缺点" class="headerlink" title="自旋锁的优点和缺点"></a>自旋锁的优点和缺点</h5><ul>
<li>优点：避免上下文切换带来的耗时</li>
<li>缺点：自旋循环时间长的话会占用和浪费cpu资源</li>
</ul>
<h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><p>抽象同步器负责通用的逻辑（阻塞和唤醒、入队和出队），具体同步器负责自定义逻辑（加锁和解锁）</p>
<p>AQS的核心对象</p>
<ul>
<li>state：资源</li>
<li>CLH队列：双向链表实现的等待队列（链表结点中包含线程对象）</li>
</ul>
<blockquote>
<p>ps：CLH队列中的某个结点会自旋CAS检查前驱结点的locked状态，自旋失败后则进行阻塞并等待前驱结点唤醒</p>
</blockquote>
<p>AQS的重写方法</p>
<ul>
<li>isHeldExclusively()：该线程是否正在独占资源（只有用到Condition时才需要去实现它）</li>
<li>tryAcquire(int)：独占方式，成功则返回true，失败则返回false</li>
<li>tryRelease(int)：独占方式，成功则返回true，失败则返回false</li>
<li>tryAcquireShared(int)：共享方式，负数表示失败，0表示成功但没有剩余资源，正数表示成功且有剩余资源</li>
<li>tryReleaseShared(int)：共享方式，如果释放后允许唤醒后续等待对象则返回true，否则返回false</li>
</ul>
<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><h4 id="FutureTask的状态变化"><a href="#FutureTask的状态变化" class="headerlink" title="FutureTask的状态变化"></a>FutureTask的状态变化</h4><ul>
<li>NEW（已创建）：创建FutureTask之后</li>
<li>COMPLETING（完成中）：设置结果开始时，是一个中间过渡态</li>
<li>NORMAL（已正常完成）：设置结果（正常完成）结束后</li>
<li>EXCEPTIONAL（已异常完成）：设置结果（异常完成）结束后</li>
<li>CANCELLED（已取消）：取消任务后</li>
<li>INTERRUPTING（中断中）：中断开始时，是一个中间过渡态</li>
<li>INTERRUPTED（已断中）：中断结束后</li>
</ul>
<h4 id="FutureTask为什么支持传递给线程"><a href="#FutureTask为什么支持传递给线程" class="headerlink" title="FutureTask为什么支持传递给线程"></a>FutureTask为什么支持传递给线程</h4><p>因为FutureTask实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable接口，所以FutureTask支持传递给线程</p>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><h4 id="线程池的创建方式"><a href="#线程池的创建方式" class="headerlink" title="线程池的创建方式"></a>线程池的创建方式</h4><ul>
<li>使用Executors快速创建</li>
<li>使用ExecutorService手动创建</li>
</ul>
<p>使用Executors快速创建的方式如下</p>
<ul>
<li>Executors.newSingleThreadExecutor：队列容量无限大，容易导致内存耗尽引发OOM</li>
<li>Executors.newFixedThreadPool：队列容量无限大，容易导致内存耗尽引发OOM</li>
<li>Executors.newCachedThreadPool：线程数量无限大，容易导致内存耗尽引发OOM</li>
<li>Executors.newScheduledThreadPool：线程数量无限大，容易导致内存耗尽引发OOM</li>
<li>Executors.newSingleThreadScheduledExecutor：线程数量无限大，容易导致内存耗尽引发OOM</li>
<li>Executors.newWorkStealingPool：队列容量无限大，容易导致内存耗尽引发OOM</li>
</ul>
<h4 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h4><ul>
<li>corePoolSize：核心线程数</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程保活时间大小</li>
<li>unit：线程保活时间单位</li>
<li>workQueue：工作队列</li>
<li>threadFactory：线程工厂</li>
<li>handler：任务饱和策略处理器</li>
</ul>
<h4 id="线程池的提交策略"><a href="#线程池的提交策略" class="headerlink" title="线程池的提交策略"></a>线程池的提交策略</h4><ul>
<li><code>poolSize &lt; corePoolSize</code>时增加线程</li>
<li><code>poolSize = corePoolSize</code>时放入队列</li>
<li>队列满了之后再增加线程</li>
<li>线程达到<code>maximumPoolSize</code>后执行RejectedExecutionHandler</li>
<li>根据RejectedExecutionHandler指定的拒绝策略来处理新的任务</li>
</ul>
<h4 id="线程池的线程数量"><a href="#线程池的线程数量" class="headerlink" title="线程池的线程数量"></a>线程池的线程数量</h4><ul>
<li>如果是CPU密集型应用，则线程池大小设置为CPU核心数+1</li>
<li>如果是IO密集型应用，则线程池大小设置为2*CPU核心数+1</li>
</ul>
<h4 id="线程池的工作队列"><a href="#线程池的工作队列" class="headerlink" title="线程池的工作队列"></a>线程池的工作队列</h4><ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>SynchronousQueue</li>
<li>LinkedTransferQueue</li>
<li>PriorityBlockingQueue</li>
<li>DelayedWorkQueue</li>
<li>LinkedBlockingDeque</li>
</ul>
<h4 id="线程池的饱和策略"><a href="#线程池的饱和策略" class="headerlink" title="线程池的饱和策略"></a>线程池的饱和策略</h4><ul>
<li>AbortPolicy：丢弃任务并且抛出RejectedExecutionException异常（默认策略）</li>
<li>DiscardPolicy：丢弃任务但不抛出异常</li>
<li>DiscardOldestPolicy：丢弃最老的（队列头部）任务</li>
<li>CallerRunsPolicy：在提交的线程中直接执行任务</li>
</ul>
<h4 id="线程池的提交方式"><a href="#线程池的提交方式" class="headerlink" title="线程池的提交方式"></a>线程池的提交方式</h4><ul>
<li>使用submit方法提交（普通任务有返回值时使用）</li>
<li>使用execute方法提交（普通任务无返回值时使用）</li>
<li>使用schedule方法提交（延时任务和定时任务时使用）</li>
</ul>
<h5 id="submit和execute的区别"><a href="#submit和execute的区别" class="headerlink" title="submit和execute的区别"></a>submit和execute的区别</h5><ul>
<li>execute只支持Runnable，submit可以支持Runnable和Callable</li>
<li>execute没有返回值，submit有返回值</li>
<li>execute有异常会直接打印，submit在Future.get的时候才会打印异常</li>
</ul>
<h4 id="线程池的异常捕获"><a href="#线程池的异常捕获" class="headerlink" title="线程池的异常捕获"></a>线程池的异常捕获</h4><ul>
<li>execute方式提交时<ul>
<li>在方法内部捕获异常并处理</li>
<li>在ThreadFactory里使用Thread.setUncaughtExceptionHandler拦截处理</li>
<li>在ThreadPoolExecutor.afterExecute里面处理</li>
</ul>
</li>
<li>submit方式提交时<ul>
<li>在方法内部捕获异常并处理</li>
<li>调用Future.get的时候捕获异常并处理</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：线程池里面的某个线程异常了，线程池会移除这个线程并创建一个新的线程</p>
</blockquote>
<h4 id="线程池的关闭方式"><a href="#线程池的关闭方式" class="headerlink" title="线程池的关闭方式"></a>线程池的关闭方式</h4><ul>
<li>shutdown：线程池的状态变为SHUTDOWN，不再接受新任务了，不会终止当前正在运行的任务，还会继续处理队列里剩余的任务</li>
<li>shutdownNow：线程池的状态变为STOP，不再接受新任务了，会终止当前正在运行的任务，而且不会处理队列里剩余的任务并返回还未处理完成的任务列表</li>
</ul>
<h5 id="shutdown和shutdownNow的区别"><a href="#shutdown和shutdownNow的区别" class="headerlink" title="shutdown和shutdownNow的区别"></a>shutdown和shutdownNow的区别</h5><ul>
<li>shutdown和shutdownNow之后都不会接收新任务了</li>
<li>shutdown不会终止当前正在运行的任务，shutdownNow会终止当前正在运行的任务</li>
<li>shutdown还会继续处理队列里剩余的任务，shutdownNow不会处理队列里剩余的任务</li>
</ul>
<h4 id="线程池的状态变化"><a href="#线程池的状态变化" class="headerlink" title="线程池的状态变化"></a>线程池的状态变化</h4><p>RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED</p>
<ul>
<li>RUNNING（运行）：创建线程池后的初始状态</li>
<li>SHUTDOWN（关闭）：执行shutdown()后，不接收新任务，但会继续处理当前任务和队列里剩余的任务</li>
<li>STOP（停止）：执行shutdownNow()后，不接收新任务，且会中断当前任务和丢弃并返回队列里剩余的任务</li>
<li>TIDYING（清扫）：线程池中的任务队列为空后</li>
<li>TERMINATED（终结）：执行terminated()后</li>
</ul>
<h4 id="线程池的相关疑问"><a href="#线程池的相关疑问" class="headerlink" title="线程池的相关疑问"></a>线程池的相关疑问</h4><h5 id="线程池是如何保证核心线程不被销毁的"><a href="#线程池是如何保证核心线程不被销毁的" class="headerlink" title="线程池是如何保证核心线程不被销毁的"></a>线程池是如何保证核心线程不被销毁的</h5><p>线程池里面的线程内部是无限循环，任务执行完后不会结束，而是继续去队列里面获取任务，如果没获取到任务，就会被队列阻塞直到有新的任务可以获取</p>
<h5 id="如何知道线程池里的的任务已经完成了"><a href="#如何知道线程池里的的任务已经完成了" class="headerlink" title="如何知道线程池里的的任务已经完成了"></a>如何知道线程池里的的任务已经完成了</h5><ul>
<li>线程池内部<ul>
<li>Runnable的run方法执行完毕时，这个任务就完成了</li>
<li>Callable的call方法执行完毕时，这个任务就完成了</li>
</ul>
</li>
<li>线程池外部<ul>
<li>通过线程池的isTerminated方法可以用来判断所有的任务是否已经完成了</li>
<li>通过线程池返回的Future对象的isDone方法可以用来判断某个任务是否已经完成了</li>
<li>可以通过CountDownLatch计数器来等待相关的任务完成</li>
</ul>
</li>
</ul>
<h2 id="IO-1"><a href="#IO-1" class="headerlink" title="IO"></a>IO</h2><h3 id="IO体系相关"><a href="#IO体系相关" class="headerlink" title="IO体系相关"></a>IO体系相关</h3><p>核心接口</p>
<ul>
<li>InputStream</li>
<li>OutputStream</li>
<li>Reader</li>
<li>Writer</li>
</ul>
<p>操作分类</p>
<ul>
<li>内存</li>
<li>文件</li>
<li>管道</li>
<li>终端</li>
<li>缓冲</li>
<li>转换</li>
</ul>
<h3 id="IO模型相关"><a href="#IO模型相关" class="headerlink" title="IO模型相关"></a>IO模型相关</h3><h4 id="BIO和NIO的区别"><a href="#BIO和NIO的区别" class="headerlink" title="BIO和NIO的区别"></a>BIO和NIO的区别</h4><ul>
<li>BIO的操作是阻塞的，NIO的操作是非阻塞的</li>
<li>BIO是面向流（Stream Oriented）的，NIO是面向缓冲区（Buffer Oriented）的</li>
<li>BIO一次只能操作一个数据源，NIO一次可以操作多个数据源</li>
</ul>
<h4 id="Stream和Channel的区别"><a href="#Stream和Channel的区别" class="headerlink" title="Stream和Channel的区别"></a>Stream和Channel的区别</h4><ul>
<li>Stream是单向的（只能读或者写），Channel是双向的（既能读又能写）</li>
</ul>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><h4 id="C10K和epoll"><a href="#C10K和epoll" class="headerlink" title="C10K和epoll"></a>C10K和epoll</h4><ul>
<li>select<ul>
<li>文件描述符个数最多只能有1024个，数量少</li>
<li>监听事件时每次都需要将所有的文件描述符拷贝到内核，开销大</li>
<li>查阅事件时每次都需要遍历所有的文件描述符，开销大</li>
</ul>
</li>
<li>poll<ul>
<li>解决了文件描述符个数最多只能有1024个的限制</li>
</ul>
</li>
<li>epoll<ul>
<li>解决了文件描述符个数最多只能有1024个的限制</li>
<li>监听事件时不需要将所有的文件描述符拷贝到内核</li>
<li>查阅事件时不需要遍历所有的文件描述符</li>
</ul>
</li>
</ul>
<h3 id="IO并发模型"><a href="#IO并发模型" class="headerlink" title="IO并发模型"></a>IO并发模型</h3><h4 id="Reactor和Proactor"><a href="#Reactor和Proactor" class="headerlink" title="Reactor和Proactor"></a>Reactor和Proactor</h4><ul>
<li>Reactor：同步非阻塞IO</li>
<li>Proactor：异步非阻塞IO</li>
</ul>
<h3 id="IO设计模式"><a href="#IO设计模式" class="headerlink" title="IO设计模式"></a>IO设计模式</h3><ul>
<li>装饰器模式：FilterInputStream和FilterOutputStream</li>
<li>适配器模式：InputStreamReader和OutputStreamWriter</li>
<li>观察者模式：WatchService和Watchable</li>
</ul>
<h2 id="JVM-1"><a href="#JVM-1" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM主要组成"><a href="#JVM主要组成" class="headerlink" title="JVM主要组成"></a>JVM主要组成</h3><ul>
<li>运行时数据区（即JVM内存区域）</li>
<li>类加载子系统</li>
<li>执行引擎</li>
<li>本地库接口</li>
<li>本地方法库</li>
</ul>
<h3 id="JVM核心功能"><a href="#JVM核心功能" class="headerlink" title="JVM核心功能"></a>JVM核心功能</h3><ul>
<li>执行指令：解释和执行字节码</li>
<li>管理内存：分配和回收内存块</li>
</ul>
<h3 id="JVM运行数据分区"><a href="#JVM运行数据分区" class="headerlink" title="JVM运行数据分区"></a>JVM运行数据分区</h3><ul>
<li>线程共享<ul>
<li>方法区：包含常量池和类的元数据（放在永久代或者元空间中）</li>
<li>堆区：包含对象的数据</li>
</ul>
</li>
<li>线程私有<ul>
<li>虚拟机栈：包含局部变量和对象的引用</li>
<li>本地方法栈：</li>
<li>程序计数器：</li>
</ul>
</li>
</ul>
<h3 id="JVM内存分配策略"><a href="#JVM内存分配策略" class="headerlink" title="JVM内存分配策略"></a>JVM内存分配策略</h3><ul>
<li>堆上分配</li>
<li>栈上分配</li>
<li>TLAB上分配</li>
</ul>
<blockquote>
<p>ps：TLAB（Thread-local allocation buffer）：线程私有的内存区域</p>
</blockquote>
<h3 id="JVM垃圾数据回收"><a href="#JVM垃圾数据回收" class="headerlink" title="JVM垃圾数据回收"></a>JVM垃圾数据回收</h3><h4 id="垃圾分代技术"><a href="#垃圾分代技术" class="headerlink" title="垃圾分代技术"></a>垃圾分代技术</h4><ul>
<li>新生代（Young Generation）：属于内存中的<code>堆区</code>，包含1个 <code>Eden</code> 区和2个 <code>Survivor</code> 区</li>
<li>老年代（Old&#x2F;Tenured Generation）：属于内存中的<code>堆区</code></li>
<li>永久代（Permanent Generation）：属于内存中的<code>方法区</code></li>
</ul>
<blockquote>
<p>ps：如果只有一个Survivor区，Survivor区会存在内存碎片<br>ps：如果没有Survivor区，垃圾对象会直接进入老年代，而老年代的回收效率很低<br>ps：java8中永久代已经被元空间（Metaspace）取代了</p>
</blockquote>
<p>永久代的缺点</p>
<ul>
<li>动态生成的类及方法的信息等比较难确定其大小，容易超出永久代的限制而引发OOM</li>
<li>永久代的垃圾回收效率低下</li>
<li>永久代的字符串常量池无法回收</li>
</ul>
<h4 id="垃圾标记算法"><a href="#垃圾标记算法" class="headerlink" title="垃圾标记算法"></a>垃圾标记算法</h4><h5 id="对象存活判断方法"><a href="#对象存活判断方法" class="headerlink" title="对象存活判断方法"></a>对象存活判断方法</h5><ul>
<li>引用计数算法：不能解决循环引用的问题</li>
<li>可达性分析算法：可以解决循环引用的问题</li>
</ul>
<h5 id="对象存活标记算法"><a href="#对象存活标记算法" class="headerlink" title="对象存活标记算法"></a>对象存活标记算法</h5><ul>
<li>三色标记法（标记对象是否活着）</li>
</ul>
<h5 id="并发标记步骤"><a href="#并发标记步骤" class="headerlink" title="并发标记步骤"></a>并发标记步骤</h5><ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
<h5 id="并发标记问题"><a href="#并发标记问题" class="headerlink" title="并发标记问题"></a>并发标记问题</h5><ul>
<li>多标：某个<code>被标记为灰色的对象A</code>，在标记后<code>A的引用被断开</code>，因为A的状态已经被标记为灰色了，所以标记完成后A会被标记为<code>黑色且不可以回收</code>，然而此时A因引用被断开已变为不可达，造成了A应该回收却不会回收的问题</li>
<li>漏标：某个<code>被标记为灰色的对象A</code>，在标记后<code>A的所有引用被断开</code>，因为A的所有引用都被断开了，所以标记完成后A会被标记为<code>白色且可以回收</code>，然后此时有一个<code>被标记为黑色的对象B</code>重新引用了A，因为B为黑色代表已经标记完成，所以不会通过B重新标记A，然而此时A因被重新引用已变为可达，造成了A不该回收却被回收了的错误</li>
</ul>
<blockquote>
<p>ps：多标会造成应该回收的不被回收，问题不大，可以在下一次进行回收<br>ps：漏标会造成不该回收的被回收了，属于bug，jvm通过重新标记解决了</p>
</blockquote>
<h5 id="并发漏标解决"><a href="#并发漏标解决" class="headerlink" title="并发漏标解决"></a>并发漏标解决</h5><p>漏标形成条件</p>
<ol>
<li>至少一个有黑色对象在自己被标记之后引用了白色对象A</li>
<li>所有的灰色对象在自己引用扫描完成之前删除了对白色对象A的引用</li>
</ol>
<p>漏标解决方案</p>
<ul>
<li>增量更新算法（IU：Incremental Update）：破坏漏标形成条件1，将白色对象标记为灰色并放到Mod-Union Table中，以便重新标记阶段能够重新扫描这个对象</li>
<li>原始快照算法（SATB：Snapshot At The Beginning）：破坏漏标形成条件2，在白色对象的所有引用被删除前将白色对象标记放到线程私有的SATB Queue并汇总到全局的SATB Queue中，以便重新标记阶段能够重新扫描这个对象</li>
</ul>
<blockquote>
<p>ps：SATB比IU算法更快，因为IU需要重新扫描，SATB则是用空间换时间<br>ps：CMS用的是IU算法，G1用的是SATB算法</p>
</blockquote>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ul>
<li>标记清除算法（MarkSweep）：清除对应的内存块，有内存碎片</li>
<li>标记复制算法（MarkCopy）：复制到另一个区域，适合新生代使用</li>
<li>标记整理算法（MarkCompact）：移动到区域的一端，适合老年代使用</li>
</ul>
<blockquote>
<p>ps：新生代存活对象少，复制开销小，移动开销大，所以适合用标记复制算法<br>ps：老年代存活对象多，复制开销大，移动开销小，所以适合用标记整理算法</p>
</blockquote>
<h4 id="垃圾回收时机"><a href="#垃圾回收时机" class="headerlink" title="垃圾回收时机"></a>垃圾回收时机</h4><ul>
<li>Minor GC：回收新生代的垃圾</li>
<li>Major GC：回收老年代的垃圾</li>
<li>Full GC：回收新生代、老年代和永久代（方法区）的垃圾</li>
</ul>
<p>Minor GC的触发条件</p>
<ul>
<li>Eden区空间不足时会触发</li>
</ul>
<blockquote>
<p>ps：Survivor区空间不足不会触发Minor GC，而是将对象直接迁移到老年代</p>
</blockquote>
<p>Major GC的触发条件</p>
<ul>
<li>老年代空间不足时触发</li>
</ul>
<blockquote>
<p>ps：Major GC执行时通常会先执行一次着Minor GC</p>
</blockquote>
<p>Full GC的触发条件</p>
<ul>
<li>调用System.gc时，建议系统执行Full GC，但是不一定要执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
</ul>
<h4 id="垃圾回收过程"><a href="#垃圾回收过程" class="headerlink" title="垃圾回收过程"></a>垃圾回收过程</h4><ul>
<li>新创建的对象会放到Eden区</li>
<li>Eden区满了会触发Minor GC的触发条件</li>
<li>经过扫描和标记后，将Eden区和S0区中的存活对象的年龄加1并进行移动</li>
<li>如果对象的年龄超限了（默认为15），则将对象移动到老年代</li>
<li>如果S1区满了或者剩余空间不足，则将对象移动到老年代</li>
<li>如果S1区没有满并且剩余空间充足，则将对象移动到S1区，并调换S0和S1区</li>
</ul>
<h4 id="垃圾回收器分类"><a href="#垃圾回收器分类" class="headerlink" title="垃圾回收器分类"></a>垃圾回收器分类</h4><ul>
<li>新生代<ul>
<li>Serial：<code>串行回收器</code>，使用<code>标记复制算法</code></li>
<li>PN（ParNew）：<code>并行回收器</code>，使用<code>标记复制算法</code>，Serial的<code>多线程版本</code></li>
<li>PS（Parallel Scavenge）：<code>并行回收器</code>，使用<code>标记复制算法</code>，追求<code>最大吞吐量</code></li>
</ul>
</li>
<li>老年代<ul>
<li>Serial Old：<code>串行回收器</code>，使用<code>标记整理算法</code>，Serial的<code>老年代版本</code></li>
<li>CMS（Concurrent Mark Sweep）：<code>并发回收器</code>，使用<code>标记清除算法</code>，追求<code>最短停顿时间</code></li>
<li>Parallel Old：<code>并行回收器</code>，使用<code>标记整理算法</code>，Parallel Scavenge的<code>老年代版本</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>ps： <code>吞吐量</code> 是指用户线程时间除以总时间（用户线程时间和GC线程时间之和）的比值，因为总时间固定，则GC线程时间越少，用户线程时间越多，吞吐量越高<br>ps： <code>停顿时间</code> 是指用户线程被暂停（STW）的时间<br>ps：Parallel Scavenge是通过 <code>增大内存空间</code> 和 <code>减少垃圾回收次数</code> 的方式来 <code>提高吞吐量</code> 的<br>ps：Concurrent Mark Sweep是通过 <code>并发标记</code> 的方式来 <code>减少停顿时间</code> 的<br>ps：追求 <code>最短停顿时间</code> 的适合 <code>用户交互型</code> 的应用，追求 <code>最大吞吐量</code> 的适合 <code>后台计算型</code> 的应用</p>
</blockquote>
<p>支持并发标记的垃圾回收器</p>
<ul>
<li>CMS（Concurrent Mark Sweep）</li>
<li>G1（Garbage First）</li>
</ul>
<h5 id="新生代垃圾回收器对比"><a href="#新生代垃圾回收器对比" class="headerlink" title="新生代垃圾回收器对比"></a>新生代垃圾回收器对比</h5><ul>
<li>Serial：单线程标记，单线程回收，全程STW</li>
<li>PN（ParNew）：多线程标记，多线程回收，全程STW，Serial的<code>多线程版本</code></li>
<li>PS（Parallel Scavenge）：多线程标记，多线程回收，全程STW，追求<code>最大吞吐量</code></li>
</ul>
<h5 id="老生代垃圾回收器对比"><a href="#老生代垃圾回收器对比" class="headerlink" title="老生代垃圾回收器对比"></a>老生代垃圾回收器对比</h5><ul>
<li>Serial Old：单线程标记，单线程回收，全程STW</li>
<li>CMS（Concurrent Mark Sweep）：初始标记时单线程，并发标记时多线程，重新标记时单线程，并发清除时多线程，初始标记和重新标记时会STW，并发标记和并发清除时不会STW，追求<code>最短停顿时间</code></li>
<li>Parallel Old：多线程标记，多线程回收，全程STW，Parallel Scavenge的<code>老年代版本</code></li>
</ul>
<h5 id="主要垃圾回收器的特点"><a href="#主要垃圾回收器的特点" class="headerlink" title="主要垃圾回收器的特点"></a>主要垃圾回收器的特点</h5><ul>
<li>Parallel Scavenge<ul>
<li>优点<ul>
<li>相比于ParNew支持控制停顿时间和吞吐量</li>
<li>相比于ParNew多了自适应调节策略</li>
</ul>
</li>
<li>缺点<ul>
<li>相比于ParNew需要消耗更多的系统资源</li>
</ul>
</li>
</ul>
</li>
<li>CMS<ul>
<li>优点<ul>
<li>相比于Parallel Scavenge的停顿时间更短</li>
</ul>
</li>
<li>缺点<ul>
<li>相比于Parallel Scavenge的吞吐量更低</li>
<li>并发标记时多标的问题会产生浮动垃圾</li>
<li>使用的标记清除回收算法会导致内存碎片</li>
</ul>
</li>
</ul>
</li>
<li>G1<ul>
<li>优点<ul>
<li>相比于CMS使用了分区和标记整理算法解决了内存碎片的问题</li>
<li>相比于CMS可以更好的控制停顿时间</li>
<li>相比于CMS可以处理更大的内存堆</li>
</ul>
</li>
<li>缺点<ul>
<li>相比于CMS需要消耗更多的系统资源</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="垃圾回收器搭配"><a href="#垃圾回收器搭配" class="headerlink" title="垃圾回收器搭配"></a>垃圾回收器搭配</h4><ul>
<li>Serial Old可以和Serial、PN（ParNew）、PS（Parallel Scavenge）搭配</li>
<li>CMS（Concurrent Mark Sweep）可以和Serial、PN（ParNew）搭配</li>
<li>Parallel Old只能和PS（Parallel Scavenge）搭配</li>
</ul>
<h3 id="JVM类"><a href="#JVM类" class="headerlink" title="JVM类"></a>JVM类</h3><h4 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h4><h5 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h5><ul>
<li>自举加载器：Bootstrap ClassLoader，负责加载<code>JAVA_HOME/jre/lib</code>目录中的jar包（rt.jar）</li>
<li>扩展加载器：Extension ClassLoader，负责加载 <code>JAVA_HOME/jre/lib/ext</code>目录中的jar包</li>
<li>应用加载器：Application ClassLoader，负责加载<code>classpath</code>目录中的jar包</li>
<li>自定义加载器：Custom ClassLoader，可以自己定义加载逻辑</li>
</ul>
<h5 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h5><ul>
<li>加载（load）：将类文件的数据加载到内存中</li>
<li>链接（link）：<ul>
<li>验证（verify）：检查类文件数据是否符合规范和要求</li>
<li>准备（prepare）：为类成员分配内存和设置默认值</li>
<li>解析（resolve）：将符号引用替换为地址引用</li>
</ul>
</li>
<li>初始化（initiate）：静态变量初始化和静态代码块初始化</li>
<li>使用（use）：使用</li>
<li>卸载（unload）：将类文件的数据从内存中卸载</li>
</ul>
<h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><h5 id="双亲委派机制的作用"><a href="#双亲委派机制的作用" class="headerlink" title="双亲委派机制的作用"></a>双亲委派机制的作用</h5><ul>
<li>保证系统类先加载，避免攻击者替换系统类进行破坏活动</li>
<li>避免重复加载，前面的加载器加载后自己就不需要加载了</li>
</ul>
<h5 id="为什么有时候要打破双亲委派机制"><a href="#为什么有时候要打破双亲委派机制" class="headerlink" title="为什么有时候要打破双亲委派机制"></a>为什么有时候要打破双亲委派机制</h5><ul>
<li>jdbc的DriverManager是由自举加载器加载的，而第三方厂商的DriverManager的实现类则是由应用加载器加载的，由于应用程序类加载器加载的类对启动类加载器是不可见的，导致找不到DriverManager的实现类，此时就需要打破双亲委派机制</li>
<li>web容器中可以存放多个应用，而这些应用可能会使用版本不同的同名类，而双亲委派机制只会加载第一个同名类，所以就需要对应用的类进行隔离，此时就需要打破双亲委派机制</li>
</ul>
<h5 id="如何打破双亲委派机制"><a href="#如何打破双亲委派机制" class="headerlink" title="如何打破双亲委派机制"></a>如何打破双亲委派机制</h5><ul>
<li>重写ClassLoader的loadClass自定义加载过程</li>
<li>利用Thread.currentThread().getContextClassLoader()返回的ClassLoader加载</li>
<li>利用java的SPI机制</li>
</ul>
<blockquote>
<p>ps：重写findClass方法可以自定义类加载过程，但不能打破双亲委派机制</p>
</blockquote>
<h3 id="JVM对象"><a href="#JVM对象" class="headerlink" title="JVM对象"></a>JVM对象</h3><h4 id="对象生命周期"><a href="#对象生命周期" class="headerlink" title="对象生命周期"></a>对象生命周期</h4><ul>
<li>实例化（Instantiation）</li>
<li>初始化（Initialization）</li>
<li>构造（Constrction）</li>
<li>使用（Usage）</li>
<li>析构（Destruction）</li>
</ul>
<blockquote>
<p>ps： <code>实例化（instantiation）</code> 和 <code>初始化（initialization）</code> 不是同一个概念，实例化会 <code>分配内存</code> 和设置 <code>默认值</code> ，初始化会设置 <code>初始值</code></p>
</blockquote>
<blockquote>
<p>ps： <code>默认值（default）</code> 和 <code>初始值（initial）</code> 不是同一个概念，比如int的 <code>默认值</code> 为 <code>0</code> ， <code>初始值</code> 可以为 <code>100</code></p>
</blockquote>
<h4 id="对象初始化过程"><a href="#对象初始化过程" class="headerlink" title="对象初始化过程"></a>对象初始化过程</h4><ol>
<li>父类静态变量和代码块</li>
<li>子类静态变量和代码块</li>
<li>父类非静态变量和代码块</li>
<li>父类构造函数</li>
<li>子类非静态变量和代码块</li>
<li>子类构造函数</li>
</ol>
<h4 id="对象内存结构"><a href="#对象内存结构" class="headerlink" title="对象内存结构"></a>对象内存结构</h4><h5 id="一个空Object对象占多大的空间"><a href="#一个空Object对象占多大的空间" class="headerlink" title="一个空Object对象占多大的空间"></a>一个空Object对象占多大的空间</h5><ul>
<li>在开启了压缩指针的情况下，Object 默认会占用 12 个字节，但是为了避免伪共享问题，JVM 会按照 8 个字节的倍数进行填充，所以会填充 4 个字节变成 16 个字节长度。</li>
<li>在关闭了压缩指针的情况下，Object 默认会占用 16 个字节，16 个字节正好是 8 的整数倍，因此不需要填充</li>
</ul>
<h3 id="JVM问题排查"><a href="#JVM问题排查" class="headerlink" title="JVM问题排查"></a>JVM问题排查</h3><p>jvm常见问题</p>
<ul>
<li>OOM</li>
<li>cpu占用高</li>
<li>死锁</li>
</ul>
<p>jvm问题排查工具</p>
<p>jmap：排查内存问题（OOM）<br>jstack：排查线程问题（CPU负载高和死锁）</p>
<p>jvm问题排查过程</p>
<ul>
<li>OOM问题排查<ul>
<li>查看内存的统计信息：<code>jmap -histo pid</code>，可以看出当前哪个对象最消耗内存</li>
<li>查看内存的详细信息：<code>jmap -heap pid</code>，可以查看内存的配置和使用情况</li>
<li>导出内存的详细信息：<code>jmap -dump:file=a.dump pid</code>，然后导入到<code>jvisualvm</code>中进行分析</li>
</ul>
</li>
<li>CPU负载高问题排查<ul>
<li>找出cpu占用飚高进程：<code>top</code>，然后按<code>P</code>键后按照CPU负载排序并找导致cpu占用飚高的进程id</li>
<li>找出cpu占用飚高线程：<code>top -H -p pid</code>，找出导致cpu占用飚高的线程id</li>
<li>将线程id转化为十六进制：使用python的<code>hex</code>函数或者其他支持进制转换工具</li>
<li>查看cpu占用飚高线程的堆栈信息：<code>jstack pid | grep -A 10 tid（十六进制的线程id）</code></li>
<li>堆栈信息中会显示线程停留在代码的哪一行</li>
</ul>
</li>
<li>死锁问题排查<ul>
<li>用jstack查看是否有deadlock字样</li>
<li>用jvisualvm查看是否有死锁</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：pid（进程id），tid（线程id）</p>
</blockquote>
<p>TODO：cpu占用高<br>TODO：内存泄露和内存溢出<br>TODO：死锁</p>
<h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p>JMM内存模型的作用：定义了线程和主内存之间的操作和关系</p>
<ul>
<li>三大特性是基本原则</li>
<li>as-if-serial和happens-before是指导思想</li>
<li>内存屏障是实现手段</li>
</ul>
<p>TODO：as-if-serial<br>TODO：happens-before<br>TODO：内存屏障</p>
<h4 id="线程安全的三大原则"><a href="#线程安全的三大原则" class="headerlink" title="线程安全的三大原则"></a>线程安全的三大原则</h4><ul>
<li>原子性：通过互斥机制实现，来解决资源的互斥使用问题</li>
<li>可见性：通过内存屏障实现，解决数据的一致性问题</li>
<li>有序性：通过内存屏障实现，解决指令的重排序问题</li>
</ul>
<blockquote>
<p>ps：内存屏障存在的意义就是为了解决程序在运行过程中出现的内存访问乱序的问题<br>ps：内存屏障是靠cpu的lock前缀指令实现的</p>
</blockquote>
<h4 id="happens-before的8大原则"><a href="#happens-before的8大原则" class="headerlink" title="happens-before的8大原则"></a>happens-before的8大原则</h4><p>as-if-serial：单线程原则，无论如何重排序，程序执行的结果都应该与代码顺序执行的结果一致<br>happens-before：多线程原则，在发生操作B之前，操作A产生的影响都能被操作B观察到</p>
<p>happens-before的8大原则</p>
<ul>
<li>单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作</li>
<li>lock的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作</li>
<li>volatile的happen-before原则： 对一个volatile变量的写操作happen-before对此变量的任意操作</li>
<li>线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法</li>
<li>线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断的代码</li>
<li>线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测</li>
<li>对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用</li>
<li>happen-before的传递性原则： 如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作</li>
</ul>
<h4 id="JMM的8种原子操作"><a href="#JMM的8种原子操作" class="headerlink" title="JMM的8种原子操作"></a>JMM的8种原子操作</h4><p>JMM的8种原子操作</p>
<ul>
<li>lock(锁定)：<ul>
<li>对象：作用于<code>主内存</code></li>
<li>作用：对变量进行<code>加锁</code></li>
</ul>
</li>
<li>unlock(解锁)：<ul>
<li>对象：作用于<code>主内存</code></li>
<li>作用：对变量进行<code>解锁</code></li>
</ul>
</li>
<li>read(读取)：<ul>
<li>对象：作用于<code>主内存</code></li>
<li>作用：将变量的值从<code>主内存</code>传输到<code>工作内存</code>中</li>
</ul>
</li>
<li>load(载入)：<ul>
<li>对象：作用于<code>工作内存</code></li>
<li>作用：将变量的值<code>加载</code>到<code>工作内存</code>中的变量副本中</li>
</ul>
</li>
<li>use(使用)：<ul>
<li>对象：作用于<code>工作内存</code></li>
<li>作用：执行引擎<code>使用</code>变量的值</li>
</ul>
</li>
<li>assign(赋值)：<ul>
<li>对象：作用于<code>工作内存</code></li>
<li>作用：执行引擎<code>设置</code>变量的值</li>
</ul>
</li>
<li>store(存储)：<ul>
<li>对象：作用于<code>工作内存</code></li>
<li>作用：将变量的值从<code>工作内存</code>传输到<code>主内存</code>中</li>
</ul>
</li>
<li>write(写入)：<ul>
<li>对象：作用于<code>主内存</code></li>
<li>作用：将变量的值<code>写入</code>到<code>主内存</code>中的变量中</li>
</ul>
</li>
</ul>
<p>JMM的8种操作要求</p>
<ul>
<li>操作要完整<ul>
<li>read和load操作必须同时出现且必须顺序执行（不是连续执行），store和write同理</li>
<li>即不允许变量从主存读取时工作内存却不接受或者从工作内存写入时主存却不接受的情况</li>
</ul>
</li>
<li>变更必须同步<ul>
<li>不允许线程丢弃它的最近的assign操作</li>
<li>即变量在工作内存中改变了就必须同步回主内存</li>
</ul>
</li>
<li>未变更不允许同步<ul>
<li>不允许线程无原因地（比如没有发生过assign操作）将数据从工作内存同步回主内存中</li>
<li>即变量在工作内存中未改变就不能同步回主内存</li>
</ul>
</li>
<li>不能使用未初始化的变量<ul>
<li>不允许在工作内存中直接使用一个未被初始化（load或assign）的变量</li>
<li>即对一个变量实施use和store操作之前必须先执行过了load和assign操作</li>
</ul>
</li>
<li>lock需要支持可重入<ul>
<li>一个变量在同一个时刻只允许一条线程对其执行lock操作，但lock操作可以被同一个条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁</li>
</ul>
</li>
<li>lock时需要将工作内存中的变量副本清空<ul>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值</li>
</ul>
</li>
<li>unlock之前得先执行过lock<ul>
<li>如果一个变量实现没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量</li>
</ul>
</li>
<li>unlock时需要将工作内存中的变量副本同步回主内存中<ul>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存（执行store和write操作）</li>
</ul>
</li>
</ul>
<h1 id="java面试总结（通用篇）"><a href="#java面试总结（通用篇）" class="headerlink" title="java面试总结（通用篇）"></a>java面试总结（通用篇）</h1><h2 id="Spring-2"><a href="#Spring-2" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring-3"><a href="#Spring-3" class="headerlink" title="Spring"></a>Spring</h3><h4 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h4><h5 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h5><h6 id="Spring的bean对象的三种注册方式"><a href="#Spring的bean对象的三种注册方式" class="headerlink" title="Spring的bean对象的三种注册方式"></a>Spring的bean对象的三种注册方式</h6><p>三种注册方式</p>
<ul>
<li>基于xml文件：ApplicationContext类 + applicationContext.xml</li>
<li>基于java注解：@Component、@Controller、@Service、@Repository</li>
<li>基于java配置类：@Configuration + @Bean、@Configuration + @Import</li>
<li>使用ImportSelector进行注册</li>
<li>使用ImportBeanDefinitionRegistrar进行注册</li>
<li>使用FactoryBean进行注册</li>
</ul>
<blockquote>
<p>ps：@Configuration上有@Component，所以使用组件扫描（@ComponentScan）时会自动注册到容器<br>ps：@Component是用来注册自己的bean的，@Configuration是用来注册第三方的bean的</p>
</blockquote>
<h6 id="Spring的bean依赖的三种注入方式"><a href="#Spring的bean依赖的三种注入方式" class="headerlink" title="Spring的bean依赖的三种注入方式"></a>Spring的bean依赖的三种注入方式</h6><ul>
<li>field注入：字段注入（不推荐）</li>
<li>setter注入：setter注入</li>
<li>constructor注入：构造器注入</li>
</ul>
<p>####### field注入的问题</p>
<ul>
<li>破坏对象的隐私和封装特性</li>
<li>可能会导致循环依赖（Spring不能解决非单例bean的循环依赖）</li>
<li>无法对static变量进行注入（因为static变量属于类不属于对象）</li>
<li>无法对final变量进行注入（因为final变量只能在声明或者构造的时候赋值）</li>
<li>手动创建的对象的依赖不会注入，使用时会导致空指针错误</li>
</ul>
<p>####### setter注入的问题</p>
<ul>
<li>手动创建的对象的依赖不会注入，使用时会导致空指针错误</li>
</ul>
<h6 id="Spring自动装配"><a href="#Spring自动装配" class="headerlink" title="Spring自动装配"></a>Spring自动装配</h6><p>@Autowired的装配查找逻辑如下</p>
<ul>
<li>先按照byType的方式进行匹配</li>
<li>如果匹配了多个，则又按照byName的方式进行匹配</li>
<li>如果没匹配到，则抛出异常</li>
</ul>
<p>@Resource的装配查找逻辑如下</p>
<ul>
<li>如果同时指定了name和type，name和type必须同时匹配</li>
<li>如果只指定了name，只会按照byName的方式进行匹配</li>
<li>如果只指定了type，只会按照byType的方式进行匹配</li>
<li>否则先按照byName的方式进行匹配，找不到时再按byType的方式进行匹配</li>
<li>如果匹配了多个或者没匹配到，则抛出异常</li>
</ul>
<blockquote>
<p>ps：byName的方式不会找到多个，因为name（bean id）在容器中必须是唯一的</p>
</blockquote>
<h6 id="Spring懒加载"><a href="#Spring懒加载" class="headerlink" title="Spring懒加载"></a>Spring懒加载</h6><p>懒加载实现的关键对象</p>
<ul>
<li>ProxyFactory</li>
<li>TargetSource</li>
</ul>
<blockquote>
<p>ps：Lazy是通过代理实现的，调用方法时实际上调用的是代理对象的代理方法，代理方法会调用时会通过 <code>targetSource.getTarget</code> 触发 <code>beanFactory.doResolveDependency</code> 的调用来完成目标对象的创建和缓存</p>
</blockquote>
<h6 id="Spring循环依赖"><a href="#Spring循环依赖" class="headerlink" title="Spring循环依赖"></a>Spring循环依赖</h6><p>循环依赖解决的关键对象</p>
<ul>
<li>Map</li>
<li>ObjectFactory</li>
</ul>
<blockquote>
<p>ps：单例对象创建后会缓存在Map中</p>
</blockquote>
<p>####### 循环依赖和注入方式</p>
<ul>
<li><code>单例bean</code>时<code>字段注入</code>和<code>setter注入</code>可以通过三级缓存解决循环依赖</li>
<li><code>单例bean</code>时<code>构造器注入</code>不能解决循环依赖，因为会导致构造函数的循环调用</li>
<li><code>非单例bean</code>时任何注入方式都不能解决循环依赖，因为非单例bean不会进行缓存</li>
</ul>
<p>####### 循环依赖和解决办法</p>
<ul>
<li><code>构造器注入</code> 可以改成 <code>setter注入</code> 或者 <code>字段注入</code></li>
<li>使用 <code>@Lazy延迟加载</code></li>
</ul>
<p>####### 循环依赖和三级缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="comment">// 单例对象的cache：一级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="comment">// 提前暴光的单例对象的Cache：二级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line"><span class="comment">// 单例对象工厂的cache：三级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>第三级缓存：存放bean对象的创建工厂（ObjectFactory）</li>
<li>第二级缓存：存放已<code>代理过</code>的bean对象（Object）</li>
<li>第一级缓存：存放已<code>初始化</code>的bean对象（Object）</li>
</ul>
<p>第二级缓存的作用</p>
<ul>
<li>提前生成代理对象并注入到依赖中</li>
</ul>
<blockquote>
<p>ps：当存在 <code>循环依赖时</code> 需要提前生成代理对象进行注入，而不是注入目标对象<br>ps：当存在 <code>循环依赖时</code> 会提前生成代理对象，否则则在 <code>初始化完成后</code> 生成代理对象</p>
</blockquote>
<h5 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h5><h6 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h6><ul>
<li>singleton：单例模式，全局只有一个</li>
<li>prototype：原型模式，每次使用时都创建一个新的Bean实例</li>
<li>request：每个请求一个，Web应用中有效</li>
<li>session：每个会话一个，Web应用中有效</li>
<li>globalsession：类似session，只有对portlet才有意义</li>
</ul>
<blockquote>
<p>ps：requestScope的bean是基于ThreadLocal实现的<br>ps：sessionScope的bean是基于sessionId和Map实现的</p>
</blockquote>
<h6 id="bean的线程安全"><a href="#bean的线程安全" class="headerlink" title="bean的线程安全"></a>bean的线程安全</h6><p>bean不是线程安全的</p>
<h6 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h6><p>####### bean的生命周期概览</p>
<ol>
<li>bean实例化</li>
<li>bean属性填充</li>
<li>bean初始化</li>
<li>bean使用</li>
<li>bean销毁</li>
</ol>
<blockquote>
<p>ps：bean实例化后会放入到（三级）缓存中</p>
</blockquote>
<p>####### bean的生命周期详述</p>
<ol>
<li>instantiateBean：bean实例化</li>
<li>populateBean：bean属性填充</li>
</ol>
<ul>
<li>调用BeanNameAware.setBeanName</li>
<li>调用BeanFactoryAware.setBeanFactory</li>
<li>调用ApplicationContextAware.setApplicationContext</li>
</ul>
<ol start="3">
<li>initializeBean：bean初始化</li>
</ol>
<ul>
<li>调用BeanPostProcessor.postProcessBeforeInitialization</li>
<li>调用@PostConstruct注解标注的方法</li>
<li>调用InitializingBean.afterPropertiesSet</li>
<li>调用bean的init-method</li>
<li>调用BeanPostProcessor.postProcessAfterInitialization</li>
</ul>
<ol start="4">
<li>useBean：bean使用</li>
<li>destoryBean：bean销毁</li>
</ol>
<ul>
<li>调用@PreDestroy注解标注的方法</li>
<li>调用DisposableBean.destory</li>
<li>调用bean的destory-method</li>
</ul>
<blockquote>
<p>ps：bean实例化后会放入到（三级）缓存中</p>
</blockquote>
<h5 id="IOC-1"><a href="#IOC-1" class="headerlink" title="IOC"></a>IOC</h5><ul>
<li>IOC容器的接口类<ul>
<li>BeanFactory</li>
<li>BeanDefinition</li>
</ul>
</li>
<li>IOC容器的实现类<ul>
<li>AnnotationConfigApplicationContext</li>
<li>ClassPathXmlApplicationContext</li>
<li>FileSystemXmlApplicationContext</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：实现类分为独立版和web版</p>
</blockquote>
<h6 id="IOC容器的初始化过程"><a href="#IOC容器的初始化过程" class="headerlink" title="IOC容器的初始化过程"></a>IOC容器的初始化过程</h6><p>####### IOC容器的初始化概览</p>
<ul>
<li>将bean的配置信息解析成BeanDefinition并放到BeanDefinitionMap中</li>
<li>根据BeanDefinition创建bean对象并进行依赖注入</li>
</ul>
<p>####### IOC容器的初始化详述</p>
<ul>
<li>prepareRefresh：context刷新前的预处理</li>
<li>obtainFreshBeanFactory：加载BeanFactory（默认实现是DefaultListableBeanFactory）</li>
<li>refreshBeanFactory：刷新BeanFactory</li>
<li>prepareBeanFactory：BeanFactory的预处理工作</li>
<li>postProcessBeanFactory：BeanFactory的后处理工作</li>
<li>invokeBeanFactoryPostProcessors：实例化实现了BeanFactoryPostProcessor接口的Bean并调用接口方法</li>
<li>registerBeanPostProcessors：注册BeanPostProcessor(Bean的后置处理器，在创建Bean的前后等执行)</li>
<li>initMessageSource：初始化MessageSource组件（做国际化功能：消息绑定，消息解析）</li>
<li>initApplicationEventMulticaster：初始化事件派发器</li>
<li>onRefresh：context的刷新回调，子类可以重写这个方法在容器刷新的时候可以自定义逻辑</li>
<li>registerListeners：注册应用的监听器，就是注册实现了ApplicationListener接口的监听器Bean</li>
<li>finishBeanFactoryInitialization：初始化所有的剩下的非懒加载的单例bean，并填充属性</li>
<li>finishRefresh：完成context的刷新</li>
</ul>
<h6 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h6><ul>
<li>BeanFactory：IOC容器的底层接口</li>
<li>FactoryBean：一种特殊的bean，getBean时会返回FactoryBean持有的bean</li>
</ul>
<blockquote>
<p>ps：Spring默认使用反射机制来创建Bean，可以使用FactoryBean来自定义创建过程<br>ps：getBean时如果需要返回FactoryBean本身，id前面需要添加 <code>&amp;</code> 符号</p>
</blockquote>
<h6 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h6><ul>
<li>BeanFactory：IOC容器的底层接口</li>
<li>ApplicationContext：IOC容器的高级接口，是BeanFactory的子接口，支持更多的功能</li>
</ul>
<h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><h5 id="AOP的核心概念"><a href="#AOP的核心概念" class="headerlink" title="AOP的核心概念"></a>AOP的核心概念</h5><p>AOP的核心概念</p>
<ul>
<li>JoinPoint（连接点）：任何可以切入的地方（比如java对象中的字段和方法）</li>
<li>Pointcut（切点）：实际需要切入的地方的匹配规则</li>
<li>Advice（通知）：切入后要做的事情</li>
<li>Aspect（切面）：切点和通知的组合</li>
<li>Target（目标）：被代理的对象</li>
<li>Proxy（代理）：代理后的对象</li>
<li>Weaving（织入）：将通知添加到切点上的实现过程</li>
<li>Introduction（引入）：特殊的通知（可以为目标添加一些额外的属性和方法）</li>
</ul>
<h5 id="AOP的通知顺序"><a href="#AOP的通知顺序" class="headerlink" title="AOP的通知顺序"></a>AOP的通知顺序</h5><p>AOP的通知顺序（Spring5）</p>
<ol>
<li>@AroundBefore</li>
<li>@Before</li>
<li>doSomething</li>
<li>@AfterReturning | @AfterThrowing</li>
<li>@After</li>
<li>@AroundAfter</li>
</ol>
<h5 id="AOP的使用场景"><a href="#AOP的使用场景" class="headerlink" title="AOP的使用场景"></a>AOP的使用场景</h5><p>AOP的使用场景</p>
<ul>
<li>权限校验</li>
<li>日志记录</li>
<li>耗时统计</li>
<li>异常处理</li>
<li>重试管理</li>
<li>事务管理</li>
<li>缓存管理</li>
</ul>
<h5 id="AOP的失效场景"><a href="#AOP的失效场景" class="headerlink" title="AOP的失效场景"></a>AOP的失效场景</h5><p>AOP的失效场景</p>
<ul>
<li>代理的方法被同类的方法调用</li>
<li>代理的方法不能被外部访问（private方法、protected方法）</li>
<li>代理的方法不能被重写（final方法、static方法）</li>
<li>代理的类不能被继承（final类）</li>
<li>代理的类没有被Spring管理</li>
<li>代理的对象是用户手动创建的</li>
</ul>
<blockquote>
<p>ps：JDK动态代理和CGLIB动态代理不能够代理 <code>不能继承的类</code> 和 <code>不能重写的方法</code> ，因为是通过生成子类并重写方法来实现的<br>ps：JDK动态代理和CGLIB动态代理不支持代理private方法，但AspectJ静态代理支持代理private方法<br>ps：JDK动态代理和CGLIB动态代理支持代理protected方法，但SpringAOP只会拦截public方法（因为AopUtils.canApply方法中使用的Class.getMethods只能获取public方法）</p>
</blockquote>
<h5 id="AOP的代理实现"><a href="#AOP的代理实现" class="headerlink" title="AOP的代理实现"></a>AOP的代理实现</h5><ul>
<li>静态代理：编译时生成代理类<ul>
<li>AspectJ：可以代理所有类</li>
</ul>
</li>
<li>动态代理：运行时生成代理类<ul>
<li>JDK动态代理：只能对基于接口的类进行代理，不能对没有基于接口的类进行代理</li>
<li>CGLIB动态代理：可以代理所有类</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：当 <code>没有实现接口</code> 或者 <code>optimize配置为true</code> 或者 <code>proxy-target-class配置为true</code> 时会使用CGLIB动态代理，否则使用JDK动态代理</p>
</blockquote>
<ul>
<li>提前生成代理对象：存在循环依赖时，在实例化（instantiateBean）的时候生成</li>
<li>非提前生成代理对象：不存在循环依赖时，在初始化（initializeBean）的时候生成</li>
</ul>
<blockquote>
<p>ps：代码入口为 <code>AbstractAutowireCapableBeanFactory.doCreateBean</code></p>
</blockquote>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><h5 id="Spring代理的实现方式"><a href="#Spring代理的实现方式" class="headerlink" title="Spring代理的实现方式"></a>Spring代理的实现方式</h5><ul>
<li>静态代理：编译时生成代理类<ul>
<li>AspectJ：可以代理所有类</li>
</ul>
</li>
<li>动态代理：运行时生成代理类<ul>
<li>JDK动态代理：只能对基于接口的类进行代理，不能对没有基于接口的类进行代理</li>
<li>CGLIB动态代理：可以代理所有类</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：当 <code>没有实现接口</code> 或者 <code>optimize配置为true</code> 或者 <code>proxy-target-class配置为true</code> 时会使用CGLIB动态代理，否则使用JDK动态代理</p>
</blockquote>
<h5 id="Spring代理的生成时机"><a href="#Spring代理的生成时机" class="headerlink" title="Spring代理的生成时机"></a>Spring代理的生成时机</h5><ul>
<li>提前生成代理对象：存在循环依赖时，在实例化（instantiateBean）的时候生成</li>
<li>非提前生成代理对象：不存在循环依赖时，在初始化（initializeBean）的时候生成</li>
</ul>
<blockquote>
<p>ps：代码入口为 <code>AbstractAutowireCapableBeanFactory.doCreateBean</code></p>
</blockquote>
<h3 id="SpringBoot-1"><a href="#SpringBoot-1" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><h4 id="SpringBoot和Spring的区别"><a href="#SpringBoot和Spring的区别" class="headerlink" title="SpringBoot和Spring的区别"></a>SpringBoot和Spring的区别</h4><p>SpringBoot新增主要特性</p>
<ul>
<li>起步依赖：简化了pom文件中依赖的配置（利用maven的依赖传递通过Starter引入相关的依赖）</li>
<li>自动配置：简化了bean对象的声明和注入（基于Spring的Import机制实现）</li>
<li>条件配置：@Condition</li>
</ul>
<h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="SpringBootConfiguration"></a>SpringBootConfiguration</h4><p>@SpringBootApplication由以下三个注解组成</p>
<ul>
<li>@SpringBootConfiguration：被@Configuration注解所标注，和@Configuration没区别</li>
<li>@EnableAutoConfiguration：自动和有条件的加载工程里面的<code>依赖的</code>组件和配置</li>
<li>@ComponentScan：加载自己工程里面的<code>自己的</code>组件和配置</li>
</ul>
<blockquote>
<p>ps：@Configuration是不会被@EnableAutoConfiguration和@ComponentScan重复加载，因为@EnableAutoConfiguration和@ComponentScan的加载范围不同</p>
</blockquote>
<h5 id="AutoConfiguration"><a href="#AutoConfiguration" class="headerlink" title="AutoConfiguration"></a>AutoConfiguration</h5><ul>
<li><code>@EnableAutoConfiguration</code>通过<code>@Import(AutoConfigurationImportSelector.class)</code>自动和有条件的加载所有依赖包里的配置</li>
<li><code>AutoConfigurationImportSelector</code>通过<code>SpringFactoriesLoader.loadFactoryNames</code>加载<code>META-INF/spring.factories</code>资源文件里面指定的配置类</li>
<li><code>SpringFactoriesLoader.loadFactoryNames</code>通过<code>ClassLoader.getResources</code>获取classpath中<code>META-INF/spring.factories</code>资源文件</li>
</ul>
<h4 id="SpringBootStarter"><a href="#SpringBootStarter" class="headerlink" title="SpringBootStarter"></a>SpringBootStarter</h4><ul>
<li>起步依赖：利用maven的依赖传递通过Starter引入相关的依赖</li>
<li>自动配置：应用启动时会通过 <code>@SpringBootApplication</code> 里的 <code>@EnableAutoConfiguration</code> 自动和有条件的加载所有依赖包里的组件和配置</li>
</ul>
<h3 id="SpringWeb-1"><a href="#SpringWeb-1" class="headerlink" title="SpringWeb"></a>SpringWeb</h3><h4 id="Mvc"><a href="#Mvc" class="headerlink" title="Mvc"></a>Mvc</h4><h5 id="请求流程描述"><a href="#请求流程描述" class="headerlink" title="请求流程描述"></a>请求流程描述</h5><ul>
<li>web容器接收到请求后解析成Request对象</li>
<li>web容器将所有请求交给DispatcherServlet处理</li>
<li>DispatcherServlet通过HandlerMapping获取Handler</li>
<li>通过相应的适配类HandlerAdapter调用Handler的处理方法处理请求并返回ModelAndView</li>
<li>根据返回的ModelAndView选择一个适合的ViewResolver</li>
<li>ViewResolver结合Model和View渲染视图</li>
<li>将结果放到Response对象中返回给web容器</li>
</ul>
<h5 id="请求过滤拦截"><a href="#请求过滤拦截" class="headerlink" title="请求过滤拦截"></a>请求过滤拦截</h5><h6 id="Filter（过滤器）和Interceptor（拦截器）对比"><a href="#Filter（过滤器）和Interceptor（拦截器）对比" class="headerlink" title="Filter（过滤器）和Interceptor（拦截器）对比"></a>Filter（过滤器）和Interceptor（拦截器）对比</h6><p>主要区别如下</p>
<ul>
<li>使用范围不同：Filter是Servlet规范，只能用于web应用，Interceptor是Spring的规范，还可以用于非web应用</li>
<li>拦截对象不同：Filter在IOC初始化之前，Interceptor在IOC初始化之后，所以Filter中不能使用IOC中的对象</li>
</ul>
<h6 id="Filter（过滤器）和Interceptor（拦截器）顺序"><a href="#Filter（过滤器）和Interceptor（拦截器）顺序" class="headerlink" title="Filter（过滤器）和Interceptor（拦截器）顺序"></a>Filter（过滤器）和Interceptor（拦截器）顺序</h6><p>执行顺序如下</p>
<ul>
<li>Filter（过滤器）</li>
<li>Interceptor（拦截器）</li>
<li>Advice</li>
<li>Aop</li>
</ul>
<blockquote>
<p>ps：Filter在IOC之前，所以Filter中不能使用IOC</p>
</blockquote>
<h5 id="后端如何支持跨域功能"><a href="#后端如何支持跨域功能" class="headerlink" title="后端如何支持跨域功能"></a>后端如何支持跨域功能</h5><ul>
<li>全局<ul>
<li>WebMvcConfigurer</li>
<li>CorsFilter</li>
<li>自定义Filter添加响应头(Access-Control-Allow-Origin)</li>
</ul>
</li>
<li>局部<ul>
<li>@CrossOrigin</li>
<li>手动在响应里面添加响应头(Access-Control-Allow-Origin)</li>
</ul>
</li>
</ul>
<h4 id="Web-1"><a href="#Web-1" class="headerlink" title="Web"></a>Web</h4><h5 id="如何实现幂等"><a href="#如何实现幂等" class="headerlink" title="如何实现幂等"></a>如何实现幂等</h5><ul>
<li>去重：需要配合LOCK来保证并发安全，适合插入操作<ul>
<li>查重表<ul>
<li>数据库的主键或者唯一键（冲突检测）</li>
<li>redis的setnx操作</li>
</ul>
</li>
<li>token令牌</li>
</ul>
</li>
<li>状态机：需要配合CAS来保证并发安全，适合更新操作</li>
<li>版本号：需要配合CAS来保证并发安全，适合更新操作<ul>
<li>计数</li>
<li>时间戳</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：去重时还可以使用布隆过滤器来优化去重的效率<br>ps：数据库的插入和更新都会主动加锁，所以不需要额外加锁</p>
</blockquote>
<p>去重需要唯一标识</p>
<p>唯一标识来源</p>
<ul>
<li>业务id（身份证号、手机号、设备指纹）</li>
<li>逻辑id（发号器生成）<ul>
<li>顺序id</li>
<li>随机id</li>
</ul>
</li>
</ul>
<p>唯一标识实现</p>
<ul>
<li>单机<ul>
<li>顺序id<ul>
<li>mysql自增id</li>
<li>时间戳</li>
</ul>
</li>
<li>随机id<ul>
<li>UUID</li>
</ul>
</li>
</ul>
</li>
<li>分布式<ul>
<li>顺序id<ul>
<li>mysql发号器</li>
<li>redis发号器</li>
<li>SnowflakeId</li>
</ul>
</li>
<li>随机id<ul>
<li>UUID</li>
<li>MongodbId（不是顺序id，防止数据倾斜）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="如何防止重复提交"><a href="#如何防止重复提交" class="headerlink" title="如何防止重复提交"></a>如何防止重复提交</h5><ul>
<li>前端<ul>
<li>进入页面时向后端请求一个去重token放入隐藏域中</li>
<li>点击提交按钮后立即禁用提交按钮</li>
<li>点击提交按钮后显示加载中或者跳转到其他页面</li>
</ul>
</li>
<li>后端<ul>
<li>取出前端提交的去重token</li>
<li>如果token存在，则执行正常逻辑，并销毁去重token</li>
<li>如果token不存在，则执行去重逻辑，即丢弃重复的请求</li>
</ul>
</li>
</ul>
<h5 id="接口如何提高性能"><a href="#接口如何提高性能" class="headerlink" title="接口如何提高性能"></a>接口如何提高性能</h5><ul>
<li>缓存加速<ul>
<li>缓存预热</li>
</ul>
</li>
<li>异步处理（子线程、消息队列）<ul>
<li>客户端轮询</li>
<li>服务端回调（回调机制，耦合）</li>
<li>客户端监听（发布和订阅，不耦合）</li>
</ul>
</li>
<li>并行处理<ul>
<li>分解任务并进行并行处理</li>
</ul>
</li>
<li>批量操作</li>
<li>池化技术</li>
</ul>
<h3 id="SpringData-1"><a href="#SpringData-1" class="headerlink" title="SpringData"></a>SpringData</h3><h4 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h4><h5 id="和-的区别"><a href="#和-的区别" class="headerlink" title="${}和#{}的区别"></a>${}和#{}的区别</h5><ul>
<li>${}是属性替换符，生成sql时会直接替换成属性的值（不会被转义）</li>
<li>#{}是参数占位符，生成sql时会被处理为问号并通过PreparedStatement设置参数执行（会转义）</li>
</ul>
<h5 id="where中的1-x3D-1的作用"><a href="#where中的1-x3D-1的作用" class="headerlink" title="where中的1&#x3D;1的作用"></a>where中的1&#x3D;1的作用</h5><p>为了保证没有筛选条件时sql语句的正确性</p>
<h5 id="插入时如何返回主键"><a href="#插入时如何返回主键" class="headerlink" title="插入时如何返回主键"></a>插入时如何返回主键</h5><p>返回主键方案</p>
<ul>
<li>数据库支持主键自增时：useGeneratedKeys + keyProperty</li>
<li>数据库不支持主键自增时：selectKey</li>
</ul>
<h5 id="类的属性名和表的字段名不一样的解决办法"><a href="#类的属性名和表的字段名不一样的解决办法" class="headerlink" title="类的属性名和表的字段名不一样的解决办法"></a>类的属性名和表的字段名不一样的解决办法</h5><p>类的属性名和表的字段名不一样的解决办法</p>
<ul>
<li>启用下划线转驼峰的配置</li>
<li>在sql中起别名保持一致</li>
<li>使用ResultMap自定义映射</li>
</ul>
<h5 id="分页查询的实现方案"><a href="#分页查询的实现方案" class="headerlink" title="分页查询的实现方案"></a>分页查询的实现方案</h5><p>分页查询方案</p>
<ul>
<li>使用RowBounds来完成内存分页（它是针对ResultSet结果集执行的内存分页，而非物理分页）</li>
<li>直接在sql中写分页条件来完成物理分页</li>
<li>通过分页插件来完成物理分页</li>
</ul>
<h5 id="分页插件的基本原理"><a href="#分页插件的基本原理" class="headerlink" title="分页插件的基本原理"></a>分页插件的基本原理</h5><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql语句并改写sql，改写时会根据方言（dialect）添加对应的物理分页条件</p>
<h5 id="关联查询的实现方案"><a href="#关联查询的实现方案" class="headerlink" title="关联查询的实现方案"></a>关联查询的实现方案</h5><ul>
<li>一对一查询（selectOne）： association + result、association + select</li>
<li>一对多查询（selectOne）：collection + result、collection + select</li>
<li>多对一查询（selectMany）： association + result、association + select</li>
<li>多对多查询（selectMany）：collection + result、collection + select</li>
</ul>
<blockquote>
<p>ps：result方式是连接查询，需要在sql中进行join<br>ps：select方式是分步查询，不需要在sql中进行join<br>ps： <code>多对一</code> 本质上还是 <code>一对一</code> ， <code>多对多</code> 本质上还是 <code>一对多</code></p>
</blockquote>
<h5 id="Mybatis一级缓存的缓存一致性问题"><a href="#Mybatis一级缓存的缓存一致性问题" class="headerlink" title="Mybatis一级缓存的缓存一致性问题"></a>Mybatis一级缓存的缓存一致性问题</h5><p>一级缓存是session范围的</p>
<p>因为一级缓存是session范围的，所以BSession的更新不会使ASession的缓存失效，ASession再次查询时还会读缓存，导致BSession数据的更新读不到</p>
<h5 id="Mybatis二级缓存的缓存一致性问题"><a href="#Mybatis二级缓存的缓存一致性问题" class="headerlink" title="Mybatis二级缓存的缓存一致性问题"></a>Mybatis二级缓存的缓存一致性问题</h5><p>二级缓存是mapper范围的</p>
<p>因为二级缓存是mapper范围的，所以BMapper的更新不会使AMapper的缓存失效，AMapper再次查询时还会读缓存，导致BMapper数据的更新读不到</p>
<h4 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h4><h5 id="事务的实现方式"><a href="#事务的实现方式" class="headerlink" title="事务的实现方式"></a>事务的实现方式</h5><ul>
<li>编程式事务管理：TransactionTemplate、TransactionManager</li>
<li>声明式事务管理：@Transactional、TransactionProxyFactoryBean</li>
<li>配置式事务管理：Aspectj AOP</li>
</ul>
<h6 id="Spring事务实现为什么不推荐-Transactional注解"><a href="#Spring事务实现为什么不推荐-Transactional注解" class="headerlink" title="Spring事务实现为什么不推荐@Transactional注解"></a>Spring事务实现为什么不推荐@Transactional注解</h6><ul>
<li>使用不当时事务不会生效，比如同类方法调用等</li>
<li>容易出现长事务问题，占用数据库连接</li>
<li>事务内的非数据库操作不能回滚，会导致不一致的问题</li>
</ul>
<p>@Transactional使用时容易出现的问题</p>
<ul>
<li><code>@Transactional + @Async</code>：异步方法会启动一个新的事务（因为事务是线程隔离的）</li>
<li><code>@Transactional + @Retryable</code>：重试如果在事务开始之后可能会不起作用（隔离级别为可重复读时只在事务启动时生成快照）</li>
<li><code>@Transactional + Lock</code>：解锁如果在事务提交之前可能会导致业务逻辑错误</li>
</ul>
<h5 id="事务的失效场景"><a href="#事务的失效场景" class="headerlink" title="事务的失效场景"></a>事务的失效场景</h5><p>事务的失效场景</p>
<ul>
<li>所有AOP失效的场景（例外是事务对protected也不生效）</li>
<li>多线程或者异步调用（事务是线程隔离的）</li>
<li>事务传播方式使用不当</li>
</ul>
<blockquote>
<p>ps：@Transactional是通过AOP实现的，所以失效的场景包含AOP失效的场景</p>
</blockquote>
<p>事务不回滚的场景</p>
<ul>
<li>异常被吞掉了</li>
<li>未指定rollbackFor参数时抛出的异常不是RuntimeException</li>
<li>指定rollbackFor参数时抛出的异常和指定的异常不匹配</li>
</ul>
<h5 id="事务的传播方式"><a href="#事务的传播方式" class="headerlink" title="事务的传播方式"></a>事务的传播方式</h5><p>事务传播方式处理的是两个方法之间的事务关系，比如加入当前事务或者新建事务等等</p>
<p>事务传播方式</p>
<ul>
<li>PROPAGATION_REQUIRED：如果当前存在事务就<code>加入当前事务</code>，否则就以<code>新建事务</code>的方式运行</li>
<li>PROPAGATION_SUPPORTS：如果当前存在事务就<code>加入当前事务</code>，否则就以<code>非事务</code>的方式运行</li>
<li>PROPAGATION_MANDATORY：如果当前存在事务就<code>加入当前事务</code>，否则就<code>抛出异常</code></li>
<li>PROPAGATION_REQUIRES_NEW：以<code>新建事务</code>的方式运行，如果当前存在事务就<code>挂起当前事务</code></li>
<li>PROPAGATION_NOT_SUPPORTED：以<code>非事务</code>的方式运行，如果当前存在事务就<code>挂起当前事务</code></li>
<li>PROPAGATION_NEVER：以<code>非事务</code>的方式运行，如果当前存在事务就<code>抛出异常</code></li>
<li>PROPAGATION_NESTED：如果当前存在事务就<code>开启嵌套事务</code>运行，否则就<code>新建事务</code>运行</li>
</ul>
<blockquote>
<p>ps：传播方式为PROPAGATION_REQUIRES_NEW和PROPAGATION_NOT_SUPPORTED时如果存在当前事务，当前事务会被挂起<br>ps：传播方式为PROPAGATION_NESTED时嵌套事务回滚不会影响主事务，但主事务回滚会将嵌套事务一起回滚了</p>
</blockquote>
<p>事务传播处理</p>
<ul>
<li>当前事务存在时<ul>
<li>加入当前事务</li>
<li>挂起当前事务</li>
<li>抛出异常</li>
</ul>
</li>
<li>当前事务不存在时<ul>
<li>新建事务</li>
<li>非事务</li>
<li>抛出异常</li>
</ul>
</li>
</ul>
<h3 id="SpringSecurity-1"><a href="#SpringSecurity-1" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h3><h4 id="单点登录流程（SSO）"><a href="#单点登录流程（SSO）" class="headerlink" title="单点登录流程（SSO）"></a>单点登录流程（SSO）</h4><p>TODO：单点登录流程</p>
<h4 id="扫码登录流程"><a href="#扫码登录流程" class="headerlink" title="扫码登录流程"></a>扫码登录流程</h4><p>TODO：扫码登录流程</p>
<h3 id="SpringCloud-1"><a href="#SpringCloud-1" class="headerlink" title="SpringCloud"></a>SpringCloud</h3><h4 id="微服务的核心组件"><a href="#微服务的核心组件" class="headerlink" title="微服务的核心组件"></a>微服务的核心组件</h4><ul>
<li>服务治理：注册中心（注册和发现）、配置中心、网关</li>
<li>服务调用：负载均衡</li>
<li>服务防护：重试、熔断、降级、限流、预热</li>
</ul>
<h5 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h5><p>网关对比</p>
<ul>
<li>Nginx：支持所有语言的网关，可编程进行增强，也可以通过插件进行增强</li>
<li>Zuul：支持java语言的网关，可编程进行增强</li>
<li>SpringCloudGateway：支持java语言的网关，可编程进行增强</li>
</ul>
<p>负载均衡对比</p>
<ul>
<li>Nginx：服务端负载均衡</li>
<li>Ribbon：客户端负载均衡</li>
</ul>
<h5 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h5><p>服务调用对比</p>
<ul>
<li>RestTemplate：Http协议，性能相对较低</li>
<li>Feign：Http协议，性能相对较低</li>
<li>Dubbo：RPC协议，性能相对较高</li>
</ul>
<blockquote>
<p>ps：Feign可以支持声明式调用</p>
</blockquote>
<p>客户端组件作用</p>
<ul>
<li>Feign：客户端请求库（Request）</li>
<li>Ribbon：客户端请求负载均衡器（LoadBalance）</li>
<li>Hystrix：客户端请求断路器（Breaker）和限流器（Limiter）</li>
</ul>
<blockquote>
<p>ps：OpenFeign是Spring对Feign支持SpringMVC的封装，可以使用SpringMVC的注解</p>
</blockquote>
<h4 id="微服务的实现方案"><a href="#微服务的实现方案" class="headerlink" title="微服务的实现方案"></a>微服务的实现方案</h4><h5 id="SpringCloudNetflix"><a href="#SpringCloudNetflix" class="headerlink" title="SpringCloudNetflix"></a>SpringCloudNetflix</h5><ul>
<li>注册中心：Eureka</li>
<li>配置中心：Archaius</li>
<li>网关中心：Zuul</li>
<li>服务调用：Feign + Ribbon</li>
<li>服务防护：Hystrix</li>
</ul>
<h5 id="SpringCloudAlibaba"><a href="#SpringCloudAlibaba" class="headerlink" title="SpringCloudAlibaba"></a>SpringCloudAlibaba</h5><ul>
<li>注册中心：Nacos</li>
<li>配置中心：Nacos</li>
<li>网关中心：无（可使用Zuul或者SpringCloudGateway）</li>
<li>服务调用：Dubbo</li>
<li>服务防护：Sentinel</li>
</ul>
<h5 id="SpringCloudOfficial"><a href="#SpringCloudOfficial" class="headerlink" title="SpringCloudOfficial"></a>SpringCloudOfficial</h5><ul>
<li>注册中心：无（可使用Nacos）</li>
<li>配置中心：SpringCloudConfig、SpringCloudVault</li>
<li>网关中心：SpringCloudGateway</li>
<li>服务调用：SpringCloudOpenFeign</li>
<li>服务防护：无（可使用Sentinel）</li>
</ul>
<h2 id="Mysql-1"><a href="#Mysql-1" class="headerlink" title="Mysql"></a>Mysql</h2><h3 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h3><h4 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h4><h5 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h5><h6 id="MyISAM和InnoDB的区别"><a href="#MyISAM和InnoDB的区别" class="headerlink" title="MyISAM和InnoDB的区别"></a>MyISAM和InnoDB的区别</h6><ul>
<li>MyISAM不支持事务，InnoDB支持事务</li>
<li>MyISAM不支持外键，InnoDB支持外键</li>
<li>MyISAM支持全文索引，InnoDB不支持全文索引（5.7以后的InnoDB支持全文索引了）</li>
<li>MyISAM不要求有唯一索引，InnoDB要求有唯一索引（没指定的话会生成隐藏的ROW_ID）</li>
<li>MyISAM用的是非聚簇索引，InnoDB用的是聚簇索引</li>
<li>MyISAM只支持表锁，InnoDB支持表锁和行锁</li>
<li>MyISAM保存了行数，InnoDB获取行数要全表扫描</li>
</ul>
<h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><h5 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h5><h6 id="char和varchar对比和选择"><a href="#char和varchar对比和选择" class="headerlink" title="char和varchar对比和选择"></a>char和varchar对比和选择</h6><h6 id="varchar和text对比和选择"><a href="#varchar和text对比和选择" class="headerlink" title="varchar和text对比和选择"></a>varchar和text对比和选择</h6><h6 id="char和varchar的默认值"><a href="#char和varchar的默认值" class="headerlink" title="char和varchar的默认值"></a>char和varchar的默认值</h6><h6 id="char和varchar的空格处理"><a href="#char和varchar的空格处理" class="headerlink" title="char和varchar的空格处理"></a>char和varchar的空格处理</h6><h6 id="char和varchar的长度选择"><a href="#char和varchar的长度选择" class="headerlink" title="char和varchar的长度选择"></a>char和varchar的长度选择</h6><h6 id="datetime和timestamp对比和选择"><a href="#datetime和timestamp对比和选择" class="headerlink" title="datetime和timestamp对比和选择"></a>datetime和timestamp对比和选择</h6><h6 id="datetime和timestamp的默认值"><a href="#datetime和timestamp的默认值" class="headerlink" title="datetime和timestamp的默认值"></a>datetime和timestamp的默认值</h6><h6 id="datetime和timestamp的自动更新"><a href="#datetime和timestamp的自动更新" class="headerlink" title="datetime和timestamp的自动更新"></a>datetime和timestamp的自动更新</h6><h5 id="Constraint"><a href="#Constraint" class="headerlink" title="Constraint"></a>Constraint</h5><h6 id="为什么不推荐外键"><a href="#为什么不推荐外键" class="headerlink" title="为什么不推荐外键"></a>为什么不推荐外键</h6><ul>
<li>外键需要额外的检查，影响性能</li>
<li>外键需要锁住主记录，影响性能</li>
<li>外键不利于分表分库，影响扩展</li>
</ul>
<blockquote>
<p>ps：不使用外键是为了牺牲一致性来保证可用性（类似于CAP中C和A不能同时满足）<br>ps：不使用外键的话则需要在应用层面来做约束检查</p>
</blockquote>
<h5 id="Id"><a href="#Id" class="headerlink" title="Id"></a>Id</h5><h6 id="为什么不推荐uuid和雪花id"><a href="#为什么不推荐uuid和雪花id" class="headerlink" title="为什么不推荐uuid和雪花id"></a>为什么不推荐uuid和雪花id</h6><ul>
<li>uuid和雪花id不是单调递增的，无法插入到页中最大id的后面，需要寻找合适位置插入，性能较差</li>
<li>uuid是雪花id不是单调递增的，会分散插入到多个页中，会导致页分裂和频繁的换入换出，性能较差</li>
</ul>
<blockquote>
<p>ps：雪花id是单调递增的，单机时是大致连续递增，分布式时则步长较大</p>
</blockquote>
<h4 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h4><h5 id="常规查询"><a href="#常规查询" class="headerlink" title="常规查询"></a>常规查询</h5><h6 id="sql语句书写顺序"><a href="#sql语句书写顺序" class="headerlink" title="sql语句书写顺序"></a>sql语句书写顺序</h6><ul>
<li>SELECT </li>
<li>DISTINCT <select_list></li>
<li>FROM <left_table></li>
<li><join_type> JOIN <right_table></li>
<li>ON <join_condition></li>
<li>WHERE <where_condition></li>
<li>GROUP BY <group_by_list></li>
<li>HAVING <having_condition></li>
<li>ORDER BY <order_by_condition></li>
<li>LIMIT <limit_number></li>
</ul>
<h6 id="sql语句执行顺序"><a href="#sql语句执行顺序" class="headerlink" title="sql语句执行顺序"></a>sql语句执行顺序</h6><ul>
<li>FROM</li>
<li>ON</li>
<li>JOIN</li>
<li>WHERE</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>SELECT</li>
<li>DISTINCT</li>
<li>ORDER BY</li>
<li>LIMIT</li>
</ul>
<h6 id="大数据量如何深度分页"><a href="#大数据量如何深度分页" class="headerlink" title="大数据量如何深度分页"></a>大数据量如何深度分页</h6><p>转化为子查询，子查询只查出满足条件的id集合，父查询则查出在id集合里面的记录，这样可以利用索引覆盖，减少无用记录带来的开销</p>
<h5 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h5><h6 id="union和union-all的区别"><a href="#union和union-all的区别" class="headerlink" title="union和union all的区别"></a>union和union all的区别</h6><ul>
<li>union会对重复记录进行去重，union all不会</li>
<li>union会按照主键进行排序，union all不会</li>
</ul>
<h5 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h5><h6 id="count-1-和count-的区别"><a href="#count-1-和count-的区别" class="headerlink" title="count(1)和count(*)的区别"></a>count(1)和count(*)的区别</h6><ul>
<li>当统计表的行数时</li>
<li><code>count(1)</code>和 <code>count(*)</code>没区别</li>
<li>理论上列有索引时<code>count(column)</code>比<code>count(*)</code>快(<code>count(*)</code>需要全表扫描)</li>
<li>理论上列无索引时<code>count(column)</code>和<code>count(*)</code>一样快（都要全表扫描）</li>
<li>但是优化器优化后<code>count(*)</code>会利用索引覆盖</li>
<li>所以实际上列有索引时<code>count(*)</code>和<code>count(column)</code>一样快</li>
<li>所以实际上列无索引时<code>count(*)</code>比<code>count(column)</code>快</li>
<li>所以统计表的行数时推荐<code>count(*)</code>（<code>count(*)</code>是sql标准，而<code>count(1)</code>不是sql标准）</li>
</ul>
<h5 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h5><h6 id="on和where的区别"><a href="#on和where的区别" class="headerlink" title="on和where的区别"></a>on和where的区别</h6><p>on是join之前过滤，where是join之后过滤，on比where先执行</p>
<h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><ul>
<li>子查询按依赖分类<ul>
<li>相关子查询 子查询依赖父查询</li>
<li>非相关子查询 子查询不依赖父查询</li>
</ul>
</li>
<li>子查询按返回分类<ul>
<li>表子查询 返回多行多列，即返回一张表格，用于父查询的FROM子句中</li>
<li>行子查询 返回一行多列，即返回一条记录，用于父查询的FROM、WHERE子句中</li>
<li>列子查询 返回多行一列，即返回一个集合，用于父查询的WHERE子句中</li>
<li>标量子查询 返回一行一列，即返回一个值，用于父查询的SELECT、FROM、WHERE子句中</li>
</ul>
</li>
<li>子查询按类型分类<ul>
<li>in子查询：非相关子查询 + 行子查询</li>
<li>all子查询：非相关子查询 + 行子查询</li>
<li>any子查询：非相关子查询 + 行子查询</li>
<li>some子查询（some是any的同义词）：非相关子查询 + 行子查询</li>
<li>exists子查询：相关子查询 + 任意子查询</li>
</ul>
</li>
</ul>
<h6 id="in和exists的区别"><a href="#in和exists的区别" class="headerlink" title="in和exists的区别"></a>in和exists的区别</h6><ul>
<li>in是非相关子查询，会将条件带入主表中进行查询，适用于次表数据量小的场景</li>
<li>exists相关子查询，会扫描主表的每行并去次表中匹配，适用于主表数据量小的场景</li>
</ul>
<h4 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h4><h5 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h5><ul>
<li>按数据结构分<ul>
<li>B+tree索引</li>
<li>Hash索引</li>
<li>Full-text索引</li>
</ul>
</li>
<li>按存储内容分<ul>
<li>聚簇索引：索引结点中包含主键和记录</li>
<li>非聚簇索引（也叫二级索引、辅助索引）：索引结点中不包含记录，只包含主键</li>
</ul>
</li>
<li>按字段特性分<ul>
<li>主键索引</li>
<li>唯一索引</li>
<li>普通索引</li>
</ul>
</li>
<li>按字段个数分<ul>
<li>单列索引</li>
<li>联合索引（也叫复合索引、组合索引）</li>
</ul>
</li>
<li>按字段长度分<ul>
<li>前缀索引</li>
<li>后缀索引</li>
<li>全键索引</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：数据库的 <code>辅助索引</code> 和搜索引擎的 <code>倒排索引</code> 都是 <code>属性到键</code> 的反向映射关系</p>
</blockquote>
<h5 id="索引原则"><a href="#索引原则" class="headerlink" title="索引原则"></a>索引原则</h5><ul>
<li>从表的角度考虑<ul>
<li>数据量超过300的表适合建索引</li>
<li>经常更新的表不适合建索引</li>
</ul>
</li>
<li>从字段的角度考虑<ul>
<li><code>主键</code>和<code>外键</code>必须建索引</li>
<li>经常要<code>查询</code>的字段适合建索引</li>
<li>经常要<code>去重</code>的字段适合建索引</li>
<li>经常要<code>分组</code>的字段适合建索引</li>
<li>经常要<code>排序</code>的字段适合建索引</li>
<li>多字段查询时尽量用<code>联合索引</code>代替<code>单列索引</code></li>
<li>多字段查询时使用频繁的字段应该放在<code>联合索引</code>的左边</li>
</ul>
</li>
<li>从数据的角度考虑<ul>
<li><code>散列性</code>高的字段适合建索引</li>
<li><code>大文本字段</code>不适合建索引</li>
<li>包含<code>NULL</code>值的字段不适合建<code>联合索引</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：还应该删除无用的索引，避免对执行计划造成负面影响</p>
</blockquote>
<h5 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h5><ul>
<li>单列索引时查询条件有问题导致索引失效<ul>
<li>不等查询（!&#x3D;）</li>
<li>取反查询（not in）</li>
<li>like查询时使用百分号开头</li>
</ul>
</li>
<li>联合索引时字段组合没遵循<code>最左前缀</code>原则导致索引失效</li>
<li>联合索引时查询条件有问题导致右边的索引失效<ul>
<li>联合索引时左边使用了<code>不等查询（!=）</code>导致右边的索引失效</li>
<li>联合索引时左边使用了<code>取反查询（not in）</code>导致右边的索引失效</li>
<li>联合索引时左边使用了<code>like查询时使用百分号开头</code>导致右边的索引失效</li>
<li>联合索引时左边使用了<code>范围查询</code>导致右边的索引失效</li>
<li>联合索引时左边使用了<code>or查询</code>导致右边的索引失效</li>
</ul>
</li>
<li>查询时使用了<code>函数</code>导致索引失效</li>
<li>查询时进行了<code>计算</code>导致索引失效</li>
<li>查询时触发了<code>隐式转换</code>导致索引失效</li>
<li>排序时排序字段和查询字段不一致导致无法使用索引排序</li>
<li>优化器认为全表扫描比较快导致索引失效（数据少或者需要回表）</li>
</ul>
<blockquote>
<p>ps：not between会分成两个范围，本质上还是范围操作</p>
</blockquote>
<h5 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h5><p>or查询优化为union查询</p>
<h5 id="索引访问"><a href="#索引访问" class="headerlink" title="索引访问"></a>索引访问</h5><ul>
<li>system：只有一条数据的表</li>
<li>const：主键索引，根据键直接查询到记录（常量级别）</li>
<li>eq_ref：唯一索引，查出关联的一个主键后，根据主键回表查询记录</li>
<li>ref：普通索引，查出关联的多个主键后，根据主键回表查询记录</li>
<li>range：范围查找</li>
<li>index：索引覆盖（select的字段在索引里就有）</li>
<li>all：全表扫描</li>
</ul>
<h5 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h5><ul>
<li>B+树是一颗多叉平衡查找树，包含N个关键字和N+1个指针</li>
<li>枝干结点只包含关键字，不包含数据</li>
<li>叶子结点既包含关键字，又包含数据</li>
<li>叶子结点通过链表连接起来，有利于范围查询</li>
<li>高度2到3层，支持2000千万数据的快速查询</li>
</ul>
<h3 id="Transaction-1"><a href="#Transaction-1" class="headerlink" title="Transaction"></a>Transaction</h3><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><ul>
<li>原子性（atomicity）：事务里的所有操作要么全部生效，要么全部不生效</li>
<li>一致性（consistency）：事务的操作不会影响数据的正确性</li>
<li>隔离性（isolation）：事务里的数据修改何时对其他事务可见</li>
<li>持久性（durability）：事务对数据的更改会永久的保存到磁盘</li>
</ul>
<blockquote>
<p>ps： <code>ACID</code> 中 <code>C</code> 是 <code>目的</code> ， <code>AID</code> 是 <code>措施</code></p>
</blockquote>
<blockquote>
<p>ps： <code>原子性</code> 保障的是 <code>复合操作</code> ， <code>隔离性</code> 保障的是 <code>并发操作</code></p>
</blockquote>
<blockquote>
<p>ps： <code>undo日志</code> 保证 <code>原子性</code> ， <code>redo日志</code> 保证 <code>持久性</code> ， <code>mvcc和lock机制</code> 保证 <code>隔离性</code></p>
</blockquote>
<p>事务的隔离级别</p>
<ul>
<li>读未提交（RU -&gt; Read Uncommitted）：问题为脏读（一个事务读到另一个事务未提交的更新数据）</li>
<li>读已提交（RC -&gt; Read Committed）：问题为不可重复读（同一条记录前后发生了变化）</li>
<li>可重复读（RR -&gt; Repeatable Read）：问题为幻读（记录的数量前后发生了变化）</li>
<li>串行化（Serializable）：没有问题，但性能差</li>
</ul>
<p>隔离性解决的是数据库事务并发的读写问题，是通过MVCC（快照读）和Lock（当前读）来实现的</p>
<ul>
<li>写后读：不一致性（脏读、不可重复读、幻读）</li>
<li>读后写：写入偏差</li>
<li>并发写：更新丢失</li>
</ul>
<blockquote>
<p>ps：并发读不会存在问题</p>
</blockquote>
<p>快照读：写写冲突， <code>读写不冲突</code> （通过MVCC的写时复制机制实现），读读不冲突<br>当前读：写写冲突， <code>读写冲突</code> （通过读写锁的读写互斥机制实现） ，读读不冲突</p>
<ul>
<li>快照读（不加锁）<ul>
<li><code>select</code>（MVCC）</li>
</ul>
</li>
<li>当前读（加锁）<ul>
<li><code>select for update</code>（写锁）</li>
<li><code>select lock in share mode</code>（读锁）</li>
<li><code>insert</code>（写锁）</li>
<li><code>delete</code>（写锁）</li>
<li><code>update</code>（写锁）</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：当前读只影响其他事务的当前读，不会影响其他事务的快照读，因为快照读不加锁</p>
</blockquote>
<p>各种select的区别</p>
<ul>
<li>读快照的数据时用<code>select</code></li>
<li>读最新的数据但不修改时用<code>select lock in share mode</code></li>
<li>读最新的数据且要修改时用<code>select for update</code></li>
</ul>
<blockquote>
<p>ps： <code>select for update</code> 可以用来解决并发写入时的脏写问题</p>
</blockquote>
<h5 id="mysql事务隔离级别为什么默认是RR"><a href="#mysql事务隔离级别为什么默认是RR" class="headerlink" title="mysql事务隔离级别为什么默认是RR"></a>mysql事务隔离级别为什么默认是RR</h5><p>是为了解决binlog为STATEMENT时主从执行的SQL顺序不一致导致主从数据不一致的问题，RC级不能解决，RR级别通过加锁解决了</p>
<ul>
<li>事务A删除id为1的数据</li>
<li>事务B插入id为1的数据</li>
<li>事务B先提交</li>
<li>事务A后提交</li>
<li>此时主库会存在id为1的数据</li>
<li>此时从库不存在id为1的数据</li>
<li>因为binlog是按照提交顺序记录的，会记录成先插入后删除</li>
</ul>
<blockquote>
<p>ps：binlog是提交的时候按照提交顺序记录的，不是按照事务的执行顺序记录的</p>
</blockquote>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><h5 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h5><ul>
<li>写时复制（CopyOnWrite） </li>
<li>快照读（ReadView）</li>
<li>版本链（UndoLog）</li>
</ul>
<h5 id="MVCC实现原理之隐藏字段"><a href="#MVCC实现原理之隐藏字段" class="headerlink" title="MVCC实现原理之隐藏字段"></a>MVCC实现原理之隐藏字段</h5><p>DB_ROW_ID：6字节，记录ID，没有主键时会自动用DB_ROW_ID生成一个聚簇索引<br>DB_TRX_ID：6字节，版本号，记录的是修改这条记录的事务的版本号<br>DB_ROLL_PTR：7字节，回滚指针，指向记录的上一个版本</p>
<h5 id="MVCC实现原理之ReadView"><a href="#MVCC实现原理之ReadView" class="headerlink" title="MVCC实现原理之ReadView"></a>MVCC实现原理之ReadView</h5><p>隔离级别</p>
<ul>
<li>读已提交：事务中的每次查询都生成新的ReadView</li>
<li>可重复读：事务开始时只生成一次ReadView</li>
</ul>
<p>核心概念</p>
<ul>
<li>当前事务id：creator_trx_id，创建ReadView的事务id</li>
<li>活跃事务id：m_ids，创建ReadView时未提交的事务id集合</li>
<li>最小事务id：min_trx_id，m_ids里的最小id</li>
<li>最大事务id：max_trx_id，系统分配给下一个事务的事务id</li>
<li>记录事务id：trx_id，修改记录时的事务的事务id</li>
</ul>
<p>查找过程</p>
<ul>
<li>判断记录是否可见<ul>
<li>trx_id等于creator_trx_id，当前事务修改过的数据，对于当前事务可见</li>
<li>trx_id小于min_trx_id，当前事务开启前修改的数据，对于当前事务可见</li>
<li>trx_id大于等于max_trx_id，当前事务开启后修改的数据，对于当前事务不可见</li>
<li>trx_id在m_ids中，当前事务开启时未提交的数据，对于当前事务不可见</li>
<li>trx_id不在m_ids中，当前事务开启时已提交的数据，对于当前事务可见</li>
</ul>
</li>
<li>如果记录可见，就接受当前记录</li>
<li>如果记录不可见，则通过记录的roll_ptr找到上一个版本的记录继续判断，直到所有版本的记录都判断过</li>
</ul>
<blockquote>
<p>ps：删除的记录会有删除标记（delete_mark），会被过滤掉</p>
</blockquote>
<h5 id="MVCC和隔离级别的关系"><a href="#MVCC和隔离级别的关系" class="headerlink" title="MVCC和隔离级别的关系"></a>MVCC和隔离级别的关系</h5><p>隔离级别为 <code>读已提交</code> 和 <code>可重复读</code> 时会启用MVCC机制</p>
<ul>
<li>读已提交：事务中的每次查询都生成新的ReadView</li>
<li>可重复读：事务开始时只生成一次ReadView</li>
</ul>
<h5 id="MVCC彻底解决幻读问题了吗"><a href="#MVCC彻底解决幻读问题了吗" class="headerlink" title="MVCC彻底解决幻读问题了吗"></a>MVCC彻底解决幻读问题了吗</h5><ul>
<li>MVCC可以解决 <code>不可重复读</code> 的问题</li>
<li>不可重复读是通过MVCC中的快照（ReadView）和版本链（UndoLog）解决的</li>
<li>MVCC只能解决 <code>幻读</code> 的部分问题， <code>当前读</code> 时的幻读问题</li>
<li>幻读中的 <code>记录数量变化</code> 问题可以通过MVCC（快照读）来解决</li>
<li>幻读中的 <code>记录新增和删除</code> 问题需要通过LOCK（当前读）来解决</li>
</ul>
<h4 id="Lock-1"><a href="#Lock-1" class="headerlink" title="Lock"></a>Lock</h4><p>TODO：mysql意向锁</p>
<h5 id="锁和隔离级别的关系"><a href="#锁和隔离级别的关系" class="headerlink" title="锁和隔离级别的关系"></a>锁和隔离级别的关系</h5><p>读未提交：只加record锁，操作完记录就释放锁<br>读已提交：只加record锁，事务提交时才释放锁<br>可重复读：加record锁或者gap锁或者Next-key锁，事务提交时才释放锁</p>
<h5 id="锁和查询索引的关系"><a href="#锁和查询索引的关系" class="headerlink" title="锁和查询索引的关系"></a>锁和查询索引的关系</h5><ul>
<li>有索引：行锁</li>
<li>无索引：表锁</li>
</ul>
<h5 id="锁和查询类型的关系"><a href="#锁和查询类型的关系" class="headerlink" title="锁和查询类型的关系"></a>锁和查询类型的关系</h5><ul>
<li>有唯一索引：会先加 <code>临键锁</code><ul>
<li>等值查询：<ul>
<li>命中索引时 <code>临键锁</code> 会退化成 <code>记录锁</code></li>
<li>没有命中索引时 <code>临键锁</code> 会退化成 <code>间隙锁</code></li>
</ul>
</li>
<li>范围查询：<ul>
<li>命中索引时 <code>临键锁</code> 会退化成 <code>间隙锁</code></li>
<li>没有命中索引时加<code>临键锁</code>，不退化</li>
</ul>
</li>
</ul>
</li>
<li>有非唯一索引：两端都会先加 <code>临键锁</code><ul>
<li>等值查询：<ul>
<li>命中索引时除了 <code>临键锁</code> 还会额外添加一把 <code>间隙锁</code> （会加2把锁）</li>
<li>没有命中索引时除了 <code>临键锁</code> 会退化成 <code>间隙锁</code></li>
</ul>
</li>
<li>范围查询：<ul>
<li>有没有命中索引都加<code>临键锁</code>，不退化</li>
</ul>
</li>
</ul>
</li>
<li>无索引：会导致全表扫描，行锁会升级为表锁</li>
</ul>
<h4 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h4><p>mysql事务日志</p>
<ul>
<li>undolog：事务回滚数据时需要的日志</li>
<li>redolog：宕机修复数据时需要的日志</li>
<li>binlog：主从数据同步时需要的日志</li>
</ul>
<blockquote>
<p>ps：WAL（Write-Ahead Log）：预写日志（顺序写磁盘，速度快），undo和redo都是预写日志</p>
</blockquote>
<h5 id="为什么需要undolog"><a href="#为什么需要undolog" class="headerlink" title="为什么需要undolog"></a>为什么需要undolog</h5><p>undolog记录了数据的历史版本，事务回滚时可以通过undolog日志来找到历史数据进行恢复</p>
<h5 id="为什么需要redolog"><a href="#为什么需要redolog" class="headerlink" title="为什么需要redolog"></a>为什么需要redolog</h5><ul>
<li>redolog是顺序写操作，比直接将记录写入磁盘更快</li>
<li>redolog的占用空间比记录小，写入磁盘的耗时更短</li>
</ul>
<h5 id="为什么需要binlog"><a href="#为什么需要binlog" class="headerlink" title="为什么需要binlog"></a>为什么需要binlog</h5><p>binlog记录了操作的日志，主要用于主从复制时的数据同步</p>
<h5 id="undolog、redolog、binlog的区别"><a href="#undolog、redolog、binlog的区别" class="headerlink" title="undolog、redolog、binlog的区别"></a>undolog、redolog、binlog的区别</h5><ul>
<li>undolog、redolog是引擎层面的日志（InnoDB有而MyISAM没有），binlog是服务层面的日志（InnoDB和MyISAM都有）</li>
<li>undolog是物理日志（记录的是数据行的修改），redolog是物理日志（记录的是数据页的修改），binlog是逻辑日志（记录的是SQL语句）</li>
</ul>
<h5 id="undolog、redolog、binlog的产生"><a href="#undolog、redolog、binlog的产生" class="headerlink" title="undolog、redolog、binlog的产生"></a>undolog、redolog、binlog的产生</h5><ul>
<li>undolog：<ul>
<li>事务执行前生成</li>
</ul>
</li>
<li>redolog：可以通过<code>innodb_flush_log_at_trx_commit</code>控制写入策略<ul>
<li>0：事务执行时写到redolog buffer，每隔1秒刷新到redolog file后立即调用fsync刷盘</li>
<li>1：事务执行时写到redolog buffer，事务提交时刷新到redolog file后立即调用fsync刷盘</li>
<li>2：事务执行时写到redolog buffer，事务提交时刷新到redolog file，每隔1秒调用fsync刷盘</li>
</ul>
</li>
<li>binlog：可以通过<code>sync_binlog</code>控制写入策略<ul>
<li>0：事务执行时写到binlog cache，事务提交时刷新到binlog file，何时刷盘由操作系统决定</li>
<li>1：事务执行时写到binlog cache，事务提交时刷新到binlog file，每次提交时刷盘</li>
<li>N：事务执行时写到binlog cache，事务提交时刷新到binlog file，每N个事务提交后刷盘</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：innodb_flush_log_at_trx_commit默认为1，sync_binlog默认为0<br>ps：undolog也会生成对应的redolog来保证undolog的日志数据的持久化</p>
</blockquote>
<h5 id="undolog、redolog、binlog的释放"><a href="#undolog、redolog、binlog的释放" class="headerlink" title="undolog、redolog、binlog的释放"></a>undolog、redolog、binlog的释放</h5><ul>
<li>undolog：事务提交后不会立即释放，要等到没用的时候释放</li>
<li>redolog：刷盘后就释放</li>
<li>binlog：需要手动释放或者配置过期时间</li>
</ul>
<h5 id="redolog和binlog的区别"><a href="#redolog和binlog的区别" class="headerlink" title="redolog和binlog的区别"></a>redolog和binlog的区别</h5><ul>
<li>redolog属于InnoDB引擎的功能，binlog属于MySQL Server的功能，并且是以二进制文件记录</li>
<li>redolog属于物理日志，记录是数据页的修改，binlog是逻辑日志，记录的记录的更改</li>
<li>redolog日志是循环写，日志空间大小是固定，binlog是追加写入，写完一个写下一个，不会覆盖使用</li>
<li>redolog是作为服务器异常宕机后事务数据自动恢复使用的，binlog是作为主从复制和备份恢复使用的</li>
<li>redolog有crash-safe能力的能力，binlog没有自动crash-safe能力</li>
</ul>
<h5 id="redolog和binlog的主从一致性"><a href="#redolog和binlog的主从一致性" class="headerlink" title="redolog和binlog的主从一致性"></a>redolog和binlog的主从一致性</h5><p>redolog和binlog其中有一个写盘失败，会导致主（redolog）从（binlog）数据不一致的问题</p>
<p>事务提交时先写redolog在写binlog</p>
<ul>
<li>阶段1：redolog写盘后，事务处于处于prepare状态</li>
<li>阶段2：binlog写盘后，事务处于commit状态</li>
</ul>
<h4 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h4><p>session和global控制的是新的设置生效的范围</p>
<ul>
<li>session：会话，也就是当前连接立即生效</li>
<li>global：全局，不包含当前连接，之后新获取的连接都会生效</li>
</ul>
<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><h4 id="并发操作"><a href="#并发操作" class="headerlink" title="并发操作"></a>并发操作</h4><ul>
<li>写后读：不一致性（脏读、不可重复读、幻读）</li>
<li>读后写：写入偏差</li>
<li>并发写：更新丢失</li>
</ul>
<blockquote>
<p>ps：并发读不会存在问题</p>
</blockquote>
<h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>主从延时会导致读写分离时不能立马读到最新的数据</p>
<h4 id="数据丢失"><a href="#数据丢失" class="headerlink" title="数据丢失"></a>数据丢失</h4><ul>
<li>持久化时innodb_flush_log_at_trx_commit设置为0或2会丢数据（未刷盘的数据在宕机的时候会丢数据）</li>
<li>主从切换时主从同步不完整时会丢数据</li>
<li>程序有bug误操作删除数据</li>
<li>人为误操作删除数据</li>
</ul>
<h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>查询优化</p>
<ul>
<li>索引<ul>
<li>常用的查询条件要添加索引</li>
<li>避免单列索引时查询条件有问题导致索引失效<ul>
<li>避免不等查询（!&#x3D;）</li>
<li>避免取反查询（not in）</li>
<li>避免like查询时使用百分号开头</li>
</ul>
</li>
<li>避免联合索引时字段组合没遵循<code>最左前缀</code>原则导致索引失效</li>
<li>避免联合索引时查询条件有问题导致右边的索引失效<ul>
<li>避免联合索引时左边使用了<code>不等查询（!=）</code>导致右边的索引失效</li>
<li>避免联合索引时左边使用了<code>取反查询（not in）</code>导致右边的索引失效</li>
<li>避免联合索引时左边使用了<code>like查询时使用百分号开头</code>导致右边的索引失效</li>
<li>避免联合索引时左边使用了<code>范围查询</code>导致右边的索引失效</li>
<li>避免联合索引时左边使用了<code>or查询</code>导致右边的索引失效</li>
</ul>
</li>
<li>避免查询时使用了<code>函数</code>导致索引失效</li>
<li>避免查询时进行了<code>计算</code>导致索引失效</li>
<li>避免查询时触发了<code>隐式转换</code>导致索引失效</li>
</ul>
</li>
<li>查询<ul>
<li>select时尽量只选择需要的字段</li>
<li>or查询优化为in或者union</li>
<li>排序时注意要利用索引排序</li>
<li>分页时可以使用子查询进行索引覆盖</li>
<li>子查询和关联查询时注意要用小表驱动大表</li>
<li>查询时避免使用长事务</li>
</ul>
</li>
</ul>
<p>性能优化</p>
<ul>
<li>使用更好的服务器</li>
<li>增大缓冲池</li>
<li>增大连接数</li>
</ul>
<p>操作优化</p>
<ul>
<li>多次的操作优化为批量处理</li>
<li>长时间操作优化为分批处理</li>
</ul>
<h4 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h4><h5 id="explain的输出说明"><a href="#explain的输出说明" class="headerlink" title="explain的输出说明"></a>explain的输出说明</h5><ul>
<li>id：每个select子句的标识id（值越大越先被执行）</li>
<li>select_type：查询类型</li>
<li>table：当前表名（有时不是真实的表名）</li>
<li>type：查询方式</li>
<li>possible_keys：可能使用的索引</li>
<li>key：实际使用的索引</li>
<li>key_length：使用的索引长度</li>
<li>ref：索引的哪一列被使用了</li>
<li>rows：可能需要扫描的行数</li>
<li>Extra：额外的信息说明</li>
</ul>
<h5 id="explain的Type说明"><a href="#explain的Type说明" class="headerlink" title="explain的Type说明"></a>explain的Type说明</h5><ul>
<li>system：只有一条数据的表</li>
<li>const：主键索引，根据键直接查询到记录（常量级别）</li>
<li>eq_ref：唯一索引，查出关联的一个主键后，根据主键回表查询记录</li>
<li>ref：普通索引，查出关联的多个主键后，根据主键回表查询记录</li>
<li>range：范围查找</li>
<li>index：索引覆盖（select的字段在索引里就有）</li>
<li>all：全表扫描</li>
</ul>
<h5 id="explain的Extra说明"><a href="#explain的Extra说明" class="headerlink" title="explain的Extra说明"></a>explain的Extra说明</h5><ul>
<li>Using temporary：使用了临时表</li>
<li>Using filesort：使用了文件排序</li>
<li>Using index：使用了索引覆盖</li>
<li>Using index condition: 使用了索引下推（Index Condition Pushdown）</li>
<li>Using where: 使用了引擎过滤</li>
<li>Using join buffer：使用了连接缓冲（连接时没有使用索引）</li>
<li>Using MRR：使用了MRR优化（先将主键排序后再回表，因为相近的索引可能在相同的页上）</li>
</ul>
<h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><h4 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h4><h5 id="主从复制过程"><a href="#主从复制过程" class="headerlink" title="主从复制过程"></a>主从复制过程</h5><ul>
<li>master将DDL和DML操作记录到binlog文件中</li>
<li>slave的IO线程负责从master的logdump线程那里接收binlog并写入relaylog文件中</li>
<li>slave的SQL线程负责执行relaylog文件的sql语句</li>
</ul>
<blockquote>
<p>ps：主从同步是从库去主库拉取，而不是主库推给从库</p>
</blockquote>
<h5 id="主从复制模式"><a href="#主从复制模式" class="headerlink" title="主从复制模式"></a>主从复制模式</h5><ul>
<li>异步复制模式：主库写完binlog后不管binlog是否同步到了从库就返回</li>
<li>同步复制模式：主库写完binlog后等待binlog同步到了所有的从库才返回</li>
<li>半同步复制模式：主库写完binlog后等待binlog同步到了至少一个从库就返回</li>
<li>全局事务ID步复制模式：半同步复制并用全局事务ID来改善主从同步的一致性问题</li>
</ul>
<blockquote>
<p>ps：半同步：semi-sync<br>ps：全局事务ID：GTID<br>ps：半同步复制时master如果没有收到slave的ack，会降级为异步复制</p>
</blockquote>
<h5 id="主从复制文件"><a href="#主从复制文件" class="headerlink" title="主从复制文件"></a>主从复制文件</h5><ul>
<li>binlog：master的日志文件</li>
<li>relaylog：slave的日志文件</li>
<li>master.info：master的信息文件，保存了slave读取binlog文件和位置信息</li>
<li>relaylog.info：slave的信息文件，保存了slave应用relaylog的执行点信息</li>
</ul>
<p>binlog的格式</p>
<ul>
<li>STATMENT（statement-based replication, SBR）：记录sql语句</li>
<li>ROW（row-based replication, RBR）：记录每行的变更</li>
<li>MIXED（mixed-based replication, MBR）：混合使用SBR和RBR</li>
</ul>
<blockquote>
<p>ps：SBR在某些情况下会导致主从数据不一致，比如last_insert_id()、now()等函数<br>ps：MBR会根据sql语句选择格式，优先使用SBR，SBR不能用的话才使用RBR</p>
</blockquote>
<p>binlog格式和隔离级别的关系</p>
<ul>
<li>RC：只支持row格式的binlog（如果指定了mixed格式也会自动使用row格式）</li>
<li>RR：支持statement、row和mixed格式</li>
</ul>
<blockquote>
<p>ps：statement和mixed格式可能会存在主从数据不一致的问题</p>
</blockquote>
<h4 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h4><p>TODO：mysql Cluster</p>
<h4 id="Distributed-1"><a href="#Distributed-1" class="headerlink" title="Distributed"></a>Distributed</h4><p>分表分库的实现方案</p>
<ul>
<li>分表<ul>
<li>垂直拆分：将字段拆分到多个表中</li>
<li>水平拆分：将记录拆分成多个表中</li>
</ul>
</li>
<li>分库<ul>
<li>垂直拆分：将表格拆分到多个库中</li>
<li>水平拆分：将记录拆分到多个库中</li>
</ul>
</li>
</ul>
<p>分表分库的查询问题</p>
<ul>
<li>join</li>
<li>group by</li>
<li>order by</li>
<li>事务问题</li>
<li>非分区键查询</li>
</ul>
<p>分表分库的分区策略</p>
<ul>
<li>按照范围分</li>
<li>使用hash算法分</li>
</ul>
<p>分表分库的查询过程</p>
<ul>
<li>基于分区键的查询会直接找到对应的分区进行查询</li>
<li>不基于分区键的查询会在所有的分区中查询并合并结果</li>
</ul>
<p>分区键的分区方式</p>
<ul>
<li>单键分区：比如user_id</li>
<li>多键分区：比如user_id和order_time合成一个单键user_id:order_time后再分区</li>
</ul>
<p>非分区键的查询优化</p>
<ul>
<li>冗余法：根据user_id和order_id各做一个分表分库的实现，查询order_id时直接去order_id的分表分库中查</li>
<li>索引法：建立order_id和user_id的全量数据关联表，查询order_id时先去关联表里面查出user_id</li>
<li>基因法：order_id的低n位设置为user_id的低n位，这样order_id和user_id的hash取模结果就一样</li>
</ul>
<h3 id="Theory-1"><a href="#Theory-1" class="headerlink" title="Theory"></a>Theory</h3><h4 id="mysql为什么用B-树而不是红黑树、B-树详解"><a href="#mysql为什么用B-树而不是红黑树、B-树详解" class="headerlink" title="mysql为什么用B+树而不是红黑树、B-树详解"></a>mysql为什么用B+树而不是红黑树、B-树详解</h4><p>mysql的耗时点为磁盘IO，这就要求IO的次数尽可能少，即结点的层级尽可能得少</p>
<ul>
<li>红黑树是二叉树，结点的层级很高，排除</li>
<li>B树是多叉树，结点的层级较低，但是B树的结点既包含索引所以又包含数据，导致结点的层级比B+树高，也排除</li>
<li>红黑树和B树的范围查找比B+树复杂（B+树的叶子结点通过指针连接起来）</li>
</ul>
<h2 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h2><h3 id="Basic-1"><a href="#Basic-1" class="headerlink" title="Basic"></a>Basic</h3><h4 id="Concept-1"><a href="#Concept-1" class="headerlink" title="Concept"></a>Concept</h4><h5 id="Redis和Memcached的区别"><a href="#Redis和Memcached的区别" class="headerlink" title="Redis和Memcached的区别"></a>Redis和Memcached的区别</h5><p>memcached只支持字符串类型，redis支持更多的数据类型</p>
<h3 id="Usage-1"><a href="#Usage-1" class="headerlink" title="Usage"></a>Usage</h3><h4 id="Type-1"><a href="#Type-1" class="headerlink" title="Type"></a>Type</h4><ul>
<li>String</li>
<li>List</li>
<li>Set</li>
<li>SortedSet</li>
<li>Hash</li>
<li>Geo</li>
<li>Bitmap</li>
<li>BloomFilter</li>
<li>HyperLogLog</li>
</ul>
<h4 id="Expire"><a href="#Expire" class="headerlink" title="Expire"></a>Expire</h4><h5 id="缓存过期策略"><a href="#缓存过期策略" class="headerlink" title="缓存过期策略"></a>缓存过期策略</h5><ul>
<li>惰性删除</li>
<li>定期删除</li>
</ul>
<blockquote>
<p>ps：字符串的 <code>SET</code> 和 <code>SETEX</code> 也可以设置过期时间，过期的key会放在过期表里面</p>
</blockquote>
<h4 id="Eliminate"><a href="#Eliminate" class="headerlink" title="Eliminate"></a>Eliminate</h4><h5 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h5><ul>
<li>noeviction：不淘汰，内存不够了就报错</li>
<li>volatile-ttl：从设置了过期时间的key里面选择最先过期的进行淘汰</li>
<li>volatile-random：从设置了过期时间的key里面随机选择进行淘汰</li>
<li>volatile-lru：从设置了过期时间的key里面使用lru算法进行淘汰</li>
<li>volatile-lfu：从设置了过期时间的key里面使用lfu算法进行淘汰</li>
<li>allkeys-random：从所有的key里面随机选择进行淘汰</li>
<li>allkeys-lru：从所有的key里面使用lru算法进行淘汰</li>
<li>allkeys-lfu：从所有的key里面使用lfu算法进行淘汰</li>
</ul>
<p>FIFO（First In First Out）：先进先出算法，基于位置，淘汰最前面的数据，可以使用队列实现<br>LRU（Least Recently Used）：最久未使用算法，基于时间，淘汰闲置时间最长的数据，可以使用链表实现<br>LFU（Least Frequently Used）：最不常使用算法，基于频率，淘汰使用频率最低的数据，可以使用小顶堆实现</p>
<blockquote>
<p>ps：LRU保留的是新访数据，LFU保留的是热点数据<br>ps：java中LRU可以用LinkedHashMap，LFU可以用PriorityQueue</p>
</blockquote>
<p>redis中lru的近似性：采样选择一部分key而不是所有key，按照lru算法进行淘汰<br>redis中lfu的近似性：记录的不是真实频率，而是数量级</p>
<h4 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h4><h5 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h5><ul>
<li>旁路缓存（Cache Aside Pattern）：数据写到数据库并删除缓存，业务模块负责<code>稍后同步</code>数据到缓存</li>
<li>穿透写入（Write Through Pattern）：数据写到缓存，缓存模块负责<code>立即同步</code>数据到数据库</li>
<li>异步回写（Write Back Pattern）：数据写到缓存，缓存模块负责<code>延后同步</code>数据到数据库</li>
</ul>
<blockquote>
<p>ps：旁路缓存会先删除缓存，等到下次读取缓存时发现不存在就会从数据库同步到缓存中<br>ps：写入操作会先更新缓存，然后将数据立即或者稍后同步到数据库<br>ps：穿透写入类似于cpu缓存的写通策略，异步回写类似于cpu缓存的写回策略</p>
</blockquote>
<ul>
<li>旁路缓存是以数据为主，缓存为辅的策略，追求数据的完整</li>
<li>穿透写入是以缓存为主，数据为辅的策略，追求系统的性能</li>
<li>异步回写是以缓存为主，数据为辅的策略，追求系统的性能</li>
</ul>
<blockquote>
<p>ps： <code>穿透写入</code> 适合 <code>写少</code> 的场景， <code>异步回写</code> 适合 <code>写多</code> 的场景</p>
</blockquote>
<h4 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h4><ul>
<li>Normal<ul>
<li>缓存</li>
<li>分布式锁</li>
</ul>
</li>
<li>Number <ul>
<li>计数器</li>
<li>限流器</li>
<li>发号器（生成全局序列号）</li>
</ul>
</li>
<li>List<ul>
<li>时间轴</li>
<li>消息列表</li>
</ul>
</li>
<li>Set<ul>
<li>随机抽奖</li>
<li>点赞信息</li>
<li>签到信息</li>
<li>打卡信息</li>
<li>商品标签</li>
<li>社交关系</li>
</ul>
</li>
<li>SortedSet<ul>
<li>热搜榜（TopK）</li>
<li>排行榜（TopK）</li>
<li>延时队列</li>
</ul>
</li>
<li>Hash<ul>
<li>购物车</li>
</ul>
</li>
</ul>
<h4 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h4><h5 id="数据结构和编码"><a href="#数据结构和编码" class="headerlink" title="数据结构和编码"></a>数据结构和编码</h5><ul>
<li>String：intstr、embstr、rawstr</li>
<li>List：ziplist、linkedlist、quicklist</li>
<li>Set：intset、hashtable</li>
<li>SortedSet：ziplist、skiplist</li>
<li>Hash：ziplist、hashtable</li>
</ul>
<blockquote>
<p>ps：embstr和rawstr的区别是embstr和redisObject的空间是连续在一起的<br>ps：quicklist是ziplist和linkedlist的合体，将多个ziplist用linkedlist链接起来</p>
</blockquote>
<ul>
<li>ziplist：压缩列表</li>
<li>linkedlist：双向链表</li>
<li>quicklist：快速列表</li>
<li>intset：整型集合</li>
<li>skiplist：跳跃表</li>
<li>hashtable：哈希表</li>
</ul>
<h5 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h5><ul>
<li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表</li>
<li>在字典中维持一个索引计数器变量rehashidx，并将它的指设置为0，表示rehash工作正式开始</li>
<li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值一</li>
<li>随着字典操作的不断执行，最终在某个时间点，ht[0]的所有键值对都会被rehash至ht[1]，</li>
<li>这时程序将rehashidx属性设置为-1，表示rehash已经操作完成</li>
</ul>
<h3 id="Transaction-2"><a href="#Transaction-2" class="headerlink" title="Transaction"></a>Transaction</h3><h4 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h4><p>redis中单个操作是原子性的，复合操作不是原子性的（因为某个命令执行出错不会影响下一个命令的执行）</p>
<blockquote>
<p>ps：redis事务中的命令如果有语法错误，事务会被取消，事务里的所有命令都不会执行</p>
</blockquote>
<h4 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h4><p>redis执行命令是单线程的，不存在并发，所以不需要隔离性</p>
<h4 id="Durability"><a href="#Durability" class="headerlink" title="Durability"></a>Durability</h4><ul>
<li>RDB快照：类似与mysql的dump文件</li>
<li>AOF日志：类似于mysql的binlog文件</li>
<li>RDB快照和AOF日志混合：AOF日志只记录上次RDB快照之后的变化，这次生成快照后会重写AOF日志</li>
</ul>
<blockquote>
<p>ps：非混合时启动时先考虑加载AOF文件，AOF文件不存在则加载RDB文件，因为AOF文件保存的数据比RDB文件更完整<br>ps：混合时启动会加载RDB文件，再加载AOF文件</p>
</blockquote>
<h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h5><ul>
<li>save：会阻塞其他操作直到RDB操作完成</li>
<li>bgsave：fork出子进程在后台进行RDB操作</li>
</ul>
<h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h5><ul>
<li>Always：命令执行完立即将AOF日志同步写入磁盘</li>
<li>Everysec：每隔一秒将AOF缓冲区中的内容写入磁盘</li>
<li>No：由操作系统决定何时将AOF缓冲区中的内容写入磁盘</li>
</ul>
<blockquote>
<p>ps：appendfsync的默认值为Everysec</p>
</blockquote>
<h5 id="RDB和AOF混合"><a href="#RDB和AOF混合" class="headerlink" title="RDB和AOF混合"></a>RDB和AOF混合</h5><h3 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem"></a>Problem</h3><h4 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h4><ul>
<li>缓存穿透：不存在的key（布隆过滤器、缓存空值、接口校验、IP黑名单）</li>
<li>缓存击穿：单个热点key失效了（热点key永不过期、监控热点key并延长过期时间、读数据库时加锁排队）</li>
<li>缓存雪崩：大量key同时失效了（过期时间随机、使用二级缓存、读数据库时加锁排队）</li>
</ul>
<blockquote>
<p>ps：二级缓存是指 <code>一级本地进程缓存 + 二级redis缓存</code> ，一级缓存的过期时间是随机的，二级缓存的过期时间比一级缓存的过期时间长</p>
</blockquote>
<h4 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h4><p>缓存一致性方案</p>
<ul>
<li>写缓存：写多时前面写入的缓存会被后面的覆盖从而浪费cpu资源，而且高并发写入会导致更新丢失的问题<ul>
<li>先写数据库再写缓存</li>
<li>先写缓存再写数据库</li>
</ul>
</li>
<li>删缓存：使用删除和懒加载的方式效率更高，而且删除比更新更快速和安全<ul>
<li>先写数据库再删缓存</li>
<li>先删缓存再写数据库</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：关键字：写浪费，写丢失，删除更快速和安全</p>
</blockquote>
<p>综上所述应该选择 <code>删缓存</code> 的方案</p>
<p>主要的操作如下</p>
<ul>
<li><code>写数据库 + 删缓存</code> 或 <code>删缓存 + 写数据库</code></li>
<li><code>读数据库 + 写缓存</code></li>
</ul>
<blockquote>
<p>ps：读缓存读不到时（缓存已 <code>删除</code> 或缓存已 <code>失效</code> ）会 <code>读数据库</code> 和 <code>写缓存</code></p>
</blockquote>
<p>缓存不一致的形成条件为</p>
<ul>
<li>B读数据库要在A写数据库之前（读脏数据）</li>
<li>B写缓存要在A删缓存之后（写脏数据）</li>
</ul>
<p>方案1：先写数据库再删缓存</p>
<ul>
<li>场景1：写数据库成功，删缓存失败（会出现缓存不一致的情况，需要重试删除缓存操作）</li>
<li>场景2：B读数据库（缓存已失效），A写数据库，A删缓存，B写缓存</li>
</ul>
<blockquote>
<p>ps：A写数据库要在A删缓存之前（方案要求）<br>ps：B读数据库要在A写数据库之前（读脏数据）<br>ps：B写缓存要在A删缓存之后（写脏数据）</p>
</blockquote>
<p>方案2：先删缓存再写数据库</p>
<ul>
<li>场景3：删缓存成功，写数据库成功（不会出现缓存不一致的情况，缓存后面会被重新加载）</li>
<li>场景4：B读数据库（缓存已失效），A删缓存，A写数据库，B写缓存</li>
<li>场景5：B读数据库（缓存已失效），A删缓存，B写缓存，A写数据库</li>
<li>场景6：A删缓存，B读数据库（缓存已删除），A写数据库，B写缓存</li>
<li>场景7：A删缓存，B读数据库（缓存已删除），B写缓存，A写数据库</li>
</ul>
<blockquote>
<p>ps：A删缓存要在A写数据库之前（方案要求）<br>ps：B读数据库要在A写数据库之前（读脏数据）<br>ps：B写缓存要在A删缓存之后（写脏数据）</p>
</blockquote>
<p>对比发现 <code>先写数据库再删缓存</code> 这种方案更优</p>
<ul>
<li>因为方案1出现缓存一致性的场景比方案2更少</li>
<li>因为缓存已失效比缓存已删除低的出现概率低</li>
<li>因为B读数据库之后B写缓存出现在A写数据库之后的概率低</li>
</ul>
<blockquote>
<p>ps：一般来说B读数据库之后B写缓存的速度比A写数据库快</p>
</blockquote>
<p>所以最终的方案是 <code>先写数据库再删缓存</code> ，再配合 <code>延时双删</code> 可以更好的解决缓存不一致的问题</p>
<h4 id="数据丢失-1"><a href="#数据丢失-1" class="headerlink" title="数据丢失"></a>数据丢失</h4><ul>
<li>持久化时appendfsync设置为Everysec或No会丢数据（未刷盘的数据在宕机的时候会丢数据）</li>
<li>主从切换时主从同步不完整时会丢数据</li>
<li>内存不足进行淘汰时会丢失</li>
<li>程序有bug误操作删除数据</li>
<li>人为误操作删除数据</li>
</ul>
<h3 id="Performance-1"><a href="#Performance-1" class="headerlink" title="Performance"></a>Performance</h3><p>查询优化</p>
<ul>
<li>避免使用很大的key和value</li>
<li>避免使用耗时长的命令</li>
</ul>
<p>性能优化</p>
<ul>
<li>为key设置过期时间来减少内存占用</li>
<li>避免大量的key同时过期</li>
<li>尽量使用批量操作</li>
<li>启用延迟删除的特性</li>
<li>启用自动整理碎片的功能</li>
</ul>
<p>操作优化</p>
<ul>
<li>多次的操作优化为批量处理</li>
<li>长时间操作优化为分批处理</li>
</ul>
<h4 id="为什么要使用redis"><a href="#为什么要使用redis" class="headerlink" title="为什么要使用redis"></a>为什么要使用redis</h4><ul>
<li>高性能：redis的性能很高，可以用作缓存加快访问速度</li>
<li>高并发：redis的并发很高，可以支持更高的并发请求</li>
</ul>
<blockquote>
<p>ps：系统三高指标，高性能，高并发，高可用</p>
</blockquote>
<h4 id="redis为什么这么快"><a href="#redis为什么这么快" class="headerlink" title="redis为什么这么快"></a>redis为什么这么快</h4><ul>
<li><code>数据读写</code>部分基于内存访问，速度快</li>
<li><code>数据结构</code>部分基于优化后的数据结构，效率高</li>
<li><code>命令处理</code>部分基于单线程来避免上下文切换，效率高</li>
<li><code>网络请求</code>部分基于多路复用，性能高</li>
</ul>
<blockquote>
<p>ps：redis是IO密集型，因此cpu不是瓶颈而网络IO是瓶颈，所以命令处理部分使用单线程更好</p>
</blockquote>
<h4 id="redis为什么QPS这么高"><a href="#redis为什么QPS这么高" class="headerlink" title="redis为什么QPS这么高"></a>redis为什么QPS这么高</h4><p>QPS为每秒处理的请求数和并发数的乘积，操作的速度越快，每秒处理的请求数越高</p>
<ul>
<li>内存操作：redis是基于内存的，操作速度快</li>
<li>高效的数据结构：高效的数据结构，使得操作速度更快</li>
<li>单线程和事件机制：cpu不是瓶颈，使用单线程和事件机制避免了加锁和线程切换，使得操作速度更快</li>
<li>IO多路复用机制：使用了IO多路复用机制，支持的并发数很高</li>
</ul>
<blockquote>
<p>ps：redis的QPS是10w+（50000~300000）级别的，mysql的QPS是1k+（5000左右）级别的</p>
</blockquote>
<h4 id="redis6-0之前真的是单线程吗"><a href="#redis6-0之前真的是单线程吗" class="headerlink" title="redis6.0之前真的是单线程吗"></a>redis6.0之前真的是单线程吗</h4><p>网络请求部分和命令处理部分是单线程，还存在其他线程</p>
<ul>
<li>close_file：负责关闭资源文件（日志文件和网络套接字）</li>
<li>aof_fsync：负责对aof文件刷盘</li>
<li>lazy_free：负责释放大对象空间</li>
</ul>
<h4 id="redis6-0之前为什么不使用多线程"><a href="#redis6-0之前为什么不使用多线程" class="headerlink" title="redis6.0之前为什么不使用多线程"></a>redis6.0之前为什么不使用多线程</h4><ul>
<li>单线程实现比较简单</li>
<li>多线程不是迫切需求<ul>
<li>因为内存访问很快，所以并发和吞吐量也能满足早期的需求</li>
<li>单线程无需加锁和无需线程切换的特性使得单线程的性能比多线程更高</li>
<li>早期的主要操作是IO读写，cpu不是瓶颈，IO读写在单线程中可以通过多路复用来解决</li>
</ul>
</li>
</ul>
<h4 id="redis6-0之后为什么要引入多线程"><a href="#redis6-0之后为什么要引入多线程" class="headerlink" title="redis6.0之后为什么要引入多线程"></a>redis6.0之后为什么要引入多线程</h4><ul>
<li>redis6.0之后的网络IO部分是多线程的，命令执行还是单线程的</li>
<li>使用多线程是为了提高网络IO部分的性能，支持更高的并发量</li>
</ul>
<h4 id="redis键名长度会影响性能吗"><a href="#redis键名长度会影响性能吗" class="headerlink" title="redis键名长度会影响性能吗"></a>redis键名长度会影响性能吗</h4><p>键名太长的话会导致以下问题从而影响性能</p>
<ul>
<li>内存占用更多</li>
<li>读写更加耗时</li>
<li>传输更加耗时</li>
</ul>
<h4 id="redis大key（BigKey）问题如何优化"><a href="#redis大key（BigKey）问题如何优化" class="headerlink" title="redis大key（BigKey）问题如何优化"></a>redis大key（BigKey）问题如何优化</h4><p>BigKey的危害</p>
<ul>
<li>操作时间长，阻塞其他请求，性能变差</li>
</ul>
<p>BigKey的发现</p>
<ul>
<li>redis的bigkeys选项</li>
</ul>
<p>BigKey的解决</p>
<ul>
<li>使用二级缓存（本地缓存）</li>
<li>拆分成多个key进行读写</li>
</ul>
<h4 id="redis热key（HotKey）问题如何优化"><a href="#redis热key（HotKey）问题如何优化" class="headerlink" title="redis热key（HotKey）问题如何优化"></a>redis热key（HotKey）问题如何优化</h4><p>HotKey的危害</p>
<ul>
<li>请求集中在某个节点上，导致节点的压力大</li>
</ul>
<p>HotKey的发现</p>
<ul>
<li>根据业务特点预判</li>
<li>客户端收集访问信息</li>
<li>代理层收集访问信息</li>
<li>redis的hotkeys选项</li>
<li>redis的monitor监控</li>
<li>redis的网络数据抓包</li>
</ul>
<p>HotKey的解决</p>
<ul>
<li>使用二级缓存（本地缓存）</li>
<li>分布式时增加副本数量来分摊读取压力</li>
</ul>
<h3 id="Architecture-1"><a href="#Architecture-1" class="headerlink" title="Architecture"></a>Architecture</h3><h4 id="Replication-1"><a href="#Replication-1" class="headerlink" title="Replication"></a>Replication</h4><h5 id="主从复制过程-1"><a href="#主从复制过程-1" class="headerlink" title="主从复制过程"></a>主从复制过程</h5><p>建立连接阶段</p>
<ul>
<li>读取主节点地址信息：读取配置文件中slaveof中配置的ip和port</li>
<li>建立Socket连接：根据slaveof中配置的ip和port与master建立连接</li>
<li>发送PING命令：收到PONG响应后说明连接正常</li>
<li>验证用户身份：如果配置了masterauth就会请求验证slave的身份</li>
<li>发送从节点地址信息：slave发送自己的ip和port</li>
</ul>
<p>数据同步阶段</p>
<ul>
<li>全量同步：发送<code>PSYNC ? -1</code>命令</li>
<li>增量同步：发送<code>PSYNC &lt;runid&gt; &lt;offset&gt;</code>命令</li>
</ul>
<blockquote>
<p>ps：runid为主服务器的ID</p>
</blockquote>
<h5 id="主从复制模式-1"><a href="#主从复制模式-1" class="headerlink" title="主从复制模式"></a>主从复制模式</h5><ul>
<li>全量复制：第一次连接时</li>
<li>增量复制：非第一次连接时</li>
</ul>
<h4 id="Cluster-1"><a href="#Cluster-1" class="headerlink" title="Cluster"></a>Cluster</h4><p>TODO：redis Cluster</p>
<h4 id="Distributed-2"><a href="#Distributed-2" class="headerlink" title="Distributed"></a>Distributed</h4><h5 id="redis为什么使用的是hash槽而不是一致性hash"><a href="#redis为什么使用的是hash槽而不是一致性hash" class="headerlink" title="redis为什么使用的是hash槽而不是一致性hash"></a>redis为什么使用的是hash槽而不是一致性hash</h5><ul>
<li>一致性哈希的节点分布基于圆环，无法很好的手动设置数据分布，比如有些节点的硬件差，希望少存一点数据，这种很难操作。而哈希槽可以很灵活的配置每个节点占用哈希槽的数量</li>
<li>一致性哈希的某个节点宕机或者掉线后，当该机器上原本缓存的数据被请求时，会从数据源重新获取数据，并将数据添加到失效机器后面的机器，这个过程被称为 “缓存抖动” ，而使用哈希槽的节点宕机，会导致一定范围内的槽不可用，只能通过主从复制加哨兵模式保证高可用。</li>
<li>真是基于一致性哈希的特点，当某台机器宕机时，极易引起雪崩，如上述介绍中删除节点。</li>
<li>Redis Cluster的槽位空间是可以用户手动自定义分配的，类似于 windows 盘分区的概念，可以手动控制大小。</li>
<li>相对于哈希槽，一致性哈希算法更复杂</li>
</ul>
<h5 id="redis的hash槽为什么是16384个"><a href="#redis的hash槽为什么是16384个" class="headerlink" title="redis的hash槽为什么是16384个"></a>redis的hash槽为什么是16384个</h5><p>理论上crc16算法可以得到2^16个数值，其数值范围在0-65535之间，取模运算key的时候，应该是crc16(key)%65535</p>
<ol>
<li><p>如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。<br>如上所述，在消息头中，最占空间的是 myslots[CLUSTER_SLOTS&#x2F;8]。 当槽位为65536时，这块的大小是: 65536÷8÷1024&#x3D;8kb因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。</p>
</li>
<li><p>redis的集群主节点数量基本不可能超过1000个。<br>如上所述，集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者，不建议redis cluster节点数量超过1000个。 那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。</p>
</li>
<li><p>槽位越小，节点少的情况下，压缩率高<br>Redis主节点的配置信息中，它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中，会对bitmap进行压缩，但是如果bitmap的填充率slots &#x2F; N很高的话(N表示节点数)，bitmap的压缩率就很低。 如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。16384÷8÷1024&#x3D;2kb，怎么样，神奇不！综上所述，作者决定取16384个槽，不多不少，刚刚好！</p>
</li>
</ol>
<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><h4 id="Lock-2"><a href="#Lock-2" class="headerlink" title="Lock"></a>Lock</h4><p>TODO：redis锁（红锁）<br>TODO：zookeeper锁</p>
<h5 id="如何用redis实现分布式锁"><a href="#如何用redis实现分布式锁" class="headerlink" title="如何用redis实现分布式锁"></a>如何用redis实现分布式锁</h5><p>redis实现分布式锁需要考虑的问题</p>
<ul>
<li>锁的特性<ul>
<li>锁需要超时释放：程序出错或者挂了不释放锁，会导致死锁，需要支持锁超时释放</li>
<li>锁不能提前释放：任务还没完成就释放了锁，会导致锁被重复获取，需要支持锁超时刷新</li>
<li>锁的可重入性：同一个使用者可以重复获取锁</li>
<li>锁的安全释放：锁只能被持有者释放</li>
</ul>
</li>
<li>锁的安全<ul>
<li>加锁和超时的原子性：<code>加锁</code>和<code>设置超时</code>需要保证原子性</li>
<li>检查和加锁的原子性：检查加锁的操作者是否是持有者并允许<code>重入</code>需要保证原子性</li>
<li>检查和解锁的原子性：检查解锁的操作者是否是持有者并允许<code>删除</code>需要保证原子性</li>
</ul>
</li>
</ul>
<p>redis看门狗超时刷新原理：有一个后台线程定期（周期小于过期时间和延长时间）去延长锁的过期时间</p>
<blockquote>
<p>ps：如果key不存在了，说明是主动释放了锁，这时候就不需要延长锁的过期时间</p>
</blockquote>
<h6 id="setnx"><a href="#setnx" class="headerlink" title="setnx"></a>setnx</h6><ul>
<li>不支持锁超时释放</li>
<li>不支持锁的可重入性</li>
<li>不支持锁的安全释放</li>
</ul>
<p>加锁</p>
<p> <code>SETNX lock_key 1</code></p>
<p>解锁</p>
<p> <code>DEL lock_key</code></p>
<h6 id="setnx-expire"><a href="#setnx-expire" class="headerlink" title="setnx + expire"></a>setnx + expire</h6><ul>
<li>锁可能会提前释放</li>
<li>不支持锁的可重入性</li>
<li>不支持锁的安全释放</li>
<li>加锁和超时不具备原子性</li>
</ul>
<p>加锁</p>
<p><code>SETNX lock_key 1</code> + <code>EXPIRE lock_key 10</code></p>
<p>解锁</p>
<p> <code>DEL lock_key</code></p>
<h6 id="set-ex-nx"><a href="#set-ex-nx" class="headerlink" title="set + ex + nx"></a>set + ex + nx</h6><ul>
<li>锁可能会提前释放</li>
<li>不支持锁的可重入性</li>
<li>不支持锁的安全释放</li>
</ul>
<p>加锁</p>
<p> <code>SET lock_key 1 EX 10 NX</code></p>
<p>解锁</p>
<p> <code>DEL lock_key</code></p>
<h6 id="check-set（命令版）"><a href="#check-set（命令版）" class="headerlink" title="check + set（命令版）"></a>check + set（命令版）</h6><ul>
<li>锁可能会提前释放</li>
<li>检查和加锁不具备原子性</li>
<li>检查和解锁不具备原子性</li>
</ul>
<p>加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.get(lock_key) == unique_value) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> redis.set(lock_key, unique_value, <span class="string">&quot;EX&quot;</span>, <span class="number">10</span>, <span class="string">&quot;NX&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>解锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.get(lock_key) == unique_value) &#123;</span><br><span class="line">  <span class="keyword">return</span> redis.del(lock_key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h6 id="check-set（脚本版）"><a href="#check-set（脚本版）" class="headerlink" title="check + set（脚本版）"></a>check + set（脚本版）</h6><ul>
<li>锁可能会提前释放</li>
</ul>
<p>加锁</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;set&quot;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], ARGV[<span class="number">2</span>], ARGV[<span class="number">3</span>], ARGV[<span class="number">4</span>])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>解锁</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h6 id="check-set（看门狗）"><a href="#check-set（看门狗）" class="headerlink" title="check + set（看门狗）"></a>check + set（看门狗）</h6><p>脚本版 + 看门狗 就可以实现redis单机版的分布式锁了，redis的集群版分布式锁要用红锁</p>
<h4 id="Limiter"><a href="#Limiter" class="headerlink" title="Limiter"></a>Limiter</h4><p>TODO：redis限流器</p>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>TODO：redis延时队列</p>
<h3 id="Theory-2"><a href="#Theory-2" class="headerlink" title="Theory"></a>Theory</h3><h4 id="redis为什么用跳表而不是红黑树详解"><a href="#redis为什么用跳表而不是红黑树详解" class="headerlink" title="redis为什么用跳表而不是红黑树详解"></a>redis为什么用跳表而不是红黑树详解</h4><ul>
<li>跳表插入和删除效率比红黑树高<ul>
<li>红黑树的平衡操作会引起子树的操作，比较耗时</li>
<li>跳表只需要维护相邻节点，耗时较少</li>
</ul>
</li>
<li>跳表的范围查询效率比红黑树高<ul>
<li>红黑树通过二分法找到最小值后还需要中序遍历整棵树找到范围内的值，比较耗时</li>
<li>跳表通过二分法找到最小值通过向后遍历就能找到范围内的值，耗时较少</li>
</ul>
</li>
</ul>
<h2 id="Mq"><a href="#Mq" class="headerlink" title="Mq"></a>Mq</h2><h3 id="Reliability"><a href="#Reliability" class="headerlink" title="Reliability"></a>Reliability</h3><ul>
<li>生产端：使用确认机制<ul>
<li>同步发送：同步返回结果（sync）</li>
<li>异步发送：异步返回结果（async）</li>
<li>单向发送：不关心结果（oneway）</li>
</ul>
</li>
<li>队列端：开启持久化机制（刷盘策略 + 主从同步策略）<ul>
<li>刷盘策略：<ul>
<li>每次刷盘</li>
<li>每秒刷盘</li>
<li>系统刷盘</li>
</ul>
</li>
<li>同步策略：<ul>
<li>不同步：不需要同步到从节点</li>
<li>半同步：至少需要同步到一个从节点</li>
<li>全同步：需要同步到所有的从节点</li>
</ul>
</li>
</ul>
</li>
<li>消费端：使用手动确认机制（不使用自动确认机制）<ul>
<li>不确认：收到消息后不需要确认</li>
<li>自动确认：收到消息后先确认再消费</li>
<li>手动确认：收到消息后先消费再确认</li>
</ul>
</li>
</ul>
<h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><ul>
<li>生产端：使用确认机制（使用confirm机制）</li>
<li>队列端：开启持久化机制(交换机、队列、消息)</li>
<li>消费端：使用手动确认机制(basicAck)</li>
</ul>
<blockquote>
<p>ps：生产端建议使用确认（confirm）机制，不建议使用事务（transaction）机制<br>ps：确认机制是异步操作，性能好<br>ps：事务机制是异步操作，性能差</p>
</blockquote>
<h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><ul>
<li>生产端：使用确认机制（使用异步发送）</li>
<li>队列端：同步刷盘策略 + 同步主从同步策略</li>
<li>消费端：使用手动确认机制(ConsumeStatus)</li>
</ul>
<blockquote>
<p>ps：生产端建议使用异步发送，而不是同步发送和单向发送<br>ps：异步发送是异步操作，性能好<br>ps：同步发送是同步操作，性能差<br>ps：单向发送无确认机制，会丢失消息</p>
</blockquote>
<h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><ul>
<li>生产端：使用确认机制（生产者的acks配置为1）</li>
<li>队列端：同步刷盘策略 + 同步主从同步策略</li>
<li>消费端：使用手动确认机制(手动提交offset)</li>
</ul>
<blockquote>
<p>ps：acks含义 0：不关心结果 1：只需主节点写完成 -1：所有从节点都同步完成</p>
</blockquote>
<h3 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem"></a>Problem</h3><h4 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h4><p>TODO：消息丢失</p>
<p>问题描述：消息丢失<br>解决办法：确认机制 + 重试机制 + 持久化机制</p>
<ul>
<li>生产时丢失<ul>
<li>场景1<ul>
<li>丢失原因：使用自动确认机制时，网络有问题导致生产端发送消息失败</li>
<li>解决办法：使用重试机制</li>
</ul>
</li>
<li>场景2<ul>
<li>丢失原因：使用自动确认机制时，网络有问题导致队列端返回ACK失败</li>
<li>解决办法：使用重试机制</li>
</ul>
</li>
<li>场景3<ul>
<li>丢失原因：使用自动确认机制时，队列端处理异常导致生产端发送消息失败</li>
<li>解决办法：使用重试机制</li>
</ul>
</li>
</ul>
</li>
<li>入队时丢失<ul>
<li>场景1<ul>
<li>丢失原因：队列端服务强停时，消息还在内存缓冲区中没有持久化到磁盘</li>
<li>解决办法：开启持久化机制</li>
</ul>
</li>
<li>场景2<ul>
<li>丢失原因：队列端服务崩溃时，消息还在内存缓冲区中没有持久化到磁盘</li>
<li>解决办法：开启持久化机制</li>
</ul>
</li>
<li>场景3<ul>
<li>丢失原因：队列端机器宕机时，消息还在内存缓冲区中没有持久化到磁盘</li>
<li>解决办法：开启持久化机制</li>
</ul>
</li>
</ul>
</li>
<li>消费时丢失<ul>
<li>场景1<ul>
<li>丢失原因：使用手动确认机制时，消费端收到消息后忘记了返回ACK</li>
<li>解决办法：需要返回ACK</li>
</ul>
</li>
<li>场景2<ul>
<li>丢失原因：使用自动确认机制时，消费端收到消息后不管是否处理成功就返回了ACK</li>
<li>解决办法：需要在处理成功后返回ACK</li>
</ul>
</li>
<li>场景3<ul>
<li>丢失原因：使用手动确认机制时，消费端收到消息后使用了异步处理并立即返回了ACK</li>
<li>解决办法：需要在异步处理成功后返回ACK</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h4><p>TODO：消息重复</p>
<p>问题描述：消息重复<br>解决办法：幂等处理（数据库唯一性去重 或者 redis的setnx去重）</p>
<ul>
<li>生产时重复<ul>
<li>场景1<ul>
<li>重复原因：生产时，队列端回复的ACK丢失了，生产端没有收到ACK会重发</li>
<li>解决办法：队列端进行幂等处理</li>
</ul>
</li>
</ul>
</li>
<li>消费时重复<ul>
<li>场景1<ul>
<li>重复原因：消费时，消费端回复的ACK丢失了，队列端没有收到ACK会重推</li>
<li>解决办法：消费端进行幂等处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：反正最后都需要在消费端解决一下，所以只需要在消费端解决就行了</p>
</blockquote>
<h4 id="消息乱序"><a href="#消息乱序" class="headerlink" title="消息乱序"></a>消息乱序</h4><p>TODO：消息乱序</p>
<ul>
<li>生产时乱序<ul>
<li>场景1<ul>
<li>乱序原因：因为网络的复杂性，先生产的消息可能因发送时间长而后到达</li>
<li>解决办法：</li>
</ul>
</li>
<li>场景2<ul>
<li>乱序原因：因为消息的大小不同，先生产的消息可能因发送时间长而后到达</li>
<li>解决办法：</li>
</ul>
</li>
</ul>
</li>
<li>消费时乱序<ul>
<li>场景1<ul>
<li>乱序原因：存在多分区时，消息投递到了消息积压多的分区，导致比后面的消息晚消费</li>
<li>解决办法：生产时保证分区有序 或者 只创建一个分区</li>
</ul>
</li>
<li>场景2<ul>
<li>乱序原因：存在多分区时，先消费的消息可能晚于后消费的消息完成</li>
<li>解决办法：</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：总结为3种原因，1. 先发送但后到达 2. 先到达但后消费 3. 先消费但后完成</p>
</blockquote>
<h4 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h4><p>TODO：消息积压</p>
<h4 id="消息溢出"><a href="#消息溢出" class="headerlink" title="消息溢出"></a>消息溢出</h4><p>TODO：消息溢出</p>
<h3 id="Performance-2"><a href="#Performance-2" class="headerlink" title="Performance"></a>Performance</h3><h4 id="Kafka为什么这么快"><a href="#Kafka为什么这么快" class="headerlink" title="Kafka为什么这么快"></a>Kafka为什么这么快</h4><p>TODO：页缓存<br>TODO：零拷贝<br>TODO：时间轮</p>
<ul>
<li>顺序读写：寻址快</li>
<li>分区读写：并发读写</li>
<li>批量读写：减少网络耗时</li>
<li>数据压缩：减少数据量从而减少读写时间 </li>
<li>页缓存：避免实时写磁盘的慢操作</li>
<li>零拷贝：避免多次拷贝造成的时间浪费</li>
</ul>
<h2 id="Network-1"><a href="#Network-1" class="headerlink" title="Network"></a>Network</h2><h3 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h3><h4 id="OSI的7层模型"><a href="#OSI的7层模型" class="headerlink" title="OSI的7层模型"></a>OSI的7层模型</h4><h4 id="TCP-x2F-IP的5层模型"><a href="#TCP-x2F-IP的5层模型" class="headerlink" title="TCP&#x2F;IP的5层模型"></a>TCP&#x2F;IP的5层模型</h4><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><h4 id="TCP如何保证可靠传输的"><a href="#TCP如何保证可靠传输的" class="headerlink" title="TCP如何保证可靠传输的"></a>TCP如何保证可靠传输的</h4><h4 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h4><h4 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h4><h4 id="TCP的重传机制"><a href="#TCP的重传机制" class="headerlink" title="TCP的重传机制"></a>TCP的重传机制</h4><h4 id="TCP的滑动窗口"><a href="#TCP的滑动窗口" class="headerlink" title="TCP的滑动窗口"></a>TCP的滑动窗口</h4><h4 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h4><h4 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h4><h4 id="TCP的TIME-WAIT和CLOSE-WAIT"><a href="#TCP的TIME-WAIT和CLOSE-WAIT" class="headerlink" title="TCP的TIME_WAIT和CLOSE_WAIT"></a>TCP的TIME_WAIT和CLOSE_WAIT</h4><h2 id="Web-2"><a href="#Web-2" class="headerlink" title="Web"></a>Web</h2><h3 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h3><h4 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h4><h4 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h4><h4 id="输入url到显示页面的全过程"><a href="#输入url到显示页面的全过程" class="headerlink" title="输入url到显示页面的全过程"></a>输入url到显示页面的全过程</h4><h4 id="Http常用的状态码"><a href="#Http常用的状态码" class="headerlink" title="Http常用的状态码"></a>Http常用的状态码</h4><h4 id="Http和Https的区别"><a href="#Http和Https的区别" class="headerlink" title="Http和Https的区别"></a>Http和Https的区别</h4><h2 id="Distributed-3"><a href="#Distributed-3" class="headerlink" title="Distributed"></a>Distributed</h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ul>
<li>CAP<ul>
<li>C：强一致性：某个时刻读取所有节点的某个数据都是相同的（强一致性，不同于弱一致性和最终一致性）</li>
<li>A：高可用性：在有限的时间返回数据（不能出现等待延迟或者访问超时的情况）</li>
<li>P：分区容错性：网络故障出现分区后各个可用分区也能继续对外提供服务（而不是暂停服务去等待网络恢复）</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：在分布式系统中，因为网络的复杂性，所以一定会出现因为网络故障导致分区的情况，如果此时不保证分区容错性，就意味着允许部分节点不可用导致服务不能提供完整的服务，但是大部分得场景是不能忍受不完整的服务的，所以分布式系统中一般会保证分区容错性</p>
</blockquote>
<h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><ul>
<li>BASE<ul>
<li>BA：基本可用</li>
<li>S：软状态（允许有短暂的中间状态）</li>
<li>E：最终一致性</li>
</ul>
</li>
<li>ACID<ul>
<li>A：原子性</li>
<li>C：一致性</li>
<li>I：隔离性</li>
<li>D：持久性</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：BASE理论的一致性是最终一致性，而CAP和ACID的一致性是强一致性</p>
</blockquote>
<h3 id="分布式id"><a href="#分布式id" class="headerlink" title="分布式id"></a>分布式id</h3><p>TODO：分布式id</p>
<ul>
<li>时间戳</li>
<li>UUID</li>
<li>雪花id</li>
<li>mysql自增ID </li>
<li>redis自增ID</li>
</ul>
<p>SnowflakeId：1（符号位） + 41（时间戳） + 10（nodeId） + 12（offset）</p>
<blockquote>
<p>ps：nodeId &#x3D; 5（workId） + 5（datacenterId）<br>ps：时间戳是一个偏移量不一定要从 <code>1970-1-1</code> 开始，可以从第一次上线时间开始<br>ps：可以按照实际需求做调整，比如增加时间戳或者偏移量的位数</p>
</blockquote>
<p>machineId生成方案</p>
<ul>
<li>hostname（简单，固定，需要注意检查是不是localhost）</li>
<li>ip（复杂，可能会变，需要注意排除localhost和虚拟机ip）</li>
</ul>
<p>workId生成方案</p>
<ul>
<li>redis自增</li>
<li>machineId</li>
</ul>
<p>datacenterId生成方案</p>
<ul>
<li>redis自增</li>
</ul>
<p>如何解决时钟回拨</p>
<ul>
<li>UidGenerator<ul>
<li>每次启动时生成新的机器id避免启动时的时钟回拨问题</li>
<li>运行时检测到时钟回拨则抛出异常</li>
</ul>
</li>
<li>Leaf<ul>
<li>运行时检测到时钟回拨则阻塞等待直到时间到达</li>
</ul>
</li>
</ul>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>TODO：分布式锁（红锁）</p>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>TODO：分布式事务</p>
<p>事务的分类</p>
<ul>
<li>本地事务（ACID理论）<ul>
<li>2PC和3PC</li>
</ul>
</li>
<li>分布式事务<ul>
<li>刚性事务（CAP理论、强一致性）<ul>
<li>2PC和3PC（Seata-XA&#x2F;AT）</li>
</ul>
</li>
<li>柔性事务（BASE理论，最终一致性）<ul>
<li>补偿型<ul>
<li>TCC（Seata-TCC）</li>
<li>SAGA（Seata-SAGA）</li>
</ul>
</li>
<li>通知型<ul>
<li>确保通知型（本地消息表、MQ事务消息）</li>
<li>尽力通知型（本地消息表、MQ事务消息）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：XA&#x2F;AT是通用的事务协议（AT是高性能版的XA），JTA和JTS是Java的事务协议<br>ps：TCC和2PC的流程相似，TCC适用于业务系统，2PC适用于存储系统<br>ps：确保通知型适用于内部系统，尽力通知型适用于外部系统</p>
</blockquote>
<p>事务的概念</p>
<ul>
<li>TX：应用程序与事务管理器之间的接口协议</li>
<li>XA：事务管理器与资源管理器之间的接口协议</li>
<li>AP：应用程序</li>
<li>RM：资源管理器</li>
<li>TM：事务管理器</li>
<li>2PC：Prepare、Commit、Rollback，两阶段提交（Two-Phrase-Commit）</li>
<li>3PC：Can、Prepare、Commit、Rollback，三阶段提交（Three-Phrase-Commit）</li>
<li>TCC：Try、Confirm、Cancel，两阶段提交（Two-Phrase-Commit）</li>
</ul>
<blockquote>
<p>ps：XA规范是X&#x2F;Open组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准</p>
</blockquote>
<p>事务的问题</p>
<ul>
<li>空回滚：Try请求丢失了（网络丢包），只收到了Cancel请求，这时Cancel请求需要执行空回滚操作</li>
<li>悬挂：Try请求比Cancel请求后到达（网络延迟），Try比Cancel后执行占用的资源则无法释放</li>
<li>幂等：重复Commit或Rollback需要支持幂等</li>
</ul>
<p>事务的补偿</p>
<ul>
<li>回滚</li>
<li>重试</li>
</ul>
<p>事务的确保</p>
<ul>
<li>事务执行前发送半消息（半消息对消费者不可见）</li>
<li>事务执行成功发送全消息（全消息对消费者可见）</li>
<li>事务执行失败删除半消息</li>
</ul>
<p>2PC的问题</p>
<ul>
<li>性能问题：操作阻塞，锁定资源失败时会被阻塞</li>
<li>可靠性问题：协调故障，协调者挂掉后节点不会释放占用的资源</li>
<li>一致性问题：网络异常，只有部分节点提交或者回滚了数据</li>
</ul>
<blockquote>
<p>ps：问题的关键字：阻塞、协调、网络<br>ps：协调者有超时机制，节点没有超时机制</p>
</blockquote>
<p>3PC的问题</p>
<ul>
<li>一致性问题：网络异常，部分节点收到会滚请求后执行了回滚，部分节点超时后执行了提交</li>
</ul>
<blockquote>
<p>ps：3PC新增了can阶段来判断是否能够执行事务从而缩小了所阻塞范围<br>ps：3PC新增了节点超时机制来避免协调者挂掉后节点不会释放占用的资源的问题</p>
</blockquote>
<p>TCC的问题</p>
<ul>
<li>每个操作都需要支持额外的确认和取消操作</li>
<li>操作需要支持幂等</li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div>只想买包辣条</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/pay/wechatpay.jpeg" alt="朱继鹏 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/interview/" rel="tag"># + interview</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/09/03/tech/interview/interview-1-java-guide/" rel="prev" title="interview-java-guide">
      <i class="fa fa-chevron-left"></i> interview-java-guide
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%EF%BC%88%E6%A6%82%E8%A7%88%E7%AF%87%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">java面试重点（概览篇）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%EF%BC%88%E8%AF%AD%E8%A8%80%E7%AF%87%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">java面试重点（语言篇）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lang"><span class="nav-number">2.1.</span> <span class="nav-text">Lang</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Container"><span class="nav-number">2.2.</span> <span class="nav-text">Container</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Concurrency"><span class="nav-number">2.3.</span> <span class="nav-text">Concurrency</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO"><span class="nav-number">2.4.</span> <span class="nav-text">IO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">2.5.</span> <span class="nav-text">JVM</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%EF%BC%88%E9%80%9A%E7%94%A8%E7%AF%87%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">java面试重点（通用篇）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring"><span class="nav-number">3.1.</span> <span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-1"><span class="nav-number">3.1.1.</span> <span class="nav-text">Spring</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringBoot"><span class="nav-number">3.1.2.</span> <span class="nav-text">SpringBoot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringWeb"><span class="nav-number">3.1.3.</span> <span class="nav-text">SpringWeb</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringData"><span class="nav-number">3.1.4.</span> <span class="nav-text">SpringData</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringSecurity"><span class="nav-number">3.1.5.</span> <span class="nav-text">SpringSecurity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringCloud"><span class="nav-number">3.1.6.</span> <span class="nav-text">SpringCloud</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql"><span class="nav-number">3.2.</span> <span class="nav-text">Mysql</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis"><span class="nav-number">3.3.</span> <span class="nav-text">Redis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MQ"><span class="nav-number">3.4.</span> <span class="nav-text">MQ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Network"><span class="nav-number">3.5.</span> <span class="nav-text">Network</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Web"><span class="nav-number">3.6.</span> <span class="nav-text">Web</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Distributed"><span class="nav-number">3.7.</span> <span class="nav-text">Distributed</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%EF%BC%88%E8%AF%AD%E8%A8%80%E7%AF%87%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">java面试总结（语言篇）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lang-1"><span class="nav-number">4.1.</span> <span class="nav-text">Lang</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">4.1.1.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">String为什么是不可变的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">String为什么要设计成不可变的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E5%92%8CStringBuilder%E3%80%81StringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.1.3.</span> <span class="nav-text">String和StringBuilder、StringBuffer的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Integer"><span class="nav-number">4.1.2.</span> <span class="nav-text">Integer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Integer%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8-x3D-x3D-%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">Integer为什么不能使用&#x3D;&#x3D;进行比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object"><span class="nav-number">4.1.3.</span> <span class="nav-text">Object</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Object%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">Object的基本方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equals%E5%92%8C-x3D-x3D-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">equals和&#x3D;&#x3D;的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Container-1"><span class="nav-number">4.2.</span> <span class="nav-text">Container</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Container-2"><span class="nav-number">4.2.1.</span> <span class="nav-text">Container</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#List"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Array%E5%92%8CArrayList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.1.1.1.</span> <span class="nav-text">Array和ArrayList的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.1.1.2.</span> <span class="nav-text">ArrayList和LinkedList的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ArrayList%E5%92%8CVector%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.1.1.3.</span> <span class="nav-text">ArrayList和Vector的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Collections-synchronizedList%E5%92%8CVector%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.1.1.4.</span> <span class="nav-text">Collections.synchronizedList和Vector的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CopyOnWriteArrayList%E5%92%8CVector%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.1.1.5.</span> <span class="nav-text">CopyOnWriteArrayList和Vector的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CopyOnWriteArrayList%E5%92%8CCollections-synchronizedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.1.1.6.</span> <span class="nav-text">CopyOnWriteArrayList和Collections.synchronizedList的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88ArrayList%E5%AE%9E%E7%8E%B0%E4%BA%86RandomAccess%E6%8E%A5%E5%8F%A3%E8%80%8CLinkedList%E5%8D%B4%E6%B2%A1%E6%9C%89"><span class="nav-number">4.2.1.1.7.</span> <span class="nav-text">为什么ArrayList实现了RandomAccess接口而LinkedList却没有</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap%E5%92%8CConcurrentHashMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.1.2.1.</span> <span class="nav-text">HashMap和ConcurrentHashMap的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.1.2.2.</span> <span class="nav-text">HashMap和Hashtable的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Collections-synchronizedMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.1.2.3.</span> <span class="nav-text">Collections.synchronizedMap和Hashtable的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ConcurrentHashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.1.2.4.</span> <span class="nav-text">ConcurrentHashMap和Hashtable的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ConcurrentHashMap%E5%92%8CCollections-synchronizedMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.1.2.5.</span> <span class="nav-text">ConcurrentHashMap和Collections.synchronizedMap的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Queue"><span class="nav-number">4.2.1.3.</span> <span class="nav-text">Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Queue%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.1.3.1.</span> <span class="nav-text">Queue方法的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.2.1.3.2.</span> <span class="nav-text">双端队列的使用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ArrayDeque%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.1.3.3.</span> <span class="nav-text">ArrayDeque和LinkedList的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ArrayBlockingQueue%E5%92%8CLinkedBlockingQueue%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.1.3.4.</span> <span class="nav-text">ArrayBlockingQueue和LinkedBlockingQueue的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedBlockingQueue%E5%92%8CConcurrentLinkedQueue%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.1.3.5.</span> <span class="nav-text">LinkedBlockingQueue和ConcurrentLinkedQueue的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SynchronousQueue%E5%92%8CTransferQueue%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.1.3.6.</span> <span class="nav-text">SynchronousQueue和TransferQueue的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DelayQueue%E5%92%8CDelayedWorkQueue%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.1.3.7.</span> <span class="nav-text">DelayQueue和DelayedWorkQueue的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Traverse"><span class="nav-number">4.2.2.</span> <span class="nav-text">Traverse</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Iterator%E5%92%8CItreable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">Iterator和Itreable的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Iterator%E5%92%8CListIterator%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">Iterator和ListIterator的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%9A%84%E9%81%8D%E5%8E%86%E5%AE%B9%E5%99%A8"><span class="nav-number">4.2.2.3.</span> <span class="nav-text">如何高效的遍历容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List%E9%81%8D%E5%8E%86%E6%97%B6%E8%B0%83%E7%94%A8list-remove%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">4.2.2.4.</span> <span class="nav-text">List遍历时调用list.remove删除元素会有什么问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List%E9%81%8D%E5%8E%86%E6%97%B6%E6%80%8E%E4%B9%88%E5%AE%89%E5%85%A8%E7%9A%84%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">4.2.2.5.</span> <span class="nav-text">List遍历时怎么安全的删除元素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sorting"><span class="nav-number">4.2.3.</span> <span class="nav-text">Sorting</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Comparator%E5%92%8CComparable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.3.1.</span> <span class="nav-text">Comparator和Comparable的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nullable"><span class="nav-number">4.2.4.</span> <span class="nav-text">Nullable</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap%E4%B8%BA%E4%BB%80%E4%B9%88key%E5%92%8Cvalue%E4%B8%8D%E8%83%BD%E4%B8%BAnull"><span class="nav-number">4.2.4.1.</span> <span class="nav-text">ConcurrentHashMap为什么key和value不能为null</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Theory"><span class="nav-number">4.2.5.</span> <span class="nav-text">Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#List-1"><span class="nav-number">4.2.5.1.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ArrayList%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A9%E5%AE%B9%E7%9A%84"><span class="nav-number">4.2.5.1.1.</span> <span class="nav-text">ArrayList是如何扩容的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ArrayList%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%89%E5%A4%A7%E7%BA%A61-5%E5%80%8D%E6%89%A9%E5%AE%B9"><span class="nav-number">4.2.5.1.2.</span> <span class="nav-text">ArrayList为什么按大约1.5倍扩容</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map-1"><span class="nav-number">4.2.5.2.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Map-2"><span class="nav-number">4.2.5.2.1.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E6%97%B6%E8%A6%81%E9%87%8D%E5%86%99hashCode"><span class="nav-number">4.2.5.2.1.1.</span> <span class="nav-text">为什么重写equals时要重写hashCode</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%87%8D%E5%86%99equals%E5%92%8ChashCode%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">4.2.5.2.1.2.</span> <span class="nav-text">重写equals和hashCode的设计原则</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#hash%E5%86%B2%E7%AA%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">4.2.5.2.1.3.</span> <span class="nav-text">hash冲突如何解决</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#hash%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BD%95%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%BD%8D%E7%A7%BB%E5%90%8E%E5%BC%82%E6%88%96"><span class="nav-number">4.2.5.2.1.4.</span> <span class="nav-text">hash方法为何要进行位移后异或</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Map%E7%9A%84%E5%AE%B9%E9%87%8F%E5%A4%A7%E5%B0%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF2%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9"><span class="nav-number">4.2.5.2.1.5.</span> <span class="nav-text">Map的容量大小为什么必须是2的幂次方</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap"><span class="nav-number">4.2.5.2.2.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="nav-number">4.2.5.2.2.1.</span> <span class="nav-text">HashMap的实现原理和核心逻辑</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#java7%E5%92%8Cjava8%E7%9A%84HashMap%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.5.2.2.2.</span> <span class="nav-text">java7和java8的HashMap区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#java8%E7%9A%84HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">4.2.5.2.2.3.</span> <span class="nav-text">java8的HashMap为什么要用红黑树</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#java8%E7%9A%84HashMap%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%98%AF%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"><span class="nav-number">4.2.5.2.2.4.</span> <span class="nav-text">java8的HashMap中的红黑树是排序规则</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#java8%E7%9A%84HashMap%E4%B8%AD%E9%93%BE%E8%A1%A8%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2%E6%9D%A1%E4%BB%B6"><span class="nav-number">4.2.5.2.2.5.</span> <span class="nav-text">java8的HashMap中链表和红黑树的转换条件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#HashMap%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A9%E5%AE%B9%E7%9A%84"><span class="nav-number">4.2.5.2.2.6.</span> <span class="nav-text">HashMap是如何扩容的</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#HashMap%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="nav-number">4.2.5.2.2.7.</span> <span class="nav-text">HashMap有哪些并发问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#HashMap%E4%BD%BF%E7%94%A8%E6%97%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">4.2.5.2.2.8.</span> <span class="nav-text">HashMap使用时如何保证线程安全</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">4.2.5.2.3.</span> <span class="nav-text">ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#ConcurrentHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="nav-number">4.2.5.2.3.1.</span> <span class="nav-text">ConcurrentHashMap的实现原理和核心逻辑</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#java7%E5%92%8Cjava8%E7%9A%84ConcurrentHashMap%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.5.2.3.2.</span> <span class="nav-text">java7和java8的ConcurrentHashMap区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#java7%E7%9A%84ConcurrentHashMap%E7%9A%84%E5%B9%B6%E5%8F%91%E5%BA%A6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">4.2.5.2.3.3.</span> <span class="nav-text">java7的ConcurrentHashMap的并发度是什么</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#java8%E7%9A%84ConcurrentHashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%BE%E5%BC%83%E4%BA%86%E5%88%86%E6%AE%B5%E9%94%81"><span class="nav-number">4.2.5.2.3.4.</span> <span class="nav-text">java8的ConcurrentHashMap为什么放弃了分段锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ConcurrentHashMap%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97size%E7%9A%84"><span class="nav-number">4.2.5.2.3.5.</span> <span class="nav-text">ConcurrentHashMap是如何计算size的</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ConcurrentHashMap%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A9%E5%AE%B9%E7%9A%84"><span class="nav-number">4.2.5.2.3.6.</span> <span class="nav-text">ConcurrentHashMap是如何扩容的</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ConcurrentHashMap%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84"><span class="nav-number">4.2.5.2.3.7.</span> <span class="nav-text">ConcurrentHashMap是如何保证线程安全的</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ConcurrentHashMap%E8%BF%98%E6%9C%89%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%90%97"><span class="nav-number">4.2.5.2.3.8.</span> <span class="nav-text">ConcurrentHashMap还有并发问题吗</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Queue-1"><span class="nav-number">4.2.5.3.</span> <span class="nav-text">Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ArrayBlockingQueue%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%98%BB%E5%A1%9E%E5%8A%9F%E8%83%BD%E7%9A%84"><span class="nav-number">4.2.5.3.1.</span> <span class="nav-text">ArrayBlockingQueue是如何实现阻塞功能的</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Concurrency-1"><span class="nav-number">4.3.</span> <span class="nav-text">Concurrency</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread"><span class="nav-number">4.3.1.</span> <span class="nav-text">Thread</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">线程的创建方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96"><span class="nav-number">4.3.1.2.</span> <span class="nav-text">线程的状态变化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.1.3.</span> <span class="nav-text">线程的控制方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BA%9F%E5%BC%83%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.1.4.</span> <span class="nav-text">线程的废弃方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E7%96%91%E9%97%AE"><span class="nav-number">4.3.1.5.</span> <span class="nav-text">线程的相关疑问</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.1.5.1.</span> <span class="nav-text">线程和进程的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Runnable%E5%92%8CCallable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.1.5.2.</span> <span class="nav-text">Runnable和Callable的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Thread%E7%9A%84start%E5%92%8Crun%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.1.5.3.</span> <span class="nav-text">Thread的start和run的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Thread%E7%9A%84start%E8%83%BD%E8%B0%83%E7%94%A8%E5%A4%9A%E6%AC%A1%E5%90%97"><span class="nav-number">4.3.1.5.4.</span> <span class="nav-text">Thread的start能调用多次吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Thread%E7%9A%84sleep%E5%92%8Cyield%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.1.5.5.</span> <span class="nav-text">Thread的sleep和yield的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Thread%E7%9A%84sleep%E5%92%8Cjoin%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.1.5.6.</span> <span class="nav-text">Thread的sleep和join的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Thread%E7%9A%84join%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.1.5.7.</span> <span class="nav-text">Thread的join和wait的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">4.3.2.</span> <span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">ThreadLocal为什么会内存泄漏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocalMap%E7%9A%84key%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">ThreadLocalMap的key为什么是弱引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocalMap%E7%9A%84value%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="nav-number">4.3.2.3.</span> <span class="nav-text">ThreadLocalMap的value为什么是强引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocalMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8Thread%E5%81%9Akey"><span class="nav-number">4.3.2.4.</span> <span class="nav-text">ThreadLocalMap为什么不用Thread做key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AE%9A%E4%B9%89%E6%88%90%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">4.3.2.5.</span> <span class="nav-text">ThreadLocal为什么要定义成静态变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.2.6.</span> <span class="nav-text">ThreadLocal和局部变量的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Safe"><span class="nav-number">4.3.3.</span> <span class="nav-text">Safe</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">什么是线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">4.3.3.2.</span> <span class="nav-text">如何保证线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile%E8%83%BD%E7%A1%AE%E4%BF%9D%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E5%90%97"><span class="nav-number">4.3.3.3.</span> <span class="nav-text">volatile能确保线程安全性吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">4.3.3.4.</span> <span class="nav-text">volatile的底层实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%8C%E6%A3%80%E6%9F%A5%E5%AE%9E%E7%8E%B0%E4%B8%ADvolatile%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.3.3.5.</span> <span class="nav-text">单例模式的双检查实现中volatile的作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock"><span class="nav-number">4.3.4.</span> <span class="nav-text">Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.3.4.1.</span> <span class="nav-text">锁的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.4.1.1.</span> <span class="nav-text">并发操作的控制方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E7%9A%84%E8%AF%BB%E5%86%99%E6%8E%A7%E5%88%B6"><span class="nav-number">4.3.4.1.2.</span> <span class="nav-text">并发操作的读写控制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">4.3.4.2.</span> <span class="nav-text">锁的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="nav-number">4.3.4.2.1.</span> <span class="nav-text">锁的类型分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E7%B1%BB"><span class="nav-number">4.3.4.2.2.</span> <span class="nav-text">锁的实现分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E8%8C%83%E5%9B%B4%E5%88%86%E7%B1%BB"><span class="nav-number">4.3.4.2.3.</span> <span class="nav-text">锁的范围分类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">4.3.4.3.</span> <span class="nav-text">锁的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">4.3.4.4.</span> <span class="nav-text">锁的特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.3.4.5.</span> <span class="nav-text">锁的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="nav-number">4.3.4.5.1.</span> <span class="nav-text">死锁问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A5%A5%E9%A5%BF%E9%97%AE%E9%A2%98"><span class="nav-number">4.3.4.5.2.</span> <span class="nav-text">饥饿问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E5%90%8C%E6%AD%A5%E9%94%81"><span class="nav-number">4.3.4.6.</span> <span class="nav-text">synchronized同步锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#synchronized%E9%94%81%E5%8E%9F%E7%90%86"><span class="nav-number">4.3.4.6.1.</span> <span class="nav-text">synchronized锁原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#synchronized%E9%94%81%E4%BC%98%E5%8C%96"><span class="nav-number">4.3.4.6.2.</span> <span class="nav-text">synchronized锁优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#synchronized%E9%94%81%E8%86%A8%E8%83%80"><span class="nav-number">4.3.4.6.3.</span> <span class="nav-text">synchronized锁膨胀</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#synchronized%E9%94%81%E6%B6%88%E9%99%A4"><span class="nav-number">4.3.4.6.4.</span> <span class="nav-text">synchronized锁消除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#synchronized%E9%94%81%E7%B2%97%E5%8C%96"><span class="nav-number">4.3.4.6.5.</span> <span class="nav-text">synchronized锁粗化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#synchronized%E9%94%81%E8%87%AA%E6%97%8B"><span class="nav-number">4.3.4.6.6.</span> <span class="nav-text">synchronized锁自旋</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#synchronized%E9%94%81%E7%96%91%E9%97%AE"><span class="nav-number">4.3.4.6.7.</span> <span class="nav-text">synchronized锁疑问</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#synchronized%E5%92%8Cvolatile%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.4.6.7.1.</span> <span class="nav-text">synchronized和volatile的区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#synchronized%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.4.6.7.2.</span> <span class="nav-text">synchronized和Lock的区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#synchronized%E5%92%8CReentrantLock%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E7%9A%84"><span class="nav-number">4.3.4.6.7.3.</span> <span class="nav-text">synchronized和ReentrantLock为什么默认是非公平的</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ReentrantLock%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%85%AC%E5%B9%B3%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E6%80%A7%E7%9A%84"><span class="nav-number">4.3.4.6.7.4.</span> <span class="nav-text">ReentrantLock是如何实现公平和非公平性的</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#synchronized%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84"><span class="nav-number">4.3.4.6.7.5.</span> <span class="nav-text">synchronized是如何保证线程安全的</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#wait%E5%92%8Cnotify%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%8D%E4%BA%8Esynchronized%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%AD"><span class="nav-number">4.3.4.6.7.6.</span> <span class="nav-text">wait和notify为什么要位于synchronized代码块中</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock%E5%92%8CReentrantReadWriteLock"><span class="nav-number">4.3.4.7.</span> <span class="nav-text">ReentrantLock和ReentrantReadWriteLock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#lock-lock-%E5%86%99%E5%9C%A8-try-%E4%BB%A3%E7%A0%81%E5%9D%97%E5%86%85%E9%83%A8%E8%A1%8C%E5%90%97"><span class="nav-number">4.3.4.7.1.</span> <span class="nav-text">lock.lock() 写在 try 代码块内部行吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E7%9A%84unlock"><span class="nav-number">4.3.4.7.2.</span> <span class="nav-text">如何安全的unlock</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS"><span class="nav-number">4.3.4.8.</span> <span class="nav-text">CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CAS%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.3.4.8.1.</span> <span class="nav-text">CAS存在的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="nav-number">4.3.4.8.2.</span> <span class="nav-text">乐观锁的优点和缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="nav-number">4.3.4.8.3.</span> <span class="nav-text">自旋锁的优点和缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS"><span class="nav-number">4.3.4.9.</span> <span class="nav-text">AQS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Task"><span class="nav-number">4.3.5.</span> <span class="nav-text">Task</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FutureTask%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96"><span class="nav-number">4.3.5.1.</span> <span class="nav-text">FutureTask的状态变化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FutureTask%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%AF%E6%8C%81%E4%BC%A0%E9%80%92%E7%BB%99%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.3.5.2.</span> <span class="nav-text">FutureTask为什么支持传递给线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor"><span class="nav-number">4.3.6.</span> <span class="nav-text">Executor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.6.1.</span> <span class="nav-text">线程池的创建方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="nav-number">4.3.6.2.</span> <span class="nav-text">线程池的核心参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8F%90%E4%BA%A4%E7%AD%96%E7%95%A5"><span class="nav-number">4.3.6.3.</span> <span class="nav-text">线程池的提交策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F"><span class="nav-number">4.3.6.4.</span> <span class="nav-text">线程池的线程数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-number">4.3.6.5.</span> <span class="nav-text">线程池的工作队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5"><span class="nav-number">4.3.6.6.</span> <span class="nav-text">线程池的饱和策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.6.7.</span> <span class="nav-text">线程池的提交方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#submit%E5%92%8Cexecute%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.6.7.1.</span> <span class="nav-text">submit和execute的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7"><span class="nav-number">4.3.6.8.</span> <span class="nav-text">线程池的异常捕获</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%85%B3%E9%97%AD%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.6.9.</span> <span class="nav-text">线程池的关闭方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#shutdown%E5%92%8CshutdownNow%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.6.9.1.</span> <span class="nav-text">shutdown和shutdownNow的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96"><span class="nav-number">4.3.6.10.</span> <span class="nav-text">线程池的状态变化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%9B%B8%E5%85%B3%E7%96%91%E9%97%AE"><span class="nav-number">4.3.6.11.</span> <span class="nav-text">线程池的相关疑问</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E4%B8%8D%E8%A2%AB%E9%94%80%E6%AF%81%E7%9A%84"><span class="nav-number">4.3.6.11.1.</span> <span class="nav-text">线程池是如何保证核心线程不被销毁的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%87%8C%E7%9A%84%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%B7%B2%E7%BB%8F%E5%AE%8C%E6%88%90%E4%BA%86"><span class="nav-number">4.3.6.11.2.</span> <span class="nav-text">如何知道线程池里的的任务已经完成了</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO-1"><span class="nav-number">4.4.</span> <span class="nav-text">IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E4%BD%93%E7%B3%BB%E7%9B%B8%E5%85%B3"><span class="nav-number">4.4.1.</span> <span class="nav-text">IO体系相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3"><span class="nav-number">4.4.2.</span> <span class="nav-text">IO模型相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BIO%E5%92%8CNIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">BIO和NIO的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stream%E5%92%8CChannel%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.4.2.2.</span> <span class="nav-text">Stream和Channel的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">4.4.3.</span> <span class="nav-text">IO多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C10K%E5%92%8Cepoll"><span class="nav-number">4.4.3.1.</span> <span class="nav-text">C10K和epoll</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.4.4.</span> <span class="nav-text">IO并发模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Reactor%E5%92%8CProactor"><span class="nav-number">4.4.4.1.</span> <span class="nav-text">Reactor和Proactor</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.4.5.</span> <span class="nav-text">IO设计模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-1"><span class="nav-number">4.5.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90"><span class="nav-number">4.5.1.</span> <span class="nav-text">JVM主要组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="nav-number">4.5.2.</span> <span class="nav-text">JVM核心功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E8%BF%90%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA"><span class="nav-number">4.5.3.</span> <span class="nav-text">JVM运行数据分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">4.5.4.</span> <span class="nav-text">JVM内存分配策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E5%9E%83%E5%9C%BE%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%94%B6"><span class="nav-number">4.5.5.</span> <span class="nav-text">JVM垃圾数据回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%88%86%E4%BB%A3%E6%8A%80%E6%9C%AF"><span class="nav-number">4.5.5.1.</span> <span class="nav-text">垃圾分代技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95"><span class="nav-number">4.5.5.2.</span> <span class="nav-text">垃圾标记算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95"><span class="nav-number">4.5.5.2.1.</span> <span class="nav-text">对象存活判断方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95"><span class="nav-number">4.5.5.2.2.</span> <span class="nav-text">对象存活标记算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E6%AD%A5%E9%AA%A4"><span class="nav-number">4.5.5.2.3.</span> <span class="nav-text">并发标记步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E9%97%AE%E9%A2%98"><span class="nav-number">4.5.5.2.4.</span> <span class="nav-text">并发标记问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%BC%8F%E6%A0%87%E8%A7%A3%E5%86%B3"><span class="nav-number">4.5.5.2.5.</span> <span class="nav-text">并发漏标解决</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">4.5.5.3.</span> <span class="nav-text">垃圾回收算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%97%B6%E6%9C%BA"><span class="nav-number">4.5.5.4.</span> <span class="nav-text">垃圾回收时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">4.5.5.5.</span> <span class="nav-text">垃圾回收过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%88%86%E7%B1%BB"><span class="nav-number">4.5.5.6.</span> <span class="nav-text">垃圾回收器分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%AF%B9%E6%AF%94"><span class="nav-number">4.5.5.6.1.</span> <span class="nav-text">新生代垃圾回收器对比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%80%81%E7%94%9F%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%AF%B9%E6%AF%94"><span class="nav-number">4.5.5.6.2.</span> <span class="nav-text">老生代垃圾回收器对比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">4.5.5.6.3.</span> <span class="nav-text">主要垃圾回收器的特点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%90%AD%E9%85%8D"><span class="nav-number">4.5.5.7.</span> <span class="nav-text">垃圾回收器搭配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E7%B1%BB"><span class="nav-number">4.5.6.</span> <span class="nav-text">JVM类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">4.5.6.1.</span> <span class="nav-text">类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB"><span class="nav-number">4.5.6.1.1.</span> <span class="nav-text">类加载器分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">4.5.6.1.2.</span> <span class="nav-text">类加载过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">4.5.6.2.</span> <span class="nav-text">双亲委派机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.5.6.2.1.</span> <span class="nav-text">双亲委派机制的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E8%A6%81%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">4.5.6.2.2.</span> <span class="nav-text">为什么有时候要打破双亲委派机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">4.5.6.2.3.</span> <span class="nav-text">如何打破双亲委派机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.5.7.</span> <span class="nav-text">JVM对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">4.5.7.1.</span> <span class="nav-text">对象生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">4.5.7.2.</span> <span class="nav-text">对象初始化过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">4.5.7.3.</span> <span class="nav-text">对象内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%A9%BAObject%E5%AF%B9%E8%B1%A1%E5%8D%A0%E5%A4%9A%E5%A4%A7%E7%9A%84%E7%A9%BA%E9%97%B4"><span class="nav-number">4.5.7.3.1.</span> <span class="nav-text">一个空Object对象占多大的空间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="nav-number">4.5.8.</span> <span class="nav-text">JVM问题排查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JMM"><span class="nav-number">4.5.9.</span> <span class="nav-text">JMM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%89%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="nav-number">4.5.9.1.</span> <span class="nav-text">线程安全的三大原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#happens-before%E7%9A%848%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="nav-number">4.5.9.2.</span> <span class="nav-text">happens-before的8大原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JMM%E7%9A%848%E7%A7%8D%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">4.5.9.3.</span> <span class="nav-text">JMM的8种原子操作</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%EF%BC%88%E9%80%9A%E7%94%A8%E7%AF%87%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">java面试总结（通用篇）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-2"><span class="nav-number">5.1.</span> <span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-3"><span class="nav-number">5.1.1.</span> <span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IOC"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">IOC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#DI"><span class="nav-number">5.1.1.1.1.</span> <span class="nav-text">DI</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Spring%E7%9A%84bean%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%B3%A8%E5%86%8C%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.1.1.1.1.</span> <span class="nav-text">Spring的bean对象的三种注册方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Spring%E7%9A%84bean%E4%BE%9D%E8%B5%96%E7%9A%84%E4%B8%89%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.1.1.1.2.</span> <span class="nav-text">Spring的bean依赖的三种注入方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Spring%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="nav-number">5.1.1.1.1.3.</span> <span class="nav-text">Spring自动装配</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Spring%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="nav-number">5.1.1.1.1.4.</span> <span class="nav-text">Spring懒加载</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-number">5.1.1.1.1.5.</span> <span class="nav-text">Spring循环依赖</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Bean"><span class="nav-number">5.1.1.1.2.</span> <span class="nav-text">Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">5.1.1.1.2.1.</span> <span class="nav-text">bean的作用域</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#bean%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">5.1.1.1.2.2.</span> <span class="nav-text">bean的线程安全</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">5.1.1.1.2.3.</span> <span class="nav-text">bean的生命周期</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IOC-1"><span class="nav-number">5.1.1.1.3.</span> <span class="nav-text">IOC</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#IOC%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">5.1.1.1.3.1.</span> <span class="nav-text">IOC容器的初始化过程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#BeanFactory%E5%92%8CFactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.1.1.3.2.</span> <span class="nav-text">BeanFactory和FactoryBean的区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#BeanFactory%E5%92%8CApplicationContext%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.1.1.3.3.</span> <span class="nav-text">BeanFactory和ApplicationContext的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOP"><span class="nav-number">5.1.1.2.</span> <span class="nav-text">AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AOP%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-number">5.1.1.2.1.</span> <span class="nav-text">AOP的核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AOP%E7%9A%84%E9%80%9A%E7%9F%A5%E9%A1%BA%E5%BA%8F"><span class="nav-number">5.1.1.2.2.</span> <span class="nav-text">AOP的通知顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AOP%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.1.1.2.3.</span> <span class="nav-text">AOP的使用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AOP%E7%9A%84%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="nav-number">5.1.1.2.4.</span> <span class="nav-text">AOP的失效场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AOP%E7%9A%84%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.1.1.2.5.</span> <span class="nav-text">AOP的代理实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Proxy"><span class="nav-number">5.1.1.3.</span> <span class="nav-text">Proxy</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.1.3.1.</span> <span class="nav-text">Spring代理的实现方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring%E4%BB%A3%E7%90%86%E7%9A%84%E7%94%9F%E6%88%90%E6%97%B6%E6%9C%BA"><span class="nav-number">5.1.1.3.2.</span> <span class="nav-text">Spring代理的生成时机</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringBoot-1"><span class="nav-number">5.1.2.</span> <span class="nav-text">SpringBoot</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringBoot%E5%92%8CSpring%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">SpringBoot和Spring的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringBootConfiguration"><span class="nav-number">5.1.2.2.</span> <span class="nav-text">SpringBootConfiguration</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AutoConfiguration"><span class="nav-number">5.1.2.2.1.</span> <span class="nav-text">AutoConfiguration</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringBootStarter"><span class="nav-number">5.1.2.3.</span> <span class="nav-text">SpringBootStarter</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringWeb-1"><span class="nav-number">5.1.3.</span> <span class="nav-text">SpringWeb</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Mvc"><span class="nav-number">5.1.3.1.</span> <span class="nav-text">Mvc</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B%E6%8F%8F%E8%BF%B0"><span class="nav-number">5.1.3.1.1.</span> <span class="nav-text">请求流程描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E8%BF%87%E6%BB%A4%E6%8B%A6%E6%88%AA"><span class="nav-number">5.1.3.1.2.</span> <span class="nav-text">请求过滤拦截</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Filter%EF%BC%88%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%89%E5%92%8CInterceptor%EF%BC%88%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%89%E5%AF%B9%E6%AF%94"><span class="nav-number">5.1.3.1.2.1.</span> <span class="nav-text">Filter（过滤器）和Interceptor（拦截器）对比</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Filter%EF%BC%88%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%89%E5%92%8CInterceptor%EF%BC%88%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%89%E9%A1%BA%E5%BA%8F"><span class="nav-number">5.1.3.1.2.2.</span> <span class="nav-text">Filter（过滤器）和Interceptor（拦截器）顺序</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8E%E7%AB%AF%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E8%B7%A8%E5%9F%9F%E5%8A%9F%E8%83%BD"><span class="nav-number">5.1.3.1.3.</span> <span class="nav-text">后端如何支持跨域功能</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Web-1"><span class="nav-number">5.1.3.2.</span> <span class="nav-text">Web</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%B9%82%E7%AD%89"><span class="nav-number">5.1.3.2.1.</span> <span class="nav-text">如何实现幂等</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4"><span class="nav-number">5.1.3.2.2.</span> <span class="nav-text">如何防止重复提交</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD"><span class="nav-number">5.1.3.2.3.</span> <span class="nav-text">接口如何提高性能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringData-1"><span class="nav-number">5.1.4.</span> <span class="nav-text">SpringData</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Mybatis"><span class="nav-number">5.1.4.1.</span> <span class="nav-text">Mybatis</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.4.1.1.</span> <span class="nav-text">${}和#{}的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#where%E4%B8%AD%E7%9A%841-x3D-1%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">5.1.4.1.2.</span> <span class="nav-text">where中的1&#x3D;1的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%97%B6%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE"><span class="nav-number">5.1.4.1.3.</span> <span class="nav-text">插入时如何返回主键</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%8D%E5%92%8C%E8%A1%A8%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%8D%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">5.1.4.1.4.</span> <span class="nav-text">类的属性名和表的字段名不一样的解决办法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="nav-number">5.1.4.1.5.</span> <span class="nav-text">分页查询的实现方案</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">5.1.4.1.6.</span> <span class="nav-text">分页插件的基本原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="nav-number">5.1.4.1.7.</span> <span class="nav-text">关联查询的实现方案</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">5.1.4.1.8.</span> <span class="nav-text">Mybatis一级缓存的缓存一致性问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Mybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">5.1.4.1.9.</span> <span class="nav-text">Mybatis二级缓存的缓存一致性问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Transaction"><span class="nav-number">5.1.4.2.</span> <span class="nav-text">Transaction</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.4.2.1.</span> <span class="nav-text">事务的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Spring%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90-Transactional%E6%B3%A8%E8%A7%A3"><span class="nav-number">5.1.4.2.1.1.</span> <span class="nav-text">Spring事务实现为什么不推荐@Transactional注解</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="nav-number">5.1.4.2.2.</span> <span class="nav-text">事务的失效场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.4.2.3.</span> <span class="nav-text">事务的传播方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringSecurity-1"><span class="nav-number">5.1.5.</span> <span class="nav-text">SpringSecurity</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%EF%BC%88SSO%EF%BC%89"><span class="nav-number">5.1.5.1.</span> <span class="nav-text">单点登录流程（SSO）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="nav-number">5.1.5.2.</span> <span class="nav-text">扫码登录流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringCloud-1"><span class="nav-number">5.1.6.</span> <span class="nav-text">SpringCloud</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-number">5.1.6.1.</span> <span class="nav-text">微服务的核心组件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86"><span class="nav-number">5.1.6.1.1.</span> <span class="nav-text">服务治理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8"><span class="nav-number">5.1.6.1.2.</span> <span class="nav-text">服务调用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="nav-number">5.1.6.2.</span> <span class="nav-text">微服务的实现方案</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SpringCloudNetflix"><span class="nav-number">5.1.6.2.1.</span> <span class="nav-text">SpringCloudNetflix</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SpringCloudAlibaba"><span class="nav-number">5.1.6.2.2.</span> <span class="nav-text">SpringCloudAlibaba</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SpringCloudOfficial"><span class="nav-number">5.1.6.2.3.</span> <span class="nav-text">SpringCloudOfficial</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql-1"><span class="nav-number">5.2.</span> <span class="nav-text">Mysql</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic"><span class="nav-number">5.2.1.</span> <span class="nav-text">Basic</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Concept"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">Concept</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Engine"><span class="nav-number">5.2.1.1.1.</span> <span class="nav-text">Engine</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#MyISAM%E5%92%8CInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.1.1.1.1.</span> <span class="nav-text">MyISAM和InnoDB的区别</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Usage"><span class="nav-number">5.2.2.</span> <span class="nav-text">Usage</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DDL"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">DDL</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Type"><span class="nav-number">5.2.2.1.1.</span> <span class="nav-text">Type</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#char%E5%92%8Cvarchar%E5%AF%B9%E6%AF%94%E5%92%8C%E9%80%89%E6%8B%A9"><span class="nav-number">5.2.2.1.1.1.</span> <span class="nav-text">char和varchar对比和选择</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#varchar%E5%92%8Ctext%E5%AF%B9%E6%AF%94%E5%92%8C%E9%80%89%E6%8B%A9"><span class="nav-number">5.2.2.1.1.2.</span> <span class="nav-text">varchar和text对比和选择</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#char%E5%92%8Cvarchar%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">5.2.2.1.1.3.</span> <span class="nav-text">char和varchar的默认值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#char%E5%92%8Cvarchar%E7%9A%84%E7%A9%BA%E6%A0%BC%E5%A4%84%E7%90%86"><span class="nav-number">5.2.2.1.1.4.</span> <span class="nav-text">char和varchar的空格处理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#char%E5%92%8Cvarchar%E7%9A%84%E9%95%BF%E5%BA%A6%E9%80%89%E6%8B%A9"><span class="nav-number">5.2.2.1.1.5.</span> <span class="nav-text">char和varchar的长度选择</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#datetime%E5%92%8Ctimestamp%E5%AF%B9%E6%AF%94%E5%92%8C%E9%80%89%E6%8B%A9"><span class="nav-number">5.2.2.1.1.6.</span> <span class="nav-text">datetime和timestamp对比和选择</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#datetime%E5%92%8Ctimestamp%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">5.2.2.1.1.7.</span> <span class="nav-text">datetime和timestamp的默认值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#datetime%E5%92%8Ctimestamp%E7%9A%84%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0"><span class="nav-number">5.2.2.1.1.8.</span> <span class="nav-text">datetime和timestamp的自动更新</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Constraint"><span class="nav-number">5.2.2.1.2.</span> <span class="nav-text">Constraint</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E5%A4%96%E9%94%AE"><span class="nav-number">5.2.2.1.2.1.</span> <span class="nav-text">为什么不推荐外键</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Id"><span class="nav-number">5.2.2.1.3.</span> <span class="nav-text">Id</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90uuid%E5%92%8C%E9%9B%AA%E8%8A%B1id"><span class="nav-number">5.2.2.1.3.1.</span> <span class="nav-text">为什么不推荐uuid和雪花id</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DQL"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">DQL</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.2.2.2.1.</span> <span class="nav-text">常规查询</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#sql%E8%AF%AD%E5%8F%A5%E4%B9%A6%E5%86%99%E9%A1%BA%E5%BA%8F"><span class="nav-number">5.2.2.2.1.1.</span> <span class="nav-text">sql语句书写顺序</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">5.2.2.2.1.2.</span> <span class="nav-text">sql语句执行顺序</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A6%82%E4%BD%95%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5"><span class="nav-number">5.2.2.2.1.3.</span> <span class="nav-text">大数据量如何深度分页</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.2.2.2.2.</span> <span class="nav-text">组合查询</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#union%E5%92%8Cunion-all%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.2.2.2.1.</span> <span class="nav-text">union和union all的区别</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.2.2.2.3.</span> <span class="nav-text">聚合查询</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#count-1-%E5%92%8Ccount-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.2.2.3.1.</span> <span class="nav-text">count(1)和count(*)的区别</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.2.2.2.4.</span> <span class="nav-text">关联查询</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#on%E5%92%8Cwhere%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.2.2.4.1.</span> <span class="nav-text">on和where的区别</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.2.2.2.5.</span> <span class="nav-text">子查询</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#in%E5%92%8Cexists%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.2.2.5.1.</span> <span class="nav-text">in和exists的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Index"><span class="nav-number">5.2.2.3.</span> <span class="nav-text">Index</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="nav-number">5.2.2.3.1.</span> <span class="nav-text">索引分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%8E%9F%E5%88%99"><span class="nav-number">5.2.2.3.2.</span> <span class="nav-text">索引原则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="nav-number">5.2.2.3.3.</span> <span class="nav-text">索引失效</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="nav-number">5.2.2.3.4.</span> <span class="nav-text">索引优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE"><span class="nav-number">5.2.2.3.5.</span> <span class="nav-text">索引访问</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86"><span class="nav-number">5.2.2.3.6.</span> <span class="nav-text">索引原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transaction-1"><span class="nav-number">5.2.3.</span> <span class="nav-text">Transaction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ACID"><span class="nav-number">5.2.3.1.</span> <span class="nav-text">ACID</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E6%98%AFRR"><span class="nav-number">5.2.3.1.1.</span> <span class="nav-text">mysql事务隔离级别为什么默认是RR</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVCC"><span class="nav-number">5.2.3.2.</span> <span class="nav-text">MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">5.2.3.2.1.</span> <span class="nav-text">MVCC实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5"><span class="nav-number">5.2.3.2.2.</span> <span class="nav-text">MVCC实现原理之隐藏字段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8BReadView"><span class="nav-number">5.2.3.2.3.</span> <span class="nav-text">MVCC实现原理之ReadView</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MVCC%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">5.2.3.2.4.</span> <span class="nav-text">MVCC和隔离级别的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MVCC%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98%E4%BA%86%E5%90%97"><span class="nav-number">5.2.3.2.5.</span> <span class="nav-text">MVCC彻底解决幻读问题了吗</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lock-1"><span class="nav-number">5.2.3.3.</span> <span class="nav-text">Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">5.2.3.3.1.</span> <span class="nav-text">锁和隔离级别的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E5%92%8C%E6%9F%A5%E8%AF%A2%E7%B4%A2%E5%BC%95%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">5.2.3.3.2.</span> <span class="nav-text">锁和查询索引的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E5%92%8C%E6%9F%A5%E8%AF%A2%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">5.2.3.3.3.</span> <span class="nav-text">锁和查询类型的关系</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Log"><span class="nav-number">5.2.3.4.</span> <span class="nav-text">Log</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81undolog"><span class="nav-number">5.2.3.4.1.</span> <span class="nav-text">为什么需要undolog</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81redolog"><span class="nav-number">5.2.3.4.2.</span> <span class="nav-text">为什么需要redolog</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81binlog"><span class="nav-number">5.2.3.4.3.</span> <span class="nav-text">为什么需要binlog</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undolog%E3%80%81redolog%E3%80%81binlog%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.3.4.4.</span> <span class="nav-text">undolog、redolog、binlog的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undolog%E3%80%81redolog%E3%80%81binlog%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="nav-number">5.2.3.4.5.</span> <span class="nav-text">undolog、redolog、binlog的产生</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undolog%E3%80%81redolog%E3%80%81binlog%E7%9A%84%E9%87%8A%E6%94%BE"><span class="nav-number">5.2.3.4.6.</span> <span class="nav-text">undolog、redolog、binlog的释放</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#redolog%E5%92%8Cbinlog%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.3.4.7.</span> <span class="nav-text">redolog和binlog的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#redolog%E5%92%8Cbinlog%E7%9A%84%E4%B8%BB%E4%BB%8E%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">5.2.3.4.8.</span> <span class="nav-text">redolog和binlog的主从一致性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Scope"><span class="nav-number">5.2.3.5.</span> <span class="nav-text">Scope</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Problem"><span class="nav-number">5.2.4.</span> <span class="nav-text">Problem</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C"><span class="nav-number">5.2.4.1.</span> <span class="nav-text">并发操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-number">5.2.4.2.</span> <span class="nav-text">读写分离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1"><span class="nav-number">5.2.4.3.</span> <span class="nav-text">数据丢失</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Performance"><span class="nav-number">5.2.5.</span> <span class="nav-text">Performance</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#explain"><span class="nav-number">5.2.5.1.</span> <span class="nav-text">explain</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#explain%E7%9A%84%E8%BE%93%E5%87%BA%E8%AF%B4%E6%98%8E"><span class="nav-number">5.2.5.1.1.</span> <span class="nav-text">explain的输出说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#explain%E7%9A%84Type%E8%AF%B4%E6%98%8E"><span class="nav-number">5.2.5.1.2.</span> <span class="nav-text">explain的Type说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#explain%E7%9A%84Extra%E8%AF%B4%E6%98%8E"><span class="nav-number">5.2.5.1.3.</span> <span class="nav-text">explain的Extra说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Architecture"><span class="nav-number">5.2.6.</span> <span class="nav-text">Architecture</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Replication"><span class="nav-number">5.2.6.1.</span> <span class="nav-text">Replication</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">5.2.6.1.1.</span> <span class="nav-text">主从复制过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.2.6.1.2.</span> <span class="nav-text">主从复制模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="nav-number">5.2.6.1.3.</span> <span class="nav-text">主从复制文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cluster"><span class="nav-number">5.2.6.2.</span> <span class="nav-text">Cluster</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Distributed-1"><span class="nav-number">5.2.6.3.</span> <span class="nav-text">Distributed</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Theory-1"><span class="nav-number">5.2.7.</span> <span class="nav-text">Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B-%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%81B-%E6%A0%91%E8%AF%A6%E8%A7%A3"><span class="nav-number">5.2.7.1.</span> <span class="nav-text">mysql为什么用B+树而不是红黑树、B-树详解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-1"><span class="nav-number">5.3.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-1"><span class="nav-number">5.3.1.</span> <span class="nav-text">Basic</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Concept-1"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">Concept</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Redis%E5%92%8CMemcached%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.3.1.1.1.</span> <span class="nav-text">Redis和Memcached的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Usage-1"><span class="nav-number">5.3.2.</span> <span class="nav-text">Usage</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Type-1"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">Type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Expire"><span class="nav-number">5.3.2.2.</span> <span class="nav-text">Expire</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="nav-number">5.3.2.2.1.</span> <span class="nav-text">缓存过期策略</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Eliminate"><span class="nav-number">5.3.2.3.</span> <span class="nav-text">Eliminate</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">5.3.2.3.1.</span> <span class="nav-text">内存淘汰策略</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Update"><span class="nav-number">5.3.2.4.</span> <span class="nav-text">Update</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-number">5.3.2.4.1.</span> <span class="nav-text">缓存更新策略</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Scene"><span class="nav-number">5.3.2.5.</span> <span class="nav-text">Scene</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Structure"><span class="nav-number">5.3.2.6.</span> <span class="nav-text">Structure</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%BC%96%E7%A0%81"><span class="nav-number">5.3.2.6.1.</span> <span class="nav-text">数据结构和编码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8Frehash"><span class="nav-number">5.3.2.6.2.</span> <span class="nav-text">渐进式rehash</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transaction-2"><span class="nav-number">5.3.3.</span> <span class="nav-text">Transaction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Atomicity"><span class="nav-number">5.3.3.1.</span> <span class="nav-text">Atomicity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Isolation"><span class="nav-number">5.3.3.2.</span> <span class="nav-text">Isolation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Durability"><span class="nav-number">5.3.3.3.</span> <span class="nav-text">Durability</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RDB"><span class="nav-number">5.3.3.3.1.</span> <span class="nav-text">RDB</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AOF"><span class="nav-number">5.3.3.3.2.</span> <span class="nav-text">AOF</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RDB%E5%92%8CAOF%E6%B7%B7%E5%90%88"><span class="nav-number">5.3.3.3.3.</span> <span class="nav-text">RDB和AOF混合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Problem-1"><span class="nav-number">5.3.4.</span> <span class="nav-text">Problem</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88"><span class="nav-number">5.3.4.1.</span> <span class="nav-text">缓存失效</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">5.3.4.2.</span> <span class="nav-text">缓存一致性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1-1"><span class="nav-number">5.3.4.3.</span> <span class="nav-text">数据丢失</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Performance-1"><span class="nav-number">5.3.5.</span> <span class="nav-text">Performance</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8redis"><span class="nav-number">5.3.5.1.</span> <span class="nav-text">为什么要使用redis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="nav-number">5.3.5.2.</span> <span class="nav-text">redis为什么这么快</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis%E4%B8%BA%E4%BB%80%E4%B9%88QPS%E8%BF%99%E4%B9%88%E9%AB%98"><span class="nav-number">5.3.5.3.</span> <span class="nav-text">redis为什么QPS这么高</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis6-0%E4%B9%8B%E5%89%8D%E7%9C%9F%E7%9A%84%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%90%97"><span class="nav-number">5.3.5.4.</span> <span class="nav-text">redis6.0之前真的是单线程吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis6-0%E4%B9%8B%E5%89%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.3.5.5.</span> <span class="nav-text">redis6.0之前为什么不使用多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis6-0%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.3.5.6.</span> <span class="nav-text">redis6.0之后为什么要引入多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis%E9%94%AE%E5%90%8D%E9%95%BF%E5%BA%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%80%A7%E8%83%BD%E5%90%97"><span class="nav-number">5.3.5.7.</span> <span class="nav-text">redis键名长度会影响性能吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis%E5%A4%A7key%EF%BC%88BigKey%EF%BC%89%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="nav-number">5.3.5.8.</span> <span class="nav-text">redis大key（BigKey）问题如何优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis%E7%83%ADkey%EF%BC%88HotKey%EF%BC%89%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="nav-number">5.3.5.9.</span> <span class="nav-text">redis热key（HotKey）问题如何优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Architecture-1"><span class="nav-number">5.3.6.</span> <span class="nav-text">Architecture</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Replication-1"><span class="nav-number">5.3.6.1.</span> <span class="nav-text">Replication</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B-1"><span class="nav-number">5.3.6.1.1.</span> <span class="nav-text">主从复制过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F-1"><span class="nav-number">5.3.6.1.2.</span> <span class="nav-text">主从复制模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cluster-1"><span class="nav-number">5.3.6.2.</span> <span class="nav-text">Cluster</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Distributed-2"><span class="nav-number">5.3.6.3.</span> <span class="nav-text">Distributed</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#redis%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AFhash%E6%A7%BD%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7hash"><span class="nav-number">5.3.6.3.1.</span> <span class="nav-text">redis为什么使用的是hash槽而不是一致性hash</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#redis%E7%9A%84hash%E6%A7%BD%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF16384%E4%B8%AA"><span class="nav-number">5.3.6.3.2.</span> <span class="nav-text">redis的hash槽为什么是16384个</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Application"><span class="nav-number">5.3.7.</span> <span class="nav-text">Application</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Lock-2"><span class="nav-number">5.3.7.1.</span> <span class="nav-text">Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">5.3.7.1.1.</span> <span class="nav-text">如何用redis实现分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#setnx"><span class="nav-number">5.3.7.1.1.1.</span> <span class="nav-text">setnx</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#setnx-expire"><span class="nav-number">5.3.7.1.1.2.</span> <span class="nav-text">setnx + expire</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#set-ex-nx"><span class="nav-number">5.3.7.1.1.3.</span> <span class="nav-text">set + ex + nx</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#check-set%EF%BC%88%E5%91%BD%E4%BB%A4%E7%89%88%EF%BC%89"><span class="nav-number">5.3.7.1.1.4.</span> <span class="nav-text">check + set（命令版）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#check-set%EF%BC%88%E8%84%9A%E6%9C%AC%E7%89%88%EF%BC%89"><span class="nav-number">5.3.7.1.1.5.</span> <span class="nav-text">check + set（脚本版）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#check-set%EF%BC%88%E7%9C%8B%E9%97%A8%E7%8B%97%EF%BC%89"><span class="nav-number">5.3.7.1.1.6.</span> <span class="nav-text">check + set（看门狗）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Limiter"><span class="nav-number">5.3.7.2.</span> <span class="nav-text">Limiter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DelayQueue"><span class="nav-number">5.3.7.3.</span> <span class="nav-text">DelayQueue</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Theory-2"><span class="nav-number">5.3.8.</span> <span class="nav-text">Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#redis%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E8%B7%B3%E8%A1%A8%E8%80%8C%E4%B8%8D%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3"><span class="nav-number">5.3.8.1.</span> <span class="nav-text">redis为什么用跳表而不是红黑树详解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mq"><span class="nav-number">5.4.</span> <span class="nav-text">Mq</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reliability"><span class="nav-number">5.4.1.</span> <span class="nav-text">Reliability</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RabbitMQ"><span class="nav-number">5.4.1.1.</span> <span class="nav-text">RabbitMQ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RocketMQ"><span class="nav-number">5.4.1.2.</span> <span class="nav-text">RocketMQ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka"><span class="nav-number">5.4.1.3.</span> <span class="nav-text">Kafka</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Problem-2"><span class="nav-number">5.4.2.</span> <span class="nav-text">Problem</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1"><span class="nav-number">5.4.2.1.</span> <span class="nav-text">消息丢失</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D"><span class="nav-number">5.4.2.2.</span> <span class="nav-text">消息重复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%B9%B1%E5%BA%8F"><span class="nav-number">5.4.2.3.</span> <span class="nav-text">消息乱序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B"><span class="nav-number">5.4.2.4.</span> <span class="nav-text">消息积压</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%BA%A2%E5%87%BA"><span class="nav-number">5.4.2.5.</span> <span class="nav-text">消息溢出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Performance-2"><span class="nav-number">5.4.3.</span> <span class="nav-text">Performance</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="nav-number">5.4.3.1.</span> <span class="nav-text">Kafka为什么这么快</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Network-1"><span class="nav-number">5.5.</span> <span class="nav-text">Network</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OSI"><span class="nav-number">5.5.1.</span> <span class="nav-text">OSI</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OSI%E7%9A%847%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.5.1.1.</span> <span class="nav-text">OSI的7层模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-x2F-IP%E7%9A%845%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.5.1.2.</span> <span class="nav-text">TCP&#x2F;IP的5层模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP"><span class="nav-number">5.5.2.</span> <span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.5.2.1.</span> <span class="nav-text">TCP和UDP的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84"><span class="nav-number">5.5.2.2.</span> <span class="nav-text">TCP如何保证可靠传输的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">5.5.2.3.</span> <span class="nav-text">TCP的三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">5.5.2.4.</span> <span class="nav-text">TCP的四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E7%9A%84%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="nav-number">5.5.2.5.</span> <span class="nav-text">TCP的重传机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">5.5.2.6.</span> <span class="nav-text">TCP的滑动窗口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">5.5.2.7.</span> <span class="nav-text">TCP的流量控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">5.5.2.8.</span> <span class="nav-text">TCP的拥塞控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E7%9A%84TIME-WAIT%E5%92%8CCLOSE-WAIT"><span class="nav-number">5.5.2.9.</span> <span class="nav-text">TCP的TIME_WAIT和CLOSE_WAIT</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Web-2"><span class="nav-number">5.6.</span> <span class="nav-text">Web</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Http"><span class="nav-number">5.6.1.</span> <span class="nav-text">Http</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.6.1.1.</span> <span class="nav-text">GET和POST的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.6.1.2.</span> <span class="nav-text">Cookie和Session的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">5.6.1.3.</span> <span class="nav-text">输入url到显示页面的全过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Http%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">5.6.1.4.</span> <span class="nav-text">Http常用的状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Http%E5%92%8CHttps%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.6.1.5.</span> <span class="nav-text">Http和Https的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Distributed-3"><span class="nav-number">5.7.</span> <span class="nav-text">Distributed</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CAP"><span class="nav-number">5.7.1.</span> <span class="nav-text">CAP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BASE"><span class="nav-number">5.7.2.</span> <span class="nav-text">BASE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8Fid"><span class="nav-number">5.7.3.</span> <span class="nav-text">分布式id</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">5.7.4.</span> <span class="nav-text">分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">5.7.5.</span> <span class="nav-text">分布式事务</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="朱继鹏"
      src="/images/avatar/zhujipeng.jpg">
  <p class="site-author-name" itemprop="name">朱继鹏</p>
  <div class="site-description" itemprop="description">在全栈的路上狂奔不止</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">107</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jipengzhu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jipengzhu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jipengzhu@qq.com" title="E-Mail → mailto:jipengzhu@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朱继鹏</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
